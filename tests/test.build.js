/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "http://localhost:8888/tests";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	__webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _expect = __webpack_require__(2);

	var _expect2 = _interopRequireDefault(_expect);

	var _mocha = __webpack_require__(25);

	var _mocha2 = _interopRequireDefault(_mocha);

	var _expectJsx = __webpack_require__(130);

	var _expectJsx2 = _interopRequireDefault(_expectJsx);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import {createRenderer} from "react-addons-test-utils";
	//import {describe, it} from "mocha";

	_expect2.default.extend(_expectJsx2.default);

	//import Home from "./home";

	//import React from "react";
	console.log('ABOUT TO TEST!!!');

	_mocha2.default.describe("Home", function () {
	    _mocha2.default.it("is", function () {
	        (0, _expect2.default)(true).to.equal(true);
	    });
	});

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Expectation = __webpack_require__(3);

	var _Expectation2 = _interopRequireDefault(_Expectation);

	var _SpyUtils = __webpack_require__(22);

	var _assert = __webpack_require__(20);

	var _assert2 = _interopRequireDefault(_assert);

	var _extend = __webpack_require__(24);

	var _extend2 = _interopRequireDefault(_extend);

	function expect(actual) {
	  return new _Expectation2['default'](actual);
	}

	expect.createSpy = _SpyUtils.createSpy;
	expect.spyOn = _SpyUtils.spyOn;
	expect.isSpy = _SpyUtils.isSpy;
	expect.restoreSpies = _SpyUtils.restoreSpies;
	expect.assert = _assert2['default'];
	expect.extend = _extend2['default'];

	exports['default'] = expect;
	module.exports = exports['default'];

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _isEqual = __webpack_require__(4);

	var _isEqual2 = _interopRequireDefault(_isEqual);

	var _isRegex = __webpack_require__(15);

	var _isRegex2 = _interopRequireDefault(_isRegex);

	var _assert = __webpack_require__(20);

	var _assert2 = _interopRequireDefault(_assert);

	var _SpyUtils = __webpack_require__(22);

	var _TestUtils = __webpack_require__(23);

	/**
	 * An Expectation is a wrapper around an assertion that allows it to be written
	 * in a more natural style, without the need to remember the order of arguments.
	 * This helps prevent you from making mistakes when writing tests.
	 */

	var Expectation = (function () {
	  function Expectation(actual) {
	    _classCallCheck(this, Expectation);

	    this.actual = actual;

	    if (_TestUtils.isFunction(actual)) {
	      this.context = null;
	      this.args = [];
	    }
	  }

	  Expectation.prototype.toExist = function toExist(message) {
	    _assert2['default'](this.actual, message || 'Expected %s to exist', this.actual);

	    return this;
	  };

	  Expectation.prototype.toNotExist = function toNotExist(message) {
	    _assert2['default'](!this.actual, message || 'Expected %s to not exist', this.actual);

	    return this;
	  };

	  Expectation.prototype.toBe = function toBe(value, message) {
	    _assert2['default'](this.actual === value, message || 'Expected %s to be %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toNotBe = function toNotBe(value, message) {
	    _assert2['default'](this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toEqual = function toEqual(value, message) {
	    try {
	      _assert2['default'](_isEqual2['default'](this.actual, value), message || 'Expected %s to equal %s', this.actual, value);
	    } catch (e) {
	      // These attributes are consumed by Mocha to produce a diff output.
	      e.showDiff = true;
	      e.actual = this.actual;
	      e.expected = value;
	      throw e;
	    }

	    return this;
	  };

	  Expectation.prototype.toNotEqual = function toNotEqual(value, message) {
	    _assert2['default'](!_isEqual2['default'](this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toThrow = function toThrow(value, message) {
	    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);

	    _assert2['default'](_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');

	    return this;
	  };

	  Expectation.prototype.toNotThrow = function toNotThrow(value, message) {
	    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);

	    _assert2['default'](!_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');

	    return this;
	  };

	  Expectation.prototype.toBeA = function toBeA(value, message) {
	    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toBeA(value) must be a function or a string');

	    _assert2['default'](_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toNotBeA = function toNotBeA(value, message) {
	    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toNotBeA(value) must be a function or a string');

	    _assert2['default'](!_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toMatch = function toMatch(pattern, message) {
	    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toMatch() must be a string');

	    _assert2['default'](_isRegex2['default'](pattern), 'The "value" argument in toMatch(value) must be a RegExp');

	    _assert2['default'](pattern.test(this.actual), message || 'Expected %s to match %s', this.actual, pattern);

	    return this;
	  };

	  Expectation.prototype.toNotMatch = function toNotMatch(pattern, message) {
	    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toNotMatch() must be a string');

	    _assert2['default'](_isRegex2['default'](pattern), 'The "value" argument in toNotMatch(value) must be a RegExp');

	    _assert2['default'](!pattern.test(this.actual), message || 'Expected %s to not match %s', this.actual, pattern);

	    return this;
	  };

	  Expectation.prototype.toBeLessThan = function toBeLessThan(value, message) {
	    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThan() must be a number');

	    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeLessThan(value) must be a number');

	    _assert2['default'](this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toBeLessThanOrEqualTo = function toBeLessThanOrEqualTo(value, message) {
	    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThanOrEqualTo() must be a number');

	    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeLessThanOrEqualTo(value) must be a number');

	    _assert2['default'](this.actual <= value, message || 'Expected %s to be less than or equal to %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toBeGreaterThan = function toBeGreaterThan(value, message) {
	    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThan() must be a number');

	    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeGreaterThan(value) must be a number');

	    _assert2['default'](this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toBeGreaterThanOrEqualTo = function toBeGreaterThanOrEqualTo(value, message) {
	    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThanOrEqualTo() must be a number');

	    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeGreaterThanOrEqualTo(value) must be a number');

	    _assert2['default'](this.actual >= value, message || 'Expected %s to be greater than or equal to %s', this.actual, value);

	    return this;
	  };

	  Expectation.prototype.toInclude = function toInclude(value, compareValues, message) {
	    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toInclude() must be an array or a string');

	    if (typeof compareValues === 'string') {
	      message = compareValues;
	      compareValues = null;
	    }

	    message = message || 'Expected %s to include %s';

	    if (_TestUtils.isArray(this.actual)) {
	      _assert2['default'](_TestUtils.arrayContains(this.actual, value, compareValues), message, this.actual, value);
	    } else {
	      _assert2['default'](_TestUtils.stringContains(this.actual, value), message, this.actual, value);
	    }

	    return this;
	  };

	  Expectation.prototype.toExclude = function toExclude(value, compareValues, message) {
	    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toExclude() must be an array or a string');

	    if (typeof compareValues === 'string') {
	      message = compareValues;
	      compareValues = null;
	    }

	    message = message || 'Expected %s to exclude %s';

	    if (_TestUtils.isArray(this.actual)) {
	      _assert2['default'](!_TestUtils.arrayContains(this.actual, value, compareValues), message, this.actual, value);
	    } else {
	      _assert2['default'](!_TestUtils.stringContains(this.actual, value), message, this.actual, value);
	    }

	    return this;
	  };

	  Expectation.prototype.toHaveBeenCalled = function toHaveBeenCalled(message) {
	    var spy = this.actual;

	    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalled() must be a spy');

	    _assert2['default'](spy.calls.length > 0, message || 'spy was not called');

	    return this;
	  };

	  Expectation.prototype.toHaveBeenCalledWith = function toHaveBeenCalledWith() {
	    var spy = this.actual;

	    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalledWith() must be a spy');

	    var expectedArgs = Array.prototype.slice.call(arguments, 0);

	    _assert2['default'](spy.calls.some(function (call) {
	      return _isEqual2['default'](call.arguments, expectedArgs);
	    }), 'spy was never called with %s', expectedArgs);

	    return this;
	  };

	  Expectation.prototype.toNotHaveBeenCalled = function toNotHaveBeenCalled(message) {
	    var spy = this.actual;

	    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toNotHaveBeenCalled() must be a spy');

	    _assert2['default'](spy.calls.length === 0, message || 'spy was not supposed to be called');

	    return this;
	  };

	  Expectation.prototype.withContext = function withContext(context) {
	    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withContext() must be a function');

	    this.context = context;

	    return this;
	  };

	  Expectation.prototype.withArgs = function withArgs() {
	    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withArgs() must be a function');

	    if (arguments.length) this.args = this.args.concat(Array.prototype.slice.call(arguments, 0));

	    return this;
	  };

	  return Expectation;
	})();

	var aliases = {
	  toBeAn: 'toBeA',
	  toNotBeAn: 'toNotBeA',
	  toBeTruthy: 'toExist',
	  toBeFalsy: 'toNotExist',
	  toBeFewerThan: 'toBeLessThan',
	  toBeMoreThan: 'toBeGreaterThan',
	  toContain: 'toInclude',
	  toNotContain: 'toExclude'
	};

	for (var alias in aliases) {
	  Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];
	}exports['default'] = Expectation;
	module.exports = exports['default'];

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var whyNotEqual = __webpack_require__(5);

	module.exports = function isEqual(value, other) {
		return whyNotEqual(value, other) === '';
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ObjectPrototype = Object.prototype;
	var toStr = ObjectPrototype.toString;
	var booleanValue = Boolean.prototype.valueOf;
	var has = __webpack_require__(6);
	var isArrowFunction = __webpack_require__(9);
	var isBoolean = __webpack_require__(11);
	var isDate = __webpack_require__(12);
	var isGenerator = __webpack_require__(13);
	var isNumber = __webpack_require__(14);
	var isRegex = __webpack_require__(15);
	var isString = __webpack_require__(16);
	var isSymbol = __webpack_require__(17);
	var isCallable = __webpack_require__(10);

	var isProto = Object.prototype.isPrototypeOf;

	var foo = function foo() {};
	var functionsHaveNames = foo.name === 'foo';

	var symbolValue = typeof Symbol === 'function' ? Symbol.prototype.valueOf : null;
	var symbolIterator = __webpack_require__(18)();

	var collectionsForEach = __webpack_require__(19)();

	var getPrototypeOf = Object.getPrototypeOf;
	if (!getPrototypeOf) {
		/* eslint-disable no-proto */
		if (typeof 'test'.__proto__ === 'object') {
			getPrototypeOf = function (obj) {
				return obj.__proto__;
			};
		} else {
			getPrototypeOf = function (obj) {
				var constructor = obj.constructor,
					oldConstructor;
				if (has(obj, 'constructor')) {
					oldConstructor = constructor;
					if (!(delete obj.constructor)) { // reset constructor
						return null; // can't delete obj.constructor, return null
					}
					constructor = obj.constructor; // get real constructor
					obj.constructor = oldConstructor; // restore constructor
				}
				return constructor ? constructor.prototype : ObjectPrototype; // needed for IE
			};
		}
		/* eslint-enable no-proto */
	}

	var isArray = Array.isArray || function (value) {
		return toStr.call(value) === '[object Array]';
	};

	var normalizeFnWhitespace = function normalizeFnWhitespace(fnStr) {
		// this is needed in IE 9, at least, which has inconsistencies here.
		return fnStr.replace(/^function ?\(/, 'function (').replace('){', ') {');
	};

	var tryMapSetEntries = function tryMapSetEntries(collection) {
		var foundEntries = [];
		try {
			collectionsForEach.Map.call(collection, function (key, value) {
				foundEntries.push([key, value]);
			});
		} catch (notMap) {
			try {
				collectionsForEach.Set.call(collection, function (value) {
					foundEntries.push([value]);
				});
			} catch (notSet) {
				return false;
			}
		}
		return foundEntries;
	};

	module.exports = function whyNotEqual(value, other) {
		if (value === other) { return ''; }
		if (value == null || other == null) {
			return value === other ? '' : String(value) + ' !== ' + String(other);
		}

		var valToStr = toStr.call(value);
		var otherToStr = toStr.call(value);
		if (valToStr !== otherToStr) {
			return 'toStringTag is not the same: ' + valToStr + ' !== ' + otherToStr;
		}

		var valIsBool = isBoolean(value);
		var otherIsBool = isBoolean(other);
		if (valIsBool || otherIsBool) {
			if (!valIsBool) { return 'first argument is not a boolean; second argument is'; }
			if (!otherIsBool) { return 'second argument is not a boolean; first argument is'; }
			var valBoolVal = booleanValue.call(value);
			var otherBoolVal = booleanValue.call(other);
			if (valBoolVal === otherBoolVal) { return ''; }
			return 'primitive value of boolean arguments do not match: ' + valBoolVal + ' !== ' + otherBoolVal;
		}

		var valIsNumber = isNumber(value);
		var otherIsNumber = isNumber(value);
		if (valIsNumber || otherIsNumber) {
			if (!valIsNumber) { return 'first argument is not a number; second argument is'; }
			if (!otherIsNumber) { return 'second argument is not a number; first argument is'; }
			var valNum = Number(value);
			var otherNum = Number(other);
			if (valNum === otherNum) { return ''; }
			var valIsNaN = isNaN(value);
			var otherIsNaN = isNaN(other);
			if (valIsNaN && !otherIsNaN) {
				return 'first argument is NaN; second is not';
			} else if (!valIsNaN && otherIsNaN) {
				return 'second argument is NaN; first is not';
			} else if (valIsNaN && otherIsNaN) {
				return '';
			}
			return 'numbers are different: ' + value + ' !== ' + other;
		}

		var valIsString = isString(value);
		var otherIsString = isString(other);
		if (valIsString || otherIsString) {
			if (!valIsString) { return 'second argument is string; first is not'; }
			if (!otherIsString) { return 'first argument is string; second is not'; }
			var stringVal = String(value);
			var otherVal = String(other);
			if (stringVal === otherVal) { return ''; }
			return 'string values are different: "' + stringVal + '" !== "' + otherVal + '"';
		}

		var valIsDate = isDate(value);
		var otherIsDate = isDate(other);
		if (valIsDate || otherIsDate) {
			if (!valIsDate) { return 'second argument is Date, first is not'; }
			if (!otherIsDate) { return 'first argument is Date, second is not'; }
			var valTime = +value;
			var otherTime = +other;
			if (valTime === otherTime) { return ''; }
			return 'Dates have different time values: ' + valTime + ' !== ' + otherTime;
		}

		var valIsRegex = isRegex(value);
		var otherIsRegex = isRegex(other);
		if (valIsRegex || otherIsRegex) {
			if (!valIsRegex) { return 'second argument is RegExp, first is not'; }
			if (!otherIsRegex) { return 'first argument is RegExp, second is not'; }
			var regexStringVal = String(value);
			var regexStringOther = String(other);
			if (regexStringVal === regexStringOther) { return ''; }
			return 'regular expressions differ: ' + regexStringVal + ' !== ' + regexStringOther;
		}

		var valIsArray = isArray(value);
		var otherIsArray = isArray(other);
		if (valIsArray || otherIsArray) {
			if (!valIsArray) { return 'second argument is an Array, first is not'; }
			if (!otherIsArray) { return 'first argument is an Array, second is not'; }
			if (value.length !== other.length) {
				return 'arrays have different length: ' + value.length + ' !== ' + other.length;
			}
			if (String(value) !== String(other)) { return 'stringified Arrays differ'; }

			var index = value.length - 1;
			var equal = '';
			var valHasIndex, otherHasIndex;
			while (equal === '' && index >= 0) {
				valHasIndex = has(value, index);
				otherHasIndex = has(other, index);
				if (!valHasIndex && otherHasIndex) { return 'second argument has index ' + index + '; first does not'; }
				if (valHasIndex && !otherHasIndex) { return 'first argument has index ' + index + '; second does not'; }
				equal = whyNotEqual(value[index], other[index]);
				index -= 1;
			}
			return equal;
		}

		var valueIsSym = isSymbol(value);
		var otherIsSym = isSymbol(other);
		if (valueIsSym !== otherIsSym) {
			if (valueIsSym) { return 'first argument is Symbol; second is not'; }
			return 'second argument is Symbol; first is not';
		}
		if (valueIsSym && otherIsSym) {
			return symbolValue.call(value) === symbolValue.call(other) ? '' : 'first Symbol value !== second Symbol value';
		}

		var valueIsGen = isGenerator(value);
		var otherIsGen = isGenerator(other);
		if (valueIsGen !== otherIsGen) {
			if (valueIsGen) { return 'first argument is a Generator; second is not'; }
			return 'second argument is a Generator; first is not';
		}

		var valueIsArrow = isArrowFunction(value);
		var otherIsArrow = isArrowFunction(other);
		if (valueIsArrow !== otherIsArrow) {
			if (valueIsArrow) { return 'first argument is an Arrow function; second is not'; }
			return 'second argument is an Arrow function; first is not';
		}

		if (isCallable(value) || isCallable(other)) {
			if (functionsHaveNames && whyNotEqual(value.name, other.name) !== '') {
				return 'Function names differ: "' + value.name + '" !== "' + other.name + '"';
			}
			if (whyNotEqual(value.length, other.length) !== '') {
				return 'Function lengths differ: ' + value.length + ' !== ' + other.length;
			}

			var valueStr = normalizeFnWhitespace(String(value));
			var otherStr = normalizeFnWhitespace(String(other));
			if (whyNotEqual(valueStr, otherStr) === '') { return ''; }

			if (!valueIsGen && !valueIsArrow) {
				return whyNotEqual(valueStr.replace(/\)\s*\{/, '){'), otherStr.replace(/\)\s*\{/, '){')) === '' ? '' : 'Function string representations differ';
			}
			return whyNotEqual(valueStr, otherStr) === '' ? '' : 'Function string representations differ';
		}

		if (typeof value === 'object' || typeof other === 'object') {
			if (typeof value !== typeof other) { return 'arguments have a different typeof: ' + typeof value + ' !== ' + typeof other; }
			if (isProto.call(value, other)) { return 'first argument is the [[Prototype]] of the second'; }
			if (isProto.call(other, value)) { return 'second argument is the [[Prototype]] of the first'; }
			if (getPrototypeOf(value) !== getPrototypeOf(other)) { return 'arguments have a different [[Prototype]]'; }

			if (symbolIterator) {
				var valueIteratorFn = value[symbolIterator];
				var valueIsIterable = isCallable(valueIteratorFn);
				var otherIteratorFn = other[symbolIterator];
				var otherIsIterable = isCallable(otherIteratorFn);
				if (valueIsIterable !== otherIsIterable) {
					if (valueIsIterable) { return 'first argument is iterable; second is not'; }
					return 'second argument is iterable; first is not';
				}
				if (valueIsIterable && otherIsIterable) {
					var valueIterator = valueIteratorFn.call(value);
					var otherIterator = otherIteratorFn.call(other);
					var valueNext, otherNext, nextWhy;
					do {
						valueNext = valueIterator.next();
						otherNext = otherIterator.next();
						if (!valueNext.done && !otherNext.done) {
							nextWhy = whyNotEqual(valueNext, otherNext);
							if (nextWhy !== '') {
								return 'iteration results are not equal: ' + nextWhy;
							}
						}
					} while (!valueNext.done && !otherNext.done);
					if (valueNext.done && !otherNext.done) { return 'first argument finished iterating before second'; }
					if (!valueNext.done && otherNext.done) { return 'second argument finished iterating before first'; }
					return '';
				}
			} else if (collectionsForEach.Map || collectionsForEach.Set) {
				var valueEntries = tryMapSetEntries(value);
				var otherEntries = tryMapSetEntries(other);
				var valueEntriesIsArray = isArray(valueEntries);
				var otherEntriesIsArray = isArray(otherEntries);
				if (valueEntriesIsArray && !otherEntriesIsArray) { return 'first argument has Collection entries, second does not'; }
				if (!valueEntriesIsArray && otherEntriesIsArray) { return 'second argument has Collection entries, first does not'; }
				if (valueEntriesIsArray && otherEntriesIsArray) {
					var entriesWhy = whyNotEqual(valueEntries, otherEntries);
					return entriesWhy === '' ? '' : 'Collection entries differ: ' + entriesWhy;
				}
			}

			var key, valueKeyIsRecursive, otherKeyIsRecursive, keyWhy;
			for (key in value) {
				if (has(value, key)) {
					if (!has(other, key)) { return 'first argument has key "' + key + '"; second does not'; }
					valueKeyIsRecursive = value[key] && value[key][key] === value;
					otherKeyIsRecursive = other[key] && other[key][key] === other;
					if (valueKeyIsRecursive !== otherKeyIsRecursive) {
						if (valueKeyIsRecursive) { return 'first argument has a circular reference at key "' + key + '"; second does not'; }
						return 'second argument has a circular reference at key "' + key + '"; second does not';
					}
					if (!valueKeyIsRecursive && !otherKeyIsRecursive) {
						keyWhy = whyNotEqual(value[key], other[key]);
						if (keyWhy !== '') {
							return 'value at key "' + key + '" differs: ' + keyWhy;
						}
					}
				}
			}
			for (key in other) {
				if (has(other, key)) {
					if (!has(value, key)) { return 'second argument has key "' + key + '"; first does not'; }
					valueKeyIsRecursive = value[key] && value[key][key] === value;
					otherKeyIsRecursive = other[key] && other[key][key] === other;
					if (valueKeyIsRecursive !== otherKeyIsRecursive) {
						if (valueKeyIsRecursive) { return 'first argument has a circular reference at key "' + key + '"; second does not'; }
						return 'second argument has a circular reference at key "' + key + '"; second does not';
					}
					if (!valueKeyIsRecursive && !otherKeyIsRecursive) {
						keyWhy = whyNotEqual(other[key], value[key]);
						if (keyWhy !== '') {
							return 'value at key "' + key + '" differs: ' + keyWhy;
						}
					}
				}
			}
			return '';
		}

		return false;
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var bind = __webpack_require__(7);

	module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var implementation = __webpack_require__(8);

	module.exports = Function.prototype.bind || implementation;


/***/ },
/* 8 */
/***/ function(module, exports) {

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';

	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isCallable = __webpack_require__(10);
	var fnToStr = Function.prototype.toString;
	var isNonArrowFnRegex = /^\s*function/;
	var isArrowFnWithParensRegex = /^\([^\)]*\) *=>/;
	var isArrowFnWithoutParensRegex = /^[^=]*=>/;

	module.exports = function isArrowFunction(fn) {
		if (!isCallable(fn)) { return false; }
		var fnStr = fnToStr.call(fn);
		return fnStr.length > 0 &&
			!isNonArrowFnRegex.test(fnStr) &&
			(isArrowFnWithParensRegex.test(fnStr) || isArrowFnWithoutParensRegex.test(fnStr));
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	var fnToStr = Function.prototype.toString;

	var constructorRegex = /\s*class /;
	var isES6ClassFn = function isES6ClassFn(value) {
		try {
			var fnStr = fnToStr.call(value);
			var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
			var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
			var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
			return constructorRegex.test(spaceStripped);
		} catch (e) {
			return false; // not a function
		}
	};

	var tryFunctionObject = function tryFunctionObject(value) {
		try {
			if (isES6ClassFn(value)) { return false; }
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';

	var boolToStr = Boolean.prototype.toString;

	var tryBooleanObject = function tryBooleanObject(value) {
		try {
			boolToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var boolClass = '[object Boolean]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isBoolean(value) {
		if (typeof value === 'boolean') { return true; }
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryBooleanObject(value) : toStr.call(value) === boolClass;
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateObject(value) {
		try {
			getDay.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};

	var toStr = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isDateObject(value) {
		if (typeof value !== 'object' || value === null) { return false; }
		return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
	};


/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;
	var fnToStr = Function.prototype.toString;
	var isFnRegex = /^\s*function\*/;

	module.exports = function isGeneratorFunction(fn) {
		if (typeof fn !== 'function') { return false; }
		var fnStr = toStr.call(fn);
		return (fnStr === '[object Function]' || fnStr === '[object GeneratorFunction]') && isFnRegex.test(fnToStr.call(fn));
	};



/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';

	var numToStr = Number.prototype.toString;
	var tryNumberObject = function tryNumberObject(value) {
		try {
			numToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var numClass = '[object Number]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isNumberObject(value) {
		if (typeof value === 'number') { return true; }
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
	};


/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	var regexExec = RegExp.prototype.exec;
	var tryRegexExec = function tryRegexExec(value) {
		try {
			regexExec.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var regexClass = '[object RegExp]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isRegex(value) {
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;
	};


/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';

	var strValue = String.prototype.valueOf;
	var tryStringObject = function tryStringObject(value) {
		try {
			strValue.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var strClass = '[object String]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isString(value) {
		if (typeof value === 'string') { return true; }
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
	};


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

	if (hasSymbols) {
		var symToStr = Symbol.prototype.toString;
		var symStringRegex = /^Symbol\(.*\)$/;
		var isSymbolObject = function isSymbolObject(value) {
			if (typeof value.valueOf() !== 'symbol') { return false; }
			return symStringRegex.test(symToStr.call(value));
		};
		module.exports = function isSymbol(value) {
			if (typeof value === 'symbol') { return true; }
			if (toStr.call(value) !== '[object Symbol]') { return false; }
			try {
				return isSymbolObject(value);
			} catch (e) {
				return false;
			}
		};
	} else {
		module.exports = function isSymbol(value) {
			// this environment does not support Symbols.
			return false;
		};
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isSymbol = __webpack_require__(17);

	module.exports = function getSymbolIterator() {
		var symbolIterator = typeof Symbol === 'function' && isSymbol(Symbol.iterator) ? Symbol.iterator : null;

		if (typeof Object.getOwnPropertyNames === 'function' && typeof Map === 'function' && typeof Map.prototype.entries === 'function') {
			Object.getOwnPropertyNames(Map.prototype).forEach(function (name) {
				if (name !== 'entries' && name !== 'size' && Map.prototype[name] === Map.prototype.entries) {
					symbolIterator = name;
				}
			});
		}

		return symbolIterator;
	};


/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var mapForEach = (function () {
			if (typeof Map !== 'function') { return null; }
			try {
				Map.prototype.forEach.call({}, function () {});
			} catch (e) {
				return Map.prototype.forEach;
			}
			return null;
		}());

		var setForEach = (function () {
			if (typeof Set !== 'function') { return null; }
			try {
				Set.prototype.forEach.call({}, function () {});
			} catch (e) {
				return Set.prototype.forEach;
			}
			return null;
		}());

		return { Map: mapForEach, Set: setForEach };
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _objectInspect = __webpack_require__(21);

	var _objectInspect2 = _interopRequireDefault(_objectInspect);

	function assert(condition, messageFormat) {
	  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    extraArgs[_key - 2] = arguments[_key];
	  }

	  if (condition) return;

	  var index = 0;

	  throw new Error(messageFormat.replace(/%s/g, function () {
	    return _objectInspect2['default'](extraArgs[index++]);
	  }));
	}

	exports['default'] = assert;
	module.exports = exports['default'];

/***/ },
/* 21 */
/***/ function(module, exports) {

	var hasMap = typeof Map === 'function' && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === 'function' && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;

	module.exports = function inspect_ (obj, opts, depth, seen) {
	    if (!opts) opts = {};
	    
	    var maxDepth = opts.depth === undefined ? 5 : opts.depth;
	    if (depth === undefined) depth = 0;
	    if (depth >= maxDepth && maxDepth > 0
	    && obj && typeof obj === 'object') {
	        return '[Object]';
	    }
	    
	    if (seen === undefined) seen = [];
	    else if (indexOf(seen, obj) >= 0) {
	        return '[Circular]';
	    }
	    
	    function inspect (value, from) {
	        if (from) {
	            seen = seen.slice();
	            seen.push(from);
	        }
	        return inspect_(value, opts, depth + 1, seen);
	    }
	    
	    if (typeof obj === 'string') {
	        return inspectString(obj);
	    }
	    else if (typeof obj === 'function') {
	        var name = nameOf(obj);
	        return '[Function' + (name ? ': ' + name : '') + ']';
	    }
	    else if (obj === null) {
	        return 'null';
	    }
	    else if (isSymbol(obj)) {
	        var symString = Symbol.prototype.toString.call(obj);
	        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;
	    }
	    else if (isElement(obj)) {
	        var s = '<' + String(obj.nodeName).toLowerCase();
	        var attrs = obj.attributes || [];
	        for (var i = 0; i < attrs.length; i++) {
	            s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
	        }
	        s += '>';
	        if (obj.childNodes && obj.childNodes.length) s += '...';
	        s += '</' + String(obj.nodeName).toLowerCase() + '>';
	        return s;
	    }
	    else if (isArray(obj)) {
	        if (obj.length === 0) return '[]';
	        var xs = Array(obj.length);
	        for (var i = 0; i < obj.length; i++) {
	            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
	        }
	        return '[ ' + xs.join(', ') + ' ]';
	    }
	    else if (isError(obj)) {
	        var parts = [];
	        for (var key in obj) {
	            if (!has(obj, key)) continue;
	            
	            if (/[^\w$]/.test(key)) {
	                parts.push(inspect(key) + ': ' + inspect(obj[key]));
	            }
	            else {
	                parts.push(key + ': ' + inspect(obj[key]));
	            }
	        }
	        if (parts.length === 0) return '[' + obj + ']';
	        return '{ [' + obj + '] ' + parts.join(', ') + ' }';
	    }
	    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {
	        return obj.inspect();
	    }
	    else if (isMap(obj)) {
	        var parts = [];
	        mapForEach.call(obj, function (value, key) {
	            parts.push(inspect(key, obj) + ' => ' + inspect(value, obj));
	        });
	        return 'Map (' + mapSize.call(obj) + ') {' + parts.join(', ') + '}';
	    }
	    else if (isSet(obj)) {
	        var parts = [];
	        setForEach.call(obj, function (value ) {
	            parts.push(inspect(value, obj));
	        });
	        return 'Set (' + setSize.call(obj) + ') {' + parts.join(', ') + '}';
	    }
	    else if (typeof obj === 'object' && !isDate(obj) && !isRegExp(obj)) {
	        var xs = [], keys = [];
	        for (var key in obj) {
	            if (has(obj, key)) keys.push(key);
	        }
	        keys.sort();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (/[^\w$]/.test(key)) {
	                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));
	            }
	            else xs.push(key + ': ' + inspect(obj[key], obj));
	        }
	        if (xs.length === 0) return '{}';
	        return '{ ' + xs.join(', ') + ' }';
	    }
	    else return String(obj);
	};

	function quote (s) {
	    return String(s).replace(/"/g, '&quot;');
	}

	function isArray (obj) { return toStr(obj) === '[object Array]' }
	function isDate (obj) { return toStr(obj) === '[object Date]' }
	function isRegExp (obj) { return toStr(obj) === '[object RegExp]' }
	function isError (obj) { return toStr(obj) === '[object Error]' }
	function isSymbol (obj) { return toStr(obj) === '[object Symbol]' }

	var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
	function has (obj, key) {
	    return hasOwn.call(obj, key);
	}

	function toStr (obj) {
	    return Object.prototype.toString.call(obj);
	}

	function nameOf (f) {
	    if (f.name) return f.name;
	    var m = f.toString().match(/^function\s*([\w$]+)/);
	    if (m) return m[1];
	}

	function indexOf (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0, l = xs.length; i < l; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	}

	function isMap (x) {
	    if (!mapSize) {
	        return false;
	    }
	    try {
	        mapSize.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isSet (x) {
	    if (!setSize) {
	        return false;
	    }
	    try {
	        setSize.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isElement (x) {
	    if (!x || typeof x !== 'object') return false;
	    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
	        return true;
	    }
	    return typeof x.nodeName === 'string'
	        && typeof x.getAttribute === 'function'
	    ;
	}

	function inspectString (str) {
	    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
	    return "'" + s + "'";
	    
	    function lowbyte (c) {
	        var n = c.charCodeAt(0);
	        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
	        if (x) return '\\' + x;
	        return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
	    }
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.createSpy = createSpy;
	exports.spyOn = spyOn;
	exports.isSpy = isSpy;
	exports.restoreSpies = restoreSpies;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _assert = __webpack_require__(20);

	var _assert2 = _interopRequireDefault(_assert);

	var _TestUtils = __webpack_require__(23);

	function noop() {}

	var spies = [];

	function createSpy(fn) {
	  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];

	  if (fn == null) fn = noop;

	  _assert2['default'](_TestUtils.isFunction(fn), 'createSpy needs a function');

	  var targetFn = undefined,
	      thrownValue = undefined,
	      returnValue = undefined;

	  var spy = function spy() {
	    spy.calls.push({
	      context: this,
	      arguments: Array.prototype.slice.call(arguments, 0)
	    });

	    if (targetFn) return targetFn.apply(this, arguments);

	    if (thrownValue) throw thrownValue;

	    return returnValue;
	  };

	  spy.calls = [];

	  spy.andCall = function (fn) {
	    targetFn = fn;
	    return spy;
	  };

	  spy.andCallThrough = function () {
	    return spy.andCall(fn);
	  };

	  spy.andThrow = function (object) {
	    thrownValue = object;
	    return spy;
	  };

	  spy.andReturn = function (value) {
	    returnValue = value;
	    return spy;
	  };

	  spy.getLastCall = function () {
	    return spy.calls[spy.calls.length - 1];
	  };

	  spy.reset = function () {
	    spy.calls = [];
	  };

	  spy.restore = spy.destroy = restore;

	  spy.__isSpy = true;

	  spies.push(spy);

	  return spy;
	}

	function spyOn(object, methodName) {
	  var original = object[methodName];

	  if (!isSpy(original)) {
	    _assert2['default'](_TestUtils.isFunction(original), 'Cannot spyOn the %s property; it is not a function', methodName);

	    object[methodName] = createSpy(original, function () {
	      object[methodName] = original;
	    });
	  }

	  return object[methodName];
	}

	function isSpy(object) {
	  return object && object.__isSpy === true;
	}

	function restoreSpies() {
	  for (var i = spies.length - 1; i >= 0; i--) {
	    spies[i].restore();
	  }spies = [];
	}

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.functionThrows = functionThrows;
	exports.arrayContains = arrayContains;
	exports.stringContains = stringContains;
	exports.isArray = isArray;
	exports.isFunction = isFunction;
	exports.isA = isA;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _isEqual = __webpack_require__(4);

	var _isEqual2 = _interopRequireDefault(_isEqual);

	var _isRegex = __webpack_require__(15);

	var _isRegex2 = _interopRequireDefault(_isRegex);

	/**
	 * Returns true if the given function throws the given value
	 * when invoked. The value may be:
	 *
	 * - undefined, to merely assert there was a throw
	 * - a constructor function, for comparing using instanceof
	 * - a regular expression, to compare with the error message
	 * - a string, to find in the error message
	 */

	function functionThrows(fn, context, args, value) {
	  try {
	    fn.apply(context, args);
	  } catch (error) {
	    if (value == null) return true;

	    if (isFunction(value) && error instanceof value) return true;

	    var message = error.message || error;

	    if (typeof message === 'string') {
	      if (_isRegex2['default'](value) && value.test(error.message)) return true;

	      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;
	    }
	  }

	  return false;
	}

	/**
	 * Returns true if the given array contains the value, false
	 * otherwise. The compareValues function must return false to
	 * indicate a non-match.
	 */

	function arrayContains(array, value, compareValues) {
	  if (compareValues == null) compareValues = _isEqual2['default'];

	  return array.some(function (item) {
	    return compareValues(item, value) !== false;
	  });
	}

	/**
	 * Returns true if the given string contains the value, false otherwise.
	 */

	function stringContains(string, value) {
	  return string.indexOf(value) !== -1;
	}

	/**
	 * Returns true if the given object is an array.
	 */

	function isArray(object) {
	  return Array.isArray(object);
	}

	/**
	 * Returns true if the given object is a function.
	 */

	function isFunction(object) {
	  return typeof object === 'function';
	}

	/**
	 * Returns true if the given object is an instanceof value
	 * or its typeof is the given value.
	 */

	function isA(object, value) {
	  if (isFunction(value)) return object instanceof value;

	  if (value === 'array') return Array.isArray(object);

	  return typeof object === value;
	}

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Expectation = __webpack_require__(3);

	var _Expectation2 = _interopRequireDefault(_Expectation);

	var Extensions = [];

	function extend(extension) {
	  if (Extensions.indexOf(extension) === -1) {
	    Extensions.push(extension);

	    for (var p in extension) {
	      if (extension.hasOwnProperty(p)) _Expectation2['default'].prototype[p] = extension[p];
	    }
	  }
	}

	exports['default'] = extend;
	module.exports = exports['default'];

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {module.exports = process.env.COV
	  ? __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./lib-cov/mocha\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  : __webpack_require__(27);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 26 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, module, __dirname, global) {/*!
	 * mocha
	 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var escapeRe = __webpack_require__(29);
	var path = __webpack_require__(30);
	var reporters = __webpack_require__(31);
	var utils = __webpack_require__(36);

	/**
	 * Expose `Mocha`.
	 */

	exports = module.exports = Mocha;

	/**
	 * To require local UIs and reporters when running in node.
	 */

	if (!process.browser) {
	  var cwd = process.cwd();
	  module.paths.push(cwd, path.join(cwd, 'node_modules'));
	}

	/**
	 * Expose internals.
	 */

	exports.utils = utils;
	exports.interfaces = __webpack_require__(108);
	exports.reporters = reporters;
	exports.Runnable = __webpack_require__(113);
	exports.Context = __webpack_require__(120);
	exports.Runner = __webpack_require__(121);
	exports.Suite = __webpack_require__(110);
	exports.Hook = __webpack_require__(112);
	exports.Test = __webpack_require__(115);

	/**
	 * Return image `name` path.
	 *
	 * @api private
	 * @param {string} name
	 * @return {string}
	 */
	function image(name) {
	  return path.join(__dirname, '../images', name + '.png');
	}

	/**
	 * Set up mocha with `options`.
	 *
	 * Options:
	 *
	 *   - `ui` name "bdd", "tdd", "exports" etc
	 *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`
	 *   - `globals` array of accepted globals
	 *   - `timeout` timeout in milliseconds
	 *   - `retries` number of times to retry failed tests
	 *   - `bail` bail on the first test failure
	 *   - `slow` milliseconds to wait before considering a test slow
	 *   - `ignoreLeaks` ignore global leaks
	 *   - `fullTrace` display the full stack-trace on failing
	 *   - `grep` string or regexp to filter tests with
	 *
	 * @param {Object} options
	 * @api public
	 */
	function Mocha(options) {
	  options = options || {};
	  this.files = [];
	  this.options = options;
	  if (options.grep) {
	    this.grep(new RegExp(options.grep));
	  }
	  if (options.fgrep) {
	    this.grep(options.fgrep);
	  }
	  this.suite = new exports.Suite('', new exports.Context());
	  this.ui(options.ui);
	  this.bail(options.bail);
	  this.reporter(options.reporter, options.reporterOptions);
	  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {
	    this.timeout(options.timeout);
	  }
	  if (typeof options.retries !== 'undefined' && options.retries !== null) {
	    this.retries(options.retries);
	  }
	  this.useColors(options.useColors);
	  if (options.enableTimeouts !== null) {
	    this.enableTimeouts(options.enableTimeouts);
	  }
	  if (options.slow) {
	    this.slow(options.slow);
	  }

	  this.suite.on('pre-require', function(context) {
	    exports.afterEach = context.afterEach || context.teardown;
	    exports.after = context.after || context.suiteTeardown;
	    exports.beforeEach = context.beforeEach || context.setup;
	    exports.before = context.before || context.suiteSetup;
	    exports.describe = context.describe || context.suite;
	    exports.it = context.it || context.test;
	    exports.setup = context.setup || context.beforeEach;
	    exports.suiteSetup = context.suiteSetup || context.before;
	    exports.suiteTeardown = context.suiteTeardown || context.after;
	    exports.suite = context.suite || context.describe;
	    exports.teardown = context.teardown || context.afterEach;
	    exports.test = context.test || context.it;
	    exports.run = context.run;
	  });
	}

	/**
	 * Enable or disable bailing on the first failure.
	 *
	 * @api public
	 * @param {boolean} [bail]
	 */
	Mocha.prototype.bail = function(bail) {
	  if (!arguments.length) {
	    bail = true;
	  }
	  this.suite.bail(bail);
	  return this;
	};

	/**
	 * Add test `file`.
	 *
	 * @api public
	 * @param {string} file
	 */
	Mocha.prototype.addFile = function(file) {
	  this.files.push(file);
	  return this;
	};

	/**
	 * Set reporter to `reporter`, defaults to "spec".
	 *
	 * @param {String|Function} reporter name or constructor
	 * @param {Object} reporterOptions optional options
	 * @api public
	 * @param {string|Function} reporter name or constructor
	 * @param {Object} reporterOptions optional options
	 */
	Mocha.prototype.reporter = function(reporter, reporterOptions) {
	  if (typeof reporter === 'function') {
	    this._reporter = reporter;
	  } else {
	    reporter = reporter || 'spec';
	    var _reporter;
	    // Try to load a built-in reporter.
	    if (reporters[reporter]) {
	      _reporter = reporters[reporter];
	    }
	    // Try to load reporters from process.cwd() and node_modules
	    if (!_reporter) {
	      try {
	        _reporter = __webpack_require__(122)(reporter);
	      } catch (err) {
	        err.message.indexOf('Cannot find module') !== -1
	          ? console.warn('"' + reporter + '" reporter not found')
	          : console.warn('"' + reporter + '" reporter blew up with error:\n' + err.stack);
	      }
	    }
	    if (!_reporter && reporter === 'teamcity') {
	      console.warn('The Teamcity reporter was moved to a package named '
	        + 'mocha-teamcity-reporter '
	        + '(https://npmjs.org/package/mocha-teamcity-reporter).');
	    }
	    if (!_reporter) {
	      throw new Error('invalid reporter "' + reporter + '"');
	    }
	    this._reporter = _reporter;
	  }
	  this.options.reporterOptions = reporterOptions;
	  return this;
	};

	/**
	 * Set test UI `name`, defaults to "bdd".
	 *
	 * @api public
	 * @param {string} bdd
	 */
	Mocha.prototype.ui = function(name) {
	  name = name || 'bdd';
	  this._ui = exports.interfaces[name];
	  if (!this._ui) {
	    try {
	      this._ui = __webpack_require__(122)(name);
	    } catch (err) {
	      throw new Error('invalid interface "' + name + '"');
	    }
	  }
	  this._ui = this._ui(this.suite);
	  return this;
	};

	/**
	 * Load registered files.
	 *
	 * @api private
	 */
	Mocha.prototype.loadFiles = function(fn) {
	  var self = this;
	  var suite = this.suite;
	  this.files.forEach(function(file) {
	    file = path.resolve(file);
	    suite.emit('pre-require', global, file, self);
	    suite.emit('require', __webpack_require__(122)(file), file, self);
	    suite.emit('post-require', global, file, self);
	  });
	  fn && fn();
	};

	/**
	 * Enable growl support.
	 *
	 * @api private
	 */
	Mocha.prototype._growl = function(runner, reporter) {
	  var notify = __webpack_require__(128);

	  runner.on('end', function() {
	    var stats = reporter.stats;
	    if (stats.failures) {
	      var msg = stats.failures + ' of ' + runner.total + ' tests failed';
	      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });
	    } else {
	      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {
	        name: 'mocha',
	        title: 'Passed',
	        image: image('ok')
	      });
	    }
	  });
	};

	/**
	 * Add regexp to grep, if `re` is a string it is escaped.
	 *
	 * @param {RegExp|String} re
	 * @return {Mocha}
	 * @api public
	 * @param {RegExp|string} re
	 * @return {Mocha}
	 */
	Mocha.prototype.grep = function(re) {
	  this.options.grep = typeof re === 'string' ? new RegExp(escapeRe(re)) : re;
	  return this;
	};

	/**
	 * Invert `.grep()` matches.
	 *
	 * @return {Mocha}
	 * @api public
	 */
	Mocha.prototype.invert = function() {
	  this.options.invert = true;
	  return this;
	};

	/**
	 * Ignore global leaks.
	 *
	 * @param {Boolean} ignore
	 * @return {Mocha}
	 * @api public
	 * @param {boolean} ignore
	 * @return {Mocha}
	 */
	Mocha.prototype.ignoreLeaks = function(ignore) {
	  this.options.ignoreLeaks = Boolean(ignore);
	  return this;
	};

	/**
	 * Enable global leak checking.
	 *
	 * @return {Mocha}
	 * @api public
	 */
	Mocha.prototype.checkLeaks = function() {
	  this.options.ignoreLeaks = false;
	  return this;
	};

	/**
	 * Display long stack-trace on failing
	 *
	 * @return {Mocha}
	 * @api public
	 */
	Mocha.prototype.fullTrace = function() {
	  this.options.fullStackTrace = true;
	  return this;
	};

	/**
	 * Enable growl support.
	 *
	 * @return {Mocha}
	 * @api public
	 */
	Mocha.prototype.growl = function() {
	  this.options.growl = true;
	  return this;
	};

	/**
	 * Ignore `globals` array or string.
	 *
	 * @param {Array|String} globals
	 * @return {Mocha}
	 * @api public
	 * @param {Array|string} globals
	 * @return {Mocha}
	 */
	Mocha.prototype.globals = function(globals) {
	  this.options.globals = (this.options.globals || []).concat(globals);
	  return this;
	};

	/**
	 * Emit color output.
	 *
	 * @param {Boolean} colors
	 * @return {Mocha}
	 * @api public
	 * @param {boolean} colors
	 * @return {Mocha}
	 */
	Mocha.prototype.useColors = function(colors) {
	  if (colors !== undefined) {
	    this.options.useColors = colors;
	  }
	  return this;
	};

	/**
	 * Use inline diffs rather than +/-.
	 *
	 * @param {Boolean} inlineDiffs
	 * @return {Mocha}
	 * @api public
	 * @param {boolean} inlineDiffs
	 * @return {Mocha}
	 */
	Mocha.prototype.useInlineDiffs = function(inlineDiffs) {
	  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;
	  return this;
	};

	/**
	 * Set the timeout in milliseconds.
	 *
	 * @param {Number} timeout
	 * @return {Mocha}
	 * @api public
	 * @param {number} timeout
	 * @return {Mocha}
	 */
	Mocha.prototype.timeout = function(timeout) {
	  this.suite.timeout(timeout);
	  return this;
	};

	/**
	 * Set the number of times to retry failed tests.
	 *
	 * @param {Number} retry times
	 * @return {Mocha}
	 * @api public
	 */
	Mocha.prototype.retries = function(n) {
	  this.suite.retries(n);
	  return this;
	};

	/**
	 * Set slowness threshold in milliseconds.
	 *
	 * @param {Number} slow
	 * @return {Mocha}
	 * @api public
	 * @param {number} slow
	 * @return {Mocha}
	 */
	Mocha.prototype.slow = function(slow) {
	  this.suite.slow(slow);
	  return this;
	};

	/**
	 * Enable timeouts.
	 *
	 * @param {Boolean} enabled
	 * @return {Mocha}
	 * @api public
	 * @param {boolean} enabled
	 * @return {Mocha}
	 */
	Mocha.prototype.enableTimeouts = function(enabled) {
	  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);
	  return this;
	};

	/**
	 * Makes all tests async (accepting a callback)
	 *
	 * @return {Mocha}
	 * @api public
	 */
	Mocha.prototype.asyncOnly = function() {
	  this.options.asyncOnly = true;
	  return this;
	};

	/**
	 * Disable syntax highlighting (in browser).
	 *
	 * @api public
	 */
	Mocha.prototype.noHighlighting = function() {
	  this.options.noHighlighting = true;
	  return this;
	};

	/**
	 * Enable uncaught errors to propagate (in browser).
	 *
	 * @return {Mocha}
	 * @api public
	 */
	Mocha.prototype.allowUncaught = function() {
	  this.options.allowUncaught = true;
	  return this;
	};

	/**
	 * Delay root suite execution.
	 * @returns {Mocha}
	 */
	Mocha.prototype.delay = function delay() {
	  this.options.delay = true;
	  return this;
	};

	/**
	 * Run tests and invoke `fn()` when complete.
	 *
	 * @api public
	 * @param {Function} fn
	 * @return {Runner}
	 */
	Mocha.prototype.run = function(fn) {
	  if (this.files.length) {
	    this.loadFiles();
	  }
	  var suite = this.suite;
	  var options = this.options;
	  options.files = this.files;
	  var runner = new exports.Runner(suite, options.delay);
	  var reporter = new this._reporter(runner, options);
	  runner.ignoreLeaks = options.ignoreLeaks !== false;
	  runner.fullStackTrace = options.fullStackTrace;
	  runner.asyncOnly = options.asyncOnly;
	  runner.allowUncaught = options.allowUncaught;
	  if (options.grep) {
	    runner.grep(options.grep, options.invert);
	  }
	  if (options.globals) {
	    runner.globals(options.globals);
	  }
	  if (options.growl) {
	    this._growl(runner, reporter);
	  }
	  if (options.useColors !== undefined) {
	    exports.reporters.Base.useColors = options.useColors;
	  }
	  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;

	  function done(failures) {
	    if (reporter.done) {
	      reporter.done(failures, fn);
	    } else {
	      fn && fn(failures);
	    }
	  }

	  return runner.run(done);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26), __webpack_require__(28)(module), "/", (function() { return this; }())))

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	module.exports = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe,  '\\$&');
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// Alias exports to a their normalized format Mocha#reporter to prevent a need
	// for dynamic (try/catch) requires, which Browserify doesn't handle.
	exports.Base = exports.base = __webpack_require__(32);
	exports.Dot = exports.dot = __webpack_require__(62);
	exports.Doc = exports.doc = __webpack_require__(63);
	exports.TAP = exports.tap = __webpack_require__(64);
	exports.JSON = exports.json = __webpack_require__(65);
	exports.HTML = exports.html = __webpack_require__(66);
	exports.List = exports.list = __webpack_require__(68);
	exports.Min = exports.min = __webpack_require__(69);
	exports.Spec = exports.spec = __webpack_require__(70);
	exports.Nyan = exports.nyan = __webpack_require__(71);
	exports.XUnit = exports.xunit = __webpack_require__(72);
	exports.Markdown = exports.markdown = __webpack_require__(74);
	exports.Progress = exports.progress = __webpack_require__(75);
	exports.Landing = exports.landing = __webpack_require__(76);
	exports.JSONCov = exports['json-cov'] = __webpack_require__(77);
	exports.HTMLCov = exports['html-cov'] = __webpack_require__(78);
	exports.JSONStream = exports['json-stream'] = __webpack_require__(107);


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {/**
	 * Module dependencies.
	 */

	var tty = __webpack_require__(33);
	var diff = __webpack_require__(34);
	var ms = __webpack_require__(35);
	var utils = __webpack_require__(36);
	var supportsColor = process.browser ? null : __webpack_require__(61);

	/**
	 * Expose `Base`.
	 */

	exports = module.exports = Base;

	/**
	 * Save timer references to avoid Sinon interfering.
	 * See: https://github.com/mochajs/mocha/issues/237
	 */

	/* eslint-disable no-unused-vars, no-native-reassign */
	var Date = global.Date;
	var setTimeout = global.setTimeout;
	var setInterval = global.setInterval;
	var clearTimeout = global.clearTimeout;
	var clearInterval = global.clearInterval;
	/* eslint-enable no-unused-vars, no-native-reassign */

	/**
	 * Check if both stdio streams are associated with a tty.
	 */

	var isatty = tty.isatty(1) && tty.isatty(2);

	/**
	 * Enable coloring by default, except in the browser interface.
	 */

	exports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));

	/**
	 * Inline diffs instead of +/-
	 */

	exports.inlineDiffs = false;

	/**
	 * Default color map.
	 */

	exports.colors = {
	  pass: 90,
	  fail: 31,
	  'bright pass': 92,
	  'bright fail': 91,
	  'bright yellow': 93,
	  pending: 36,
	  suite: 0,
	  'error title': 0,
	  'error message': 31,
	  'error stack': 90,
	  checkmark: 32,
	  fast: 90,
	  medium: 33,
	  slow: 31,
	  green: 32,
	  light: 90,
	  'diff gutter': 90,
	  'diff added': 32,
	  'diff removed': 31
	};

	/**
	 * Default symbol map.
	 */

	exports.symbols = {
	  ok: '',
	  err: '',
	  dot: ''
	};

	// With node.js on Windows: use symbols available in terminal default fonts
	if (process.platform === 'win32') {
	  exports.symbols.ok = '\u221A';
	  exports.symbols.err = '\u00D7';
	  exports.symbols.dot = '.';
	}

	/**
	 * Color `str` with the given `type`,
	 * allowing colors to be disabled,
	 * as well as user-defined color
	 * schemes.
	 *
	 * @param {string} type
	 * @param {string} str
	 * @return {string}
	 * @api private
	 */
	var color = exports.color = function(type, str) {
	  if (!exports.useColors) {
	    return String(str);
	  }
	  return '\u001b[' + exports.colors[type] + 'm' + str + '\u001b[0m';
	};

	/**
	 * Expose term window size, with some defaults for when stderr is not a tty.
	 */

	exports.window = {
	  width: 75
	};

	if (isatty) {
	  exports.window.width = process.stdout.getWindowSize
	      ? process.stdout.getWindowSize(1)[0]
	      : tty.getWindowSize()[1];
	}

	/**
	 * Expose some basic cursor interactions that are common among reporters.
	 */

	exports.cursor = {
	  hide: function() {
	    isatty && process.stdout.write('\u001b[?25l');
	  },

	  show: function() {
	    isatty && process.stdout.write('\u001b[?25h');
	  },

	  deleteLine: function() {
	    isatty && process.stdout.write('\u001b[2K');
	  },

	  beginningOfLine: function() {
	    isatty && process.stdout.write('\u001b[0G');
	  },

	  CR: function() {
	    if (isatty) {
	      exports.cursor.deleteLine();
	      exports.cursor.beginningOfLine();
	    } else {
	      process.stdout.write('\r');
	    }
	  }
	};

	/**
	 * Outut the given `failures` as a list.
	 *
	 * @param {Array} failures
	 * @api public
	 */

	exports.list = function(failures) {
	  console.log();
	  failures.forEach(function(test, i) {
	    // format
	    var fmt = color('error title', '  %s) %s:\n')
	      + color('error message', '     %s')
	      + color('error stack', '\n%s\n');

	    // msg
	    var msg;
	    var err = test.err;
	    var message;
	    if (err.message) {
	      message = err.message;
	    } else if (typeof err.inspect === 'function') {
	      message = err.inspect() + '';
	    } else {
	      message = '';
	    }
	    var stack = err.stack || message;
	    var index = stack.indexOf(message);
	    var actual = err.actual;
	    var expected = err.expected;
	    var escape = true;

	    if (index === -1) {
	      msg = message;
	    } else {
	      index += message.length;
	      msg = stack.slice(0, index);
	      // remove msg from stack
	      stack = stack.slice(index + 1);
	    }

	    // uncaught
	    if (err.uncaught) {
	      msg = 'Uncaught ' + msg;
	    }
	    // explicitly show diff
	    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {
	      escape = false;
	      if (!(utils.isString(actual) && utils.isString(expected))) {
	        err.actual = actual = utils.stringify(actual);
	        err.expected = expected = utils.stringify(expected);
	      }

	      fmt = color('error title', '  %s) %s:\n%s') + color('error stack', '\n%s\n');
	      var match = message.match(/^([^:]+): expected/);
	      msg = '\n      ' + color('error message', match ? match[1] : msg);

	      if (exports.inlineDiffs) {
	        msg += inlineDiff(err, escape);
	      } else {
	        msg += unifiedDiff(err, escape);
	      }
	    }

	    // indent stack trace
	    stack = stack.replace(/^/gm, '  ');

	    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);
	  });
	};

	/**
	 * Initialize a new `Base` reporter.
	 *
	 * All other reporters generally
	 * inherit from this reporter, providing
	 * stats such as test duration, number
	 * of tests passed / failed etc.
	 *
	 * @param {Runner} runner
	 * @api public
	 */

	function Base(runner) {
	  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };
	  var failures = this.failures = [];

	  if (!runner) {
	    return;
	  }
	  this.runner = runner;

	  runner.stats = stats;

	  runner.on('start', function() {
	    stats.start = new Date();
	  });

	  runner.on('suite', function(suite) {
	    stats.suites = stats.suites || 0;
	    suite.root || stats.suites++;
	  });

	  runner.on('test end', function() {
	    stats.tests = stats.tests || 0;
	    stats.tests++;
	  });

	  runner.on('pass', function(test) {
	    stats.passes = stats.passes || 0;

	    if (test.duration > test.slow()) {
	      test.speed = 'slow';
	    } else if (test.duration > test.slow() / 2) {
	      test.speed = 'medium';
	    } else {
	      test.speed = 'fast';
	    }

	    stats.passes++;
	  });

	  runner.on('fail', function(test, err) {
	    stats.failures = stats.failures || 0;
	    stats.failures++;
	    test.err = err;
	    failures.push(test);
	  });

	  runner.on('end', function() {
	    stats.end = new Date();
	    stats.duration = new Date() - stats.start;
	  });

	  runner.on('pending', function() {
	    stats.pending++;
	  });
	}

	/**
	 * Output common epilogue used by many of
	 * the bundled reporters.
	 *
	 * @api public
	 */
	Base.prototype.epilogue = function() {
	  var stats = this.stats;
	  var fmt;

	  console.log();

	  // passes
	  fmt = color('bright pass', ' ')
	    + color('green', ' %d passing')
	    + color('light', ' (%s)');

	  console.log(fmt,
	    stats.passes || 0,
	    ms(stats.duration));

	  // pending
	  if (stats.pending) {
	    fmt = color('pending', ' ')
	      + color('pending', ' %d pending');

	    console.log(fmt, stats.pending);
	  }

	  // failures
	  if (stats.failures) {
	    fmt = color('fail', '  %d failing');

	    console.log(fmt, stats.failures);

	    Base.list(this.failures);
	    console.log();
	  }

	  console.log();
	};

	/**
	 * Pad the given `str` to `len`.
	 *
	 * @api private
	 * @param {string} str
	 * @param {string} len
	 * @return {string}
	 */
	function pad(str, len) {
	  str = String(str);
	  return Array(len - str.length + 1).join(' ') + str;
	}

	/**
	 * Returns an inline diff between 2 strings with coloured ANSI output
	 *
	 * @api private
	 * @param {Error} err with actual/expected
	 * @param {boolean} escape
	 * @return {string} Diff
	 */
	function inlineDiff(err, escape) {
	  var msg = errorDiff(err, 'WordsWithSpace', escape);

	  // linenos
	  var lines = msg.split('\n');
	  if (lines.length > 4) {
	    var width = String(lines.length).length;
	    msg = lines.map(function(str, i) {
	      return pad(++i, width) + ' |' + ' ' + str;
	    }).join('\n');
	  }

	  // legend
	  msg = '\n'
	    + color('diff removed', 'actual')
	    + ' '
	    + color('diff added', 'expected')
	    + '\n\n'
	    + msg
	    + '\n';

	  // indent
	  msg = msg.replace(/^/gm, '      ');
	  return msg;
	}

	/**
	 * Returns a unified diff between two strings.
	 *
	 * @api private
	 * @param {Error} err with actual/expected
	 * @param {boolean} escape
	 * @return {string} The diff.
	 */
	function unifiedDiff(err, escape) {
	  var indent = '      ';
	  function cleanUp(line) {
	    if (escape) {
	      line = escapeInvisibles(line);
	    }
	    if (line[0] === '+') {
	      return indent + colorLines('diff added', line);
	    }
	    if (line[0] === '-') {
	      return indent + colorLines('diff removed', line);
	    }
	    if (line.match(/\@\@/)) {
	      return null;
	    }
	    if (line.match(/\\ No newline/)) {
	      return null;
	    }
	    return indent + line;
	  }
	  function notBlank(line) {
	    return typeof line !== 'undefined' && line !== null;
	  }
	  var msg = diff.createPatch('string', err.actual, err.expected);
	  var lines = msg.split('\n').splice(4);
	  return '\n      '
	    + colorLines('diff added', '+ expected') + ' '
	    + colorLines('diff removed', '- actual')
	    + '\n\n'
	    + lines.map(cleanUp).filter(notBlank).join('\n');
	}

	/**
	 * Return a character diff for `err`.
	 *
	 * @api private
	 * @param {Error} err
	 * @param {string} type
	 * @param {boolean} escape
	 * @return {string}
	 */
	function errorDiff(err, type, escape) {
	  var actual = escape ? escapeInvisibles(err.actual) : err.actual;
	  var expected = escape ? escapeInvisibles(err.expected) : err.expected;
	  return diff['diff' + type](actual, expected).map(function(str) {
	    if (str.added) {
	      return colorLines('diff added', str.value);
	    }
	    if (str.removed) {
	      return colorLines('diff removed', str.value);
	    }
	    return str.value;
	  }).join('');
	}

	/**
	 * Returns a string with all invisible characters in plain text
	 *
	 * @api private
	 * @param {string} line
	 * @return {string}
	 */
	function escapeInvisibles(line) {
	  return line.replace(/\t/g, '<tab>')
	    .replace(/\r/g, '<CR>')
	    .replace(/\n/g, '<LF>\n');
	}

	/**
	 * Color lines for `str`, using the color `name`.
	 *
	 * @api private
	 * @param {string} name
	 * @param {string} str
	 * @return {string}
	 */
	function colorLines(name, str) {
	  return str.split('\n').map(function(str) {
	    return color(name, str);
	  }).join('\n');
	}

	/**
	 * Object#toString reference.
	 */
	var objToString = Object.prototype.toString;

	/**
	 * Check that a / b have the same type.
	 *
	 * @api private
	 * @param {Object} a
	 * @param {Object} b
	 * @return {boolean}
	 */
	function sameType(a, b) {
	  return objToString.call(a) === objToString.call(b);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26), (function() { return this; }())))

/***/ },
/* 33 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {exports.isatty = function isatty() {
	  return true;
	};

	exports.getWindowSize = function getWindowSize() {
	  if ('innerHeight' in global) {
	    return [global.innerHeight, global.innerWidth];
	  }
	  // In a Web Worker, the DOM Window is not available.
	  return [640, 480];
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* See LICENSE file for terms of use */

	/*
	 * Text diff implementation.
	 *
	 * This library supports the following APIS:
	 * JsDiff.diffChars: Character by character diff
	 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
	 * JsDiff.diffLines: Line based diff
	 *
	 * JsDiff.diffCss: Diff targeted at CSS content
	 *
	 * These methods are based on the implementation proposed in
	 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
	 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
	 */
	(function(global, undefined) {
	  var objectPrototypeToString = Object.prototype.toString;

	  /*istanbul ignore next*/
	  function map(arr, mapper, that) {
	    if (Array.prototype.map) {
	      return Array.prototype.map.call(arr, mapper, that);
	    }

	    var other = new Array(arr.length);

	    for (var i = 0, n = arr.length; i < n; i++) {
	      other[i] = mapper.call(that, arr[i], i, arr);
	    }
	    return other;
	  }
	  function clonePath(path) {
	    return { newPos: path.newPos, components: path.components.slice(0) };
	  }
	  function removeEmpty(array) {
	    var ret = [];
	    for (var i = 0; i < array.length; i++) {
	      if (array[i]) {
	        ret.push(array[i]);
	      }
	    }
	    return ret;
	  }
	  function escapeHTML(s) {
	    var n = s;
	    n = n.replace(/&/g, '&amp;');
	    n = n.replace(/</g, '&lt;');
	    n = n.replace(/>/g, '&gt;');
	    n = n.replace(/"/g, '&quot;');

	    return n;
	  }

	  // This function handles the presence of circular references by bailing out when encountering an
	  // object that is already on the "stack" of items being processed.
	  function canonicalize(obj, stack, replacementStack) {
	    stack = stack || [];
	    replacementStack = replacementStack || [];

	    var i;

	    for (i = 0; i < stack.length; i += 1) {
	      if (stack[i] === obj) {
	        return replacementStack[i];
	      }
	    }

	    var canonicalizedObj;

	    if ('[object Array]' === objectPrototypeToString.call(obj)) {
	      stack.push(obj);
	      canonicalizedObj = new Array(obj.length);
	      replacementStack.push(canonicalizedObj);
	      for (i = 0; i < obj.length; i += 1) {
	        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
	      }
	      stack.pop();
	      replacementStack.pop();
	    } else if (typeof obj === 'object' && obj !== null) {
	      stack.push(obj);
	      canonicalizedObj = {};
	      replacementStack.push(canonicalizedObj);
	      var sortedKeys = [],
	          key;
	      for (key in obj) {
	        sortedKeys.push(key);
	      }
	      sortedKeys.sort();
	      for (i = 0; i < sortedKeys.length; i += 1) {
	        key = sortedKeys[i];
	        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
	      }
	      stack.pop();
	      replacementStack.pop();
	    } else {
	      canonicalizedObj = obj;
	    }
	    return canonicalizedObj;
	  }

	  function buildValues(components, newString, oldString, useLongestToken) {
	    var componentPos = 0,
	        componentLen = components.length,
	        newPos = 0,
	        oldPos = 0;

	    for (; componentPos < componentLen; componentPos++) {
	      var component = components[componentPos];
	      if (!component.removed) {
	        if (!component.added && useLongestToken) {
	          var value = newString.slice(newPos, newPos + component.count);
	          value = map(value, function(value, i) {
	            var oldValue = oldString[oldPos + i];
	            return oldValue.length > value.length ? oldValue : value;
	          });

	          component.value = value.join('');
	        } else {
	          component.value = newString.slice(newPos, newPos + component.count).join('');
	        }
	        newPos += component.count;

	        // Common case
	        if (!component.added) {
	          oldPos += component.count;
	        }
	      } else {
	        component.value = oldString.slice(oldPos, oldPos + component.count).join('');
	        oldPos += component.count;

	        // Reverse add and remove so removes are output first to match common convention
	        // The diffing algorithm is tied to add then remove output and this is the simplest
	        // route to get the desired output with minimal overhead.
	        if (componentPos && components[componentPos - 1].added) {
	          var tmp = components[componentPos - 1];
	          components[componentPos - 1] = components[componentPos];
	          components[componentPos] = tmp;
	        }
	      }
	    }

	    return components;
	  }

	  function Diff(ignoreWhitespace) {
	    this.ignoreWhitespace = ignoreWhitespace;
	  }
	  Diff.prototype = {
	    diff: function(oldString, newString, callback) {
	      var self = this;

	      function done(value) {
	        if (callback) {
	          setTimeout(function() { callback(undefined, value); }, 0);
	          return true;
	        } else {
	          return value;
	        }
	      }

	      // Handle the identity case (this is due to unrolling editLength == 0
	      if (newString === oldString) {
	        return done([{ value: newString }]);
	      }
	      if (!newString) {
	        return done([{ value: oldString, removed: true }]);
	      }
	      if (!oldString) {
	        return done([{ value: newString, added: true }]);
	      }

	      newString = this.tokenize(newString);
	      oldString = this.tokenize(oldString);

	      var newLen = newString.length, oldLen = oldString.length;
	      var editLength = 1;
	      var maxEditLength = newLen + oldLen;
	      var bestPath = [{ newPos: -1, components: [] }];

	      // Seed editLength = 0, i.e. the content starts with the same values
	      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
	      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	        // Identity per the equality and tokenizer
	        return done([{value: newString.join('')}]);
	      }

	      // Main worker method. checks all permutations of a given edit length for acceptance.
	      function execEditLength() {
	        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
	          var basePath;
	          var addPath = bestPath[diagonalPath - 1],
	              removePath = bestPath[diagonalPath + 1],
	              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
	          if (addPath) {
	            // No one else is going to attempt to use this value, clear it
	            bestPath[diagonalPath - 1] = undefined;
	          }

	          var canAdd = addPath && addPath.newPos + 1 < newLen,
	              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
	          if (!canAdd && !canRemove) {
	            // If this path is a terminal then prune
	            bestPath[diagonalPath] = undefined;
	            continue;
	          }

	          // Select the diagonal that we want to branch from. We select the prior
	          // path whose position in the new string is the farthest from the origin
	          // and does not pass the bounds of the diff graph
	          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
	            basePath = clonePath(removePath);
	            self.pushComponent(basePath.components, undefined, true);
	          } else {
	            basePath = addPath;   // No need to clone, we've pulled it from the list
	            basePath.newPos++;
	            self.pushComponent(basePath.components, true, undefined);
	          }

	          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

	          // If we have hit the end of both strings, then we are done
	          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));
	          } else {
	            // Otherwise track this path as a potential candidate and continue.
	            bestPath[diagonalPath] = basePath;
	          }
	        }

	        editLength++;
	      }

	      // Performs the length of edit iteration. Is a bit fugly as this has to support the
	      // sync and async mode which is never fun. Loops over execEditLength until a value
	      // is produced.
	      if (callback) {
	        (function exec() {
	          setTimeout(function() {
	            // This should not happen, but we want to be safe.
	            /*istanbul ignore next */
	            if (editLength > maxEditLength) {
	              return callback();
	            }

	            if (!execEditLength()) {
	              exec();
	            }
	          }, 0);
	        }());
	      } else {
	        while (editLength <= maxEditLength) {
	          var ret = execEditLength();
	          if (ret) {
	            return ret;
	          }
	        }
	      }
	    },

	    pushComponent: function(components, added, removed) {
	      var last = components[components.length - 1];
	      if (last && last.added === added && last.removed === removed) {
	        // We need to clone here as the component clone operation is just
	        // as shallow array clone
	        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };
	      } else {
	        components.push({count: 1, added: added, removed: removed });
	      }
	    },
	    extractCommon: function(basePath, newString, oldString, diagonalPath) {
	      var newLen = newString.length,
	          oldLen = oldString.length,
	          newPos = basePath.newPos,
	          oldPos = newPos - diagonalPath,

	          commonCount = 0;
	      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
	        newPos++;
	        oldPos++;
	        commonCount++;
	      }

	      if (commonCount) {
	        basePath.components.push({count: commonCount});
	      }

	      basePath.newPos = newPos;
	      return oldPos;
	    },

	    equals: function(left, right) {
	      var reWhitespace = /\S/;
	      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));
	    },
	    tokenize: function(value) {
	      return value.split('');
	    }
	  };

	  var CharDiff = new Diff();

	  var WordDiff = new Diff(true);
	  var WordWithSpaceDiff = new Diff();
	  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {
	    return removeEmpty(value.split(/(\s+|\b)/));
	  };

	  var CssDiff = new Diff(true);
	  CssDiff.tokenize = function(value) {
	    return removeEmpty(value.split(/([{}:;,]|\s+)/));
	  };

	  var LineDiff = new Diff();

	  var TrimmedLineDiff = new Diff();
	  TrimmedLineDiff.ignoreTrim = true;

	  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {
	    var retLines = [],
	        lines = value.split(/^/m);
	    for (var i = 0; i < lines.length; i++) {
	      var line = lines[i],
	          lastLine = lines[i - 1],
	          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];

	      // Merge lines that may contain windows new lines
	      if (line === '\n' && lastLineLastChar === '\r') {
	          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\r\n';
	      } else {
	        if (this.ignoreTrim) {
	          line = line.trim();
	          // add a newline unless this is the last line.
	          if (i < lines.length - 1) {
	            line += '\n';
	          }
	        }
	        retLines.push(line);
	      }
	    }

	    return retLines;
	  };

	  var PatchDiff = new Diff();
	  PatchDiff.tokenize = function(value) {
	    var ret = [],
	        linesAndNewlines = value.split(/(\n|\r\n)/);

	    // Ignore the final empty token that occurs if the string ends with a new line
	    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
	      linesAndNewlines.pop();
	    }

	    // Merge the content and line separators into single tokens
	    for (var i = 0; i < linesAndNewlines.length; i++) {
	      var line = linesAndNewlines[i];

	      if (i % 2) {
	        ret[ret.length - 1] += line;
	      } else {
	        ret.push(line);
	      }
	    }
	    return ret;
	  };

	  var SentenceDiff = new Diff();
	  SentenceDiff.tokenize = function(value) {
	    return removeEmpty(value.split(/(\S.+?[.!?])(?=\s+|$)/));
	  };

	  var JsonDiff = new Diff();
	  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
	  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
	  JsonDiff.useLongestToken = true;
	  JsonDiff.tokenize = LineDiff.tokenize;
	  JsonDiff.equals = function(left, right) {
	    return LineDiff.equals(left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
	  };

	  var JsDiff = {
	    Diff: Diff,

	    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },
	    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },
	    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },
	    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },
	    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },

	    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },

	    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },
	    diffJson: function(oldObj, newObj, callback) {
	      return JsonDiff.diff(
	        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),
	        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),
	        callback
	      );
	    },

	    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {
	      var ret = [];

	      if (oldFileName == newFileName) {
	        ret.push('Index: ' + oldFileName);
	      }
	      ret.push('===================================================================');
	      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\t' + oldHeader));
	      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\t' + newHeader));

	      var diff = PatchDiff.diff(oldStr, newStr);
	      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier

	      // Formats a given set of lines for printing as context lines in a patch
	      function contextLines(lines) {
	        return map(lines, function(entry) { return ' ' + entry; });
	      }

	      // Outputs the no newline at end of file warning if needed
	      function eofNL(curRange, i, current) {
	        var last = diff[diff.length - 2],
	            isLast = i === diff.length - 2,
	            isLastOfType = i === diff.length - 3 && current.added !== last.added;

	        // Figure out if this is the last line for the given file and missing NL
	        if (!(/\n$/.test(current.value)) && (isLast || isLastOfType)) {
	          curRange.push('\\ No newline at end of file');
	        }
	      }

	      var oldRangeStart = 0, newRangeStart = 0, curRange = [],
	          oldLine = 1, newLine = 1;
	      for (var i = 0; i < diff.length; i++) {
	        var current = diff[i],
	            lines = current.lines || current.value.replace(/\n$/, '').split('\n');
	        current.lines = lines;

	        if (current.added || current.removed) {
	          // If we have previous context, start with that
	          if (!oldRangeStart) {
	            var prev = diff[i - 1];
	            oldRangeStart = oldLine;
	            newRangeStart = newLine;

	            if (prev) {
	              curRange = contextLines(prev.lines.slice(-4));
	              oldRangeStart -= curRange.length;
	              newRangeStart -= curRange.length;
	            }
	          }

	          // Output our changes
	          curRange.push.apply(curRange, map(lines, function(entry) {
	            return (current.added ? '+' : '-') + entry;
	          }));
	          eofNL(curRange, i, current);

	          // Track the updated file position
	          if (current.added) {
	            newLine += lines.length;
	          } else {
	            oldLine += lines.length;
	          }
	        } else {
	          // Identical context lines. Track line changes
	          if (oldRangeStart) {
	            // Close out any changes that have been output (or join overlapping)
	            if (lines.length <= 8 && i < diff.length - 2) {
	              // Overlapping
	              curRange.push.apply(curRange, contextLines(lines));
	            } else {
	              // end the range and output
	              var contextSize = Math.min(lines.length, 4);
	              ret.push(
	                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)
	                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)
	                  + ' @@');
	              ret.push.apply(ret, curRange);
	              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
	              if (lines.length <= 4) {
	                eofNL(ret, i, current);
	              }

	              oldRangeStart = 0;
	              newRangeStart = 0;
	              curRange = [];
	            }
	          }
	          oldLine += lines.length;
	          newLine += lines.length;
	        }
	      }

	      return ret.join('\n') + '\n';
	    },

	    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
	      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);
	    },

	    applyPatch: function(oldStr, uniDiff) {
	      var diffstr = uniDiff.split('\n'),
	          hunks = [],
	          i = 0,
	          remEOFNL = false,
	          addEOFNL = false;

	      // Skip to the first change hunk
	      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {
	        i++;
	      }

	      // Parse the unified diff
	      for (; i < diffstr.length; i++) {
	        if (diffstr[i][0] === '@') {
	          var chnukHeader = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
	          hunks.unshift({
	            start: chnukHeader[3],
	            oldlength: +chnukHeader[2],
	            removed: [],
	            newlength: chnukHeader[4],
	            added: []
	          });
	        } else if (diffstr[i][0] === '+') {
	          hunks[0].added.push(diffstr[i].substr(1));
	        } else if (diffstr[i][0] === '-') {
	          hunks[0].removed.push(diffstr[i].substr(1));
	        } else if (diffstr[i][0] === ' ') {
	          hunks[0].added.push(diffstr[i].substr(1));
	          hunks[0].removed.push(diffstr[i].substr(1));
	        } else if (diffstr[i][0] === '\\') {
	          if (diffstr[i - 1][0] === '+') {
	            remEOFNL = true;
	          } else if (diffstr[i - 1][0] === '-') {
	            addEOFNL = true;
	          }
	        }
	      }

	      // Apply the diff to the input
	      var lines = oldStr.split('\n');
	      for (i = hunks.length - 1; i >= 0; i--) {
	        var hunk = hunks[i];
	        // Sanity check the input string. Bail if we don't match.
	        for (var j = 0; j < hunk.oldlength; j++) {
	          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {
	            return false;
	          }
	        }
	        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));
	      }

	      // Handle EOFNL insertion/removal
	      if (remEOFNL) {
	        while (!lines[lines.length - 1]) {
	          lines.pop();
	        }
	      } else if (addEOFNL) {
	        lines.push('');
	      }
	      return lines.join('\n');
	    },

	    convertChangesToXML: function(changes) {
	      var ret = [];
	      for (var i = 0; i < changes.length; i++) {
	        var change = changes[i];
	        if (change.added) {
	          ret.push('<ins>');
	        } else if (change.removed) {
	          ret.push('<del>');
	        }

	        ret.push(escapeHTML(change.value));

	        if (change.added) {
	          ret.push('</ins>');
	        } else if (change.removed) {
	          ret.push('</del>');
	        }
	      }
	      return ret.join('');
	    },

	    // See: http://code.google.com/p/google-diff-match-patch/wiki/API
	    convertChangesToDMP: function(changes) {
	      var ret = [],
	          change,
	          operation;
	      for (var i = 0; i < changes.length; i++) {
	        change = changes[i];
	        if (change.added) {
	          operation = 1;
	        } else if (change.removed) {
	          operation = -1;
	        } else {
	          operation = 0;
	        }

	        ret.push([operation, change.value]);
	      }
	      return ret;
	    },

	    canonicalize: canonicalize
	  };

	  /*istanbul ignore next */
	  /*global module */
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = JsDiff;
	  } else if (true) {
	    /*global define */
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return JsDiff; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof global.JsDiff === 'undefined') {
	    global.JsDiff = JsDiff;
	  }
	}(this));


/***/ },
/* 35 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @api public
	 * @param {string|number} val
	 * @param {Object} options
	 * @return {string|number}
	 */
	module.exports = function(val, options) {
	  options = options || {};
	  if (typeof val === 'string') {
	    return parse(val);
	  }
	  // https://github.com/mochajs/mocha/pull/1035
	  return options['long'] ? longFormat(val) : shortFormat(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @api private
	 * @param {string} str
	 * @return {number}
	 */
	function parse(str) {
	  var match = (/^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 's':
	      return n * s;
	    case 'ms':
	      return n;
	    default:
	      // No default case
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @api private
	 * @param {number} ms
	 * @return {string}
	 */
	function shortFormat(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @api private
	 * @param {number} ms
	 * @return {string}
	 */
	function longFormat(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 *
	 * @api private
	 * @param {number} ms
	 * @param {number} n
	 * @param {string} name
	 */
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/* eslint-env browser */

	/**
	 * Module dependencies.
	 */

	var basename = __webpack_require__(30).basename;
	var debug = __webpack_require__(41)('mocha:watch');
	var exists = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).existsSync || __webpack_require__(30).existsSync;
	var glob = __webpack_require__(42);
	var join = __webpack_require__(30).join;
	var readdirSync = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readdirSync;
	var statSync = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).statSync;
	var watchFile = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).watchFile;

	/**
	 * Ignored directories.
	 */

	var ignore = ['node_modules', '.git'];

	exports.inherits = __webpack_require__(45).inherits;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @api private
	 * @param  {string} html
	 * @return {string}
	 */
	exports.escape = function(html) {
	  return String(html)
	    .replace(/&/g, '&amp;')
	    .replace(/"/g, '&quot;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;');
	};

	/**
	 * Array#forEach (<=IE8)
	 *
	 * @api private
	 * @param {Array} arr
	 * @param {Function} fn
	 * @param {Object} scope
	 */
	exports.forEach = function(arr, fn, scope) {
	  for (var i = 0, l = arr.length; i < l; i++) {
	    fn.call(scope, arr[i], i);
	  }
	};

	/**
	 * Test if the given obj is type of string.
	 *
	 * @api private
	 * @param {Object} obj
	 * @return {boolean}
	 */
	exports.isString = function(obj) {
	  return typeof obj === 'string';
	};

	/**
	 * Array#map (<=IE8)
	 *
	 * @api private
	 * @param {Array} arr
	 * @param {Function} fn
	 * @param {Object} scope
	 * @return {Array}
	 */
	exports.map = function(arr, fn, scope) {
	  var result = [];
	  for (var i = 0, l = arr.length; i < l; i++) {
	    result.push(fn.call(scope, arr[i], i, arr));
	  }
	  return result;
	};

	/**
	 * Array#indexOf (<=IE8)
	 *
	 * @api private
	 * @param {Array} arr
	 * @param {Object} obj to find index of
	 * @param {number} start
	 * @return {number}
	 */
	exports.indexOf = function(arr, obj, start) {
	  for (var i = start || 0, l = arr.length; i < l; i++) {
	    if (arr[i] === obj) {
	      return i;
	    }
	  }
	  return -1;
	};

	/**
	 * Array#reduce (<=IE8)
	 *
	 * @api private
	 * @param {Array} arr
	 * @param {Function} fn
	 * @param {Object} val Initial value.
	 * @return {*}
	 */
	exports.reduce = function(arr, fn, val) {
	  var rval = val;

	  for (var i = 0, l = arr.length; i < l; i++) {
	    rval = fn(rval, arr[i], i, arr);
	  }

	  return rval;
	};

	/**
	 * Array#filter (<=IE8)
	 *
	 * @api private
	 * @param {Array} arr
	 * @param {Function} fn
	 * @return {Array}
	 */
	exports.filter = function(arr, fn) {
	  var ret = [];

	  for (var i = 0, l = arr.length; i < l; i++) {
	    var val = arr[i];
	    if (fn(val, i, arr)) {
	      ret.push(val);
	    }
	  }

	  return ret;
	};

	/**
	 * Object.keys (<=IE8)
	 *
	 * @api private
	 * @param {Object} obj
	 * @return {Array} keys
	 */
	exports.keys = typeof Object.keys === 'function' ? Object.keys : function(obj) {
	  var keys = [];
	  var has = Object.prototype.hasOwnProperty; // for `window` on <=IE8

	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      keys.push(key);
	    }
	  }

	  return keys;
	};

	/**
	 * Watch the given `files` for changes
	 * and invoke `fn(file)` on modification.
	 *
	 * @api private
	 * @param {Array} files
	 * @param {Function} fn
	 */
	exports.watch = function(files, fn) {
	  var options = { interval: 100 };
	  files.forEach(function(file) {
	    debug('file %s', file);
	    watchFile(file, options, function(curr, prev) {
	      if (prev.mtime < curr.mtime) {
	        fn(file);
	      }
	    });
	  });
	};

	/**
	 * Array.isArray (<=IE8)
	 *
	 * @api private
	 * @param {Object} obj
	 * @return {Boolean}
	 */
	var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {
	  return Object.prototype.toString.call(obj) === '[object Array]';
	};

	exports.isArray = isArray;

	/**
	 * Buffer.prototype.toJSON polyfill.
	 *
	 * @type {Function}
	 */
	if (typeof Buffer !== 'undefined' && Buffer.prototype) {
	  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function() {
	    return Array.prototype.slice.call(this, 0);
	  };
	}

	/**
	 * Ignored files.
	 *
	 * @api private
	 * @param {string} path
	 * @return {boolean}
	 */
	function ignored(path) {
	  return !~ignore.indexOf(path);
	}

	/**
	 * Lookup files in the given `dir`.
	 *
	 * @api private
	 * @param {string} dir
	 * @param {string[]} [ext=['.js']]
	 * @param {Array} [ret=[]]
	 * @return {Array}
	 */
	exports.files = function(dir, ext, ret) {
	  ret = ret || [];
	  ext = ext || ['js'];

	  var re = new RegExp('\\.(' + ext.join('|') + ')$');

	  readdirSync(dir)
	    .filter(ignored)
	    .forEach(function(path) {
	      path = join(dir, path);
	      if (statSync(path).isDirectory()) {
	        exports.files(path, ext, ret);
	      } else if (path.match(re)) {
	        ret.push(path);
	      }
	    });

	  return ret;
	};

	/**
	 * Compute a slug from the given `str`.
	 *
	 * @api private
	 * @param {string} str
	 * @return {string}
	 */
	exports.slug = function(str) {
	  return str
	    .toLowerCase()
	    .replace(/ +/g, '-')
	    .replace(/[^-\w]/g, '');
	};

	/**
	 * Strip the function definition from `str`, and re-indent for pre whitespace.
	 *
	 * @param {string} str
	 * @return {string}
	 */
	exports.clean = function(str) {
	  str = str
	    .replace(/\r\n?|[\n\u2028\u2029]/g, '\n').replace(/^\uFEFF/, '')
	    .replace(/^function *\(.*\)\s*\{|\(.*\) *=> *\{?/, '')
	    .replace(/\s+\}$/, '');

	  var spaces = str.match(/^\n?( *)/)[1].length;
	  var tabs = str.match(/^\n?(\t*)/)[1].length;
	  var re = new RegExp('^\n?' + (tabs ? '\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');

	  str = str.replace(re, '');

	  return exports.trim(str);
	};

	/**
	 * Trim the given `str`.
	 *
	 * @api private
	 * @param {string} str
	 * @return {string}
	 */
	exports.trim = function(str) {
	  return str.replace(/^\s+|\s+$/g, '');
	};

	/**
	 * Parse the given `qs`.
	 *
	 * @api private
	 * @param {string} qs
	 * @return {Object}
	 */
	exports.parseQuery = function(qs) {
	  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair) {
	    var i = pair.indexOf('=');
	    var key = pair.slice(0, i);
	    var val = pair.slice(++i);

	    obj[key] = decodeURIComponent(val);
	    return obj;
	  }, {});
	};

	/**
	 * Highlight the given string of `js`.
	 *
	 * @api private
	 * @param {string} js
	 * @return {string}
	 */
	function highlight(js) {
	  return js
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>')
	    .replace(/('.*?')/gm, '<span class="string">$1</span>')
	    .replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>')
	    .replace(/(\d+)/gm, '<span class="number">$1</span>')
	    .replace(/\bnew[ \t]+(\w+)/gm, '<span class="keyword">new</span> <span class="init">$1</span>')
	    .replace(/\b(function|new|throw|return|var|if|else)\b/gm, '<span class="keyword">$1</span>');
	}

	/**
	 * Highlight the contents of tag `name`.
	 *
	 * @api private
	 * @param {string} name
	 */
	exports.highlightTags = function(name) {
	  var code = document.getElementById('mocha').getElementsByTagName(name);
	  for (var i = 0, len = code.length; i < len; ++i) {
	    code[i].innerHTML = highlight(code[i].innerHTML);
	  }
	};

	/**
	 * If a value could have properties, and has none, this function is called,
	 * which returns a string representation of the empty value.
	 *
	 * Functions w/ no properties return `'[Function]'`
	 * Arrays w/ length === 0 return `'[]'`
	 * Objects w/ no properties return `'{}'`
	 * All else: return result of `value.toString()`
	 *
	 * @api private
	 * @param {*} value The value to inspect.
	 * @param {string} [type] The type of the value, if known.
	 * @returns {string}
	 */
	function emptyRepresentation(value, type) {
	  type = type || exports.type(value);

	  switch (type) {
	    case 'function':
	      return '[Function]';
	    case 'object':
	      return '{}';
	    case 'array':
	      return '[]';
	    default:
	      return value.toString();
	  }
	}

	/**
	 * Takes some variable and asks `Object.prototype.toString()` what it thinks it
	 * is.
	 *
	 * @api private
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
	 * @param {*} value The value to test.
	 * @returns {string}
	 * @example
	 * type({}) // 'object'
	 * type([]) // 'array'
	 * type(1) // 'number'
	 * type(false) // 'boolean'
	 * type(Infinity) // 'number'
	 * type(null) // 'null'
	 * type(new Date()) // 'date'
	 * type(/foo/) // 'regexp'
	 * type('type') // 'string'
	 * type(global) // 'global'
	 */
	exports.type = function type(value) {
	  if (value === undefined) {
	    return 'undefined';
	  } else if (value === null) {
	    return 'null';
	  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
	    return 'buffer';
	  }
	  return Object.prototype.toString.call(value)
	    .replace(/^\[.+\s(.+?)\]$/, '$1')
	    .toLowerCase();
	};

	/**
	 * Stringify `value`. Different behavior depending on type of value:
	 *
	 * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.
	 * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.
	 * - If `value` is an *empty* object, function, or array, return result of function
	 *   {@link emptyRepresentation}.
	 * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of
	 *   JSON.stringify().
	 *
	 * @api private
	 * @see exports.type
	 * @param {*} value
	 * @return {string}
	 */
	exports.stringify = function(value) {
	  var type = exports.type(value);

	  if (!~exports.indexOf(['object', 'array', 'function'], type)) {
	    if (type !== 'buffer') {
	      return jsonStringify(value);
	    }
	    var json = value.toJSON();
	    // Based on the toJSON result
	    return jsonStringify(json.data && json.type ? json.data : json, 2)
	      .replace(/,(\n|$)/g, '$1');
	  }

	  for (var prop in value) {
	    if (Object.prototype.hasOwnProperty.call(value, prop)) {
	      return jsonStringify(exports.canonicalize(value), 2).replace(/,(\n|$)/g, '$1');
	    }
	  }

	  return emptyRepresentation(value, type);
	};

	/**
	 * like JSON.stringify but more sense.
	 *
	 * @api private
	 * @param {Object}  object
	 * @param {number=} spaces
	 * @param {number=} depth
	 * @returns {*}
	 */
	function jsonStringify(object, spaces, depth) {
	  if (typeof spaces === 'undefined') {
	    // primitive types
	    return _stringify(object);
	  }

	  depth = depth || 1;
	  var space = spaces * depth;
	  var str = isArray(object) ? '[' : '{';
	  var end = isArray(object) ? ']' : '}';
	  var length = object.length || exports.keys(object).length;
	  // `.repeat()` polyfill
	  function repeat(s, n) {
	    return new Array(n).join(s);
	  }

	  function _stringify(val) {
	    switch (exports.type(val)) {
	      case 'null':
	      case 'undefined':
	        val = '[' + val + ']';
	        break;
	      case 'array':
	      case 'object':
	        val = jsonStringify(val, spaces, depth + 1);
	        break;
	      case 'boolean':
	      case 'regexp':
	      case 'number':
	        val = val === 0 && (1 / val) === -Infinity // `-0`
	          ? '-0'
	          : val.toString();
	        break;
	      case 'date':
	        var sDate = isNaN(val.getTime())        // Invalid date
	          ? val.toString()
	          : val.toISOString();
	        val = '[Date: ' + sDate + ']';
	        break;
	      case 'buffer':
	        var json = val.toJSON();
	        // Based on the toJSON result
	        json = json.data && json.type ? json.data : json;
	        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';
	        break;
	      default:
	        val = (val === '[Function]' || val === '[Circular]')
	          ? val
	          : JSON.stringify(val); // string
	    }
	    return val;
	  }

	  for (var i in object) {
	    if (!object.hasOwnProperty(i)) {
	      continue; // not my business
	    }
	    --length;
	    str += '\n ' + repeat(' ', space)
	      + (isArray(object) ? '' : '"' + i + '": ') // key
	      + _stringify(object[i])                     // value
	      + (length ? ',' : '');                     // comma
	  }

	  return str
	    // [], {}
	    + (str.length !== 1 ? '\n' + repeat(' ', --space) + end : end);
	}

	/**
	 * Test if a value is a buffer.
	 *
	 * @api private
	 * @param {*} value The value to test.
	 * @return {boolean} True if `value` is a buffer, otherwise false
	 */
	exports.isBuffer = function(value) {
	  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);
	};

	/**
	 * Return a new Thing that has the keys in sorted order. Recursive.
	 *
	 * If the Thing...
	 * - has already been seen, return string `'[Circular]'`
	 * - is `undefined`, return string `'[undefined]'`
	 * - is `null`, return value `null`
	 * - is some other primitive, return the value
	 * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method
	 * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.
	 * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`
	 *
	 * @api private
	 * @see {@link exports.stringify}
	 * @param {*} value Thing to inspect.  May or may not have properties.
	 * @param {Array} [stack=[]] Stack of seen values
	 * @return {(Object|Array|Function|string|undefined)}
	 */
	exports.canonicalize = function(value, stack) {
	  var canonicalizedObj;
	  /* eslint-disable no-unused-vars */
	  var prop;
	  /* eslint-enable no-unused-vars */
	  var type = exports.type(value);
	  function withStack(value, fn) {
	    stack.push(value);
	    fn();
	    stack.pop();
	  }

	  stack = stack || [];

	  if (exports.indexOf(stack, value) !== -1) {
	    return '[Circular]';
	  }

	  switch (type) {
	    case 'undefined':
	    case 'buffer':
	    case 'null':
	      canonicalizedObj = value;
	      break;
	    case 'array':
	      withStack(value, function() {
	        canonicalizedObj = exports.map(value, function(item) {
	          return exports.canonicalize(item, stack);
	        });
	      });
	      break;
	    case 'function':
	      /* eslint-disable guard-for-in */
	      for (prop in value) {
	        canonicalizedObj = {};
	        break;
	      }
	      /* eslint-enable guard-for-in */
	      if (!canonicalizedObj) {
	        canonicalizedObj = emptyRepresentation(value, type);
	        break;
	      }
	    /* falls through */
	    case 'object':
	      canonicalizedObj = canonicalizedObj || {};
	      withStack(value, function() {
	        exports.forEach(exports.keys(value).sort(), function(key) {
	          canonicalizedObj[key] = exports.canonicalize(value[key], stack);
	        });
	      });
	      break;
	    case 'date':
	    case 'number':
	    case 'regexp':
	    case 'boolean':
	      canonicalizedObj = value;
	      break;
	    default:
	      canonicalizedObj = value + '';
	  }

	  return canonicalizedObj;
	};

	/**
	 * Lookup file names at the given `path`.
	 *
	 * @api public
	 * @param {string} path Base path to start searching from.
	 * @param {string[]} extensions File extensions to look for.
	 * @param {boolean} recursive Whether or not to recurse into subdirectories.
	 * @return {string[]} An array of paths.
	 */
	exports.lookupFiles = function lookupFiles(path, extensions, recursive) {
	  var files = [];
	  var re = new RegExp('\\.(' + extensions.join('|') + ')$');

	  if (!exists(path)) {
	    if (exists(path + '.js')) {
	      path += '.js';
	    } else {
	      files = glob.sync(path);
	      if (!files.length) {
	        throw new Error("cannot resolve path (or pattern) '" + path + "'");
	      }
	      return files;
	    }
	  }

	  try {
	    var stat = statSync(path);
	    if (stat.isFile()) {
	      return path;
	    }
	  } catch (err) {
	    // ignore error
	    return;
	  }

	  readdirSync(path).forEach(function(file) {
	    file = join(path, file);
	    try {
	      var stat = statSync(file);
	      if (stat.isDirectory()) {
	        if (recursive) {
	          files = files.concat(lookupFiles(file, extensions, recursive));
	        }
	        return;
	      }
	    } catch (err) {
	      // ignore error
	      return;
	    }
	    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {
	      return;
	    }
	    files.push(file);
	  });

	  return files;
	};

	/**
	 * Generate an undefined error with a message warning the user.
	 *
	 * @return {Error}
	 */

	exports.undefinedError = function() {
	  return new Error('Caught undefined error, did you throw without specifying what?');
	};

	/**
	 * Generate an undefined error if `err` is not defined.
	 *
	 * @param {Error} err
	 * @return {Error}
	 */

	exports.getError = function(err) {
	  return err || exports.undefinedError();
	};

	/**
	 * @summary
	 * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)
	 * @description
	 * When invoking this function you get a filter function that get the Error.stack as an input,
	 * and return a prettify output.
	 * (i.e: strip Mocha and internal node functions from stack trace).
	 * @returns {Function}
	 */
	exports.stackTraceFilter = function() {
	  // TODO: Replace with `process.browser`
	  var slash = '/';
	  var is = typeof document === 'undefined' ? { node: true } : { browser: true };
	  var cwd = is.node
	      ? process.cwd() + slash
	      : (typeof location === 'undefined' ? window.location : location).href.replace(/\/[^\/]*$/, '/');

	  function isMochaInternal(line) {
	    return (~line.indexOf('node_modules' + slash + 'mocha' + slash))
	      || (~line.indexOf('components' + slash + 'mochajs' + slash))
	      || (~line.indexOf('components' + slash + 'mocha' + slash))
	      || (~line.indexOf(slash + 'mocha.js'));
	  }

	  function isNodeInternal(line) {
	    return (~line.indexOf('(timers.js:'))
	      || (~line.indexOf('(events.js:'))
	      || (~line.indexOf('(node.js:'))
	      || (~line.indexOf('(module.js:'))
	      || (~line.indexOf('GeneratorFunctionPrototype.next (native)'))
	      || false;
	  }

	  return function(stack) {
	    stack = stack.split('\n');

	    stack = exports.reduce(stack, function(list, line) {
	      if (isMochaInternal(line)) {
	        return list;
	      }

	      if (is.node && isNodeInternal(line)) {
	        return list;
	      }

	      // Clean up cwd(absolute)
	      list.push(line.replace(cwd, ''));
	      return list;
	    }, []);

	    return stack.join('\n');
	  };
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37).Buffer, __webpack_require__(26)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(38)
	var ieee754 = __webpack_require__(39)
	var isArray = __webpack_require__(40)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37).Buffer, (function() { return this; }())))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 39 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 40 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	/* eslint-disable no-unused-vars */
	module.exports = function(type) {
	  return function() {};
	};


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	// readdir(PREFIX) as ENTRIES
	//   If fails, END
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $])
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $])
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.



	module.exports = glob

	var fs = __webpack_require__(43)
	, minimatch = __webpack_require__(50)
	, Minimatch = minimatch.Minimatch
	, inherits = __webpack_require__(47)
	, EE = __webpack_require__(60).EventEmitter
	, path = __webpack_require__(30)
	, isDir = {}
	, assert = __webpack_require__(44).ok

	function glob (pattern, options, cb) {
	  if (typeof options === "function") cb = options, options = {}
	  if (!options) options = {}

	  if (typeof options === "number") {
	    deprecated()
	    return
	  }

	  var g = new Glob(pattern, options, cb)
	  return g.sync ? g.found : g
	}

	glob.fnmatch = deprecated

	function deprecated () {
	  throw new Error("glob's interface has changed. Please see the docs.")
	}

	glob.sync = globSync
	function globSync (pattern, options) {
	  if (typeof options === "number") {
	    deprecated()
	    return
	  }

	  options = options || {}
	  options.sync = true
	  return glob(pattern, options)
	}


	glob.Glob = Glob
	inherits(Glob, EE)
	function Glob (pattern, options, cb) {
	  if (!(this instanceof Glob)) {
	    return new Glob(pattern, options, cb)
	  }

	  if (typeof cb === "function") {
	    this.on("error", cb)
	    this.on("end", function (matches) {
	      cb(null, matches)
	    })
	  }

	  options = options || {}

	  this.EOF = {}
	  this._emitQueue = []

	  this.maxDepth = options.maxDepth || 1000
	  this.maxLength = options.maxLength || Infinity
	  this.cache = options.cache || {}
	  this.statCache = options.statCache || {}

	  this.changedCwd = false
	  var cwd = process.cwd()
	  if (!options.hasOwnProperty("cwd")) this.cwd = cwd
	  else {
	    this.cwd = options.cwd
	    this.changedCwd = path.resolve(options.cwd) !== cwd
	  }

	  this.root = options.root || path.resolve(this.cwd, "/")
	  this.root = path.resolve(this.root)
	  if (process.platform === "win32")
	    this.root = this.root.replace(/\\/g, "/")

	  this.nomount = !!options.nomount

	  if (!pattern) {
	    throw new Error("must provide pattern")
	  }

	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar")
	    }
	    pattern = "**/" + pattern
	  }

	  this.strict = options.strict !== false
	  this.dot = !!options.dot
	  this.mark = !!options.mark
	  this.sync = !!options.sync
	  this.nounique = !!options.nounique
	  this.nonull = !!options.nonull
	  this.nosort = !!options.nosort
	  this.nocase = !!options.nocase
	  this.stat = !!options.stat

	  this.debug = !!options.debug || !!options.globDebug
	  if (this.debug)
	    this.log = console.error

	  this.silent = !!options.silent

	  var mm = this.minimatch = new Minimatch(pattern, options)
	  this.options = mm.options
	  pattern = this.pattern = mm.pattern

	  this.error = null
	  this.aborted = false

	  // list of all the patterns that ** has resolved do, so
	  // we can avoid visiting multiple times.
	  this._globstars = {}

	  EE.call(this)

	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length

	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n)

	  this.minimatch.set.forEach(iterator.bind(this))
	  function iterator (pattern, i, set) {
	    this._process(pattern, 0, i, function (er) {
	      if (er) this.emit("error", er)
	      if (-- n <= 0) this._finish()
	    })
	  }
	}

	Glob.prototype.log = function () {}

	Glob.prototype._finish = function () {
	  assert(this instanceof Glob)

	  var nou = this.nounique
	  , all = nou ? [] : {}

	  for (var i = 0, l = this.matches.length; i < l; i ++) {
	    var matches = this.matches[i]
	    this.log("matches[%d] =", i, matches)
	    // do like the shell, and spit out the literal glob
	    if (!matches) {
	      if (this.nonull) {
	        var literal = this.minimatch.globSet[i]
	        if (nou) all.push(literal)
	        else all[literal] = true
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches)
	      if (nou) all.push.apply(all, m)
	      else m.forEach(function (m) {
	        all[m] = true
	      })
	    }
	  }

	  if (!nou) all = Object.keys(all)

	  if (!this.nosort) {
	    all = all.sort(this.nocase ? alphasorti : alphasort)
	  }

	  if (this.mark) {
	    // at *some* point we statted all of these
	    all = all.map(function (m) {
	      var sc = this.cache[m]
	      if (!sc)
	        return m
	      var isDir = (Array.isArray(sc) || sc === 2)
	      if (isDir && m.slice(-1) !== "/") {
	        return m + "/"
	      }
	      if (!isDir && m.slice(-1) === "/") {
	        return m.replace(/\/+$/, "")
	      }
	      return m
	    }, this)
	  }

	  this.log("emitting end", all)

	  this.EOF = this.found = all
	  this.emitMatch(this.EOF)
	}

	function alphasorti (a, b) {
	  a = a.toLowerCase()
	  b = b.toLowerCase()
	  return alphasort(a, b)
	}

	function alphasort (a, b) {
	  return a > b ? 1 : a < b ? -1 : 0
	}

	Glob.prototype.abort = function () {
	  this.aborted = true
	  this.emit("abort")
	}

	Glob.prototype.pause = function () {
	  if (this.paused) return
	  if (this.sync)
	    this.emit("error", new Error("Can't pause/resume sync glob"))
	  this.paused = true
	  this.emit("pause")
	}

	Glob.prototype.resume = function () {
	  if (!this.paused) return
	  if (this.sync)
	    this.emit("error", new Error("Can't pause/resume sync glob"))
	  this.paused = false
	  this.emit("resume")
	  this._processEmitQueue()
	  //process.nextTick(this.emit.bind(this, "resume"))
	}

	Glob.prototype.emitMatch = function (m) {
	  if (!this.stat || this.statCache[m] || m === this.EOF) {
	    this._emitQueue.push(m)
	    this._processEmitQueue()
	  } else {
	    this._stat(m, function(exists, isDir) {
	      if (exists) {
	        this._emitQueue.push(m)
	        this._processEmitQueue()
	      }
	    })
	  }
	}

	Glob.prototype._processEmitQueue = function (m) {
	  while (!this._processingEmitQueue &&
	         !this.paused) {
	    this._processingEmitQueue = true
	    var m = this._emitQueue.shift()
	    if (!m) {
	      this._processingEmitQueue = false
	      break
	    }

	    this.log('emit!', m === this.EOF ? "end" : "match")

	    this.emit(m === this.EOF ? "end" : "match", m)
	    this._processingEmitQueue = false
	  }
	}

	Glob.prototype._process = function (pattern, depth, index, cb_) {
	  assert(this instanceof Glob)

	  var cb = function cb (er, res) {
	    assert(this instanceof Glob)
	    if (this.paused) {
	      if (!this._processQueue) {
	        this._processQueue = []
	        this.once("resume", function () {
	          var q = this._processQueue
	          this._processQueue = null
	          q.forEach(function (cb) { cb() })
	        })
	      }
	      this._processQueue.push(cb_.bind(this, er, res))
	    } else {
	      cb_.call(this, er, res)
	    }
	  }.bind(this)

	  if (this.aborted) return cb()

	  if (depth > this.maxDepth) return cb()

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === "string") {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // see if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      prefix = pattern.join("/")
	      this._stat(prefix, function (exists, isDir) {
	        // either it's there, or it isn't.
	        // nothing more to do, either way.
	        if (exists) {
	          if (prefix && isAbsolute(prefix) && !this.nomount) {
	            if (prefix.charAt(0) === "/") {
	              prefix = path.join(this.root, prefix)
	            } else {
	              prefix = path.resolve(this.root, prefix)
	            }
	          }

	          if (process.platform === "win32")
	            prefix = prefix.replace(/\\/g, "/")

	          this.matches[index] = this.matches[index] || {}
	          this.matches[index][prefix] = true
	          this.emitMatch(prefix)
	        }
	        return cb()
	      })
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's "absolute" like /foo/bar,
	      // or "relative" like "../baz"
	      prefix = pattern.slice(0, n)
	      prefix = prefix.join("/")
	      break
	  }

	  // get the list of entries.
	  var read
	  if (prefix === null) read = "."
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
	    if (!prefix || !isAbsolute(prefix)) {
	      prefix = path.join("/", prefix)
	    }
	    read = prefix = path.resolve(prefix)

	    // if (process.platform === "win32")
	    //   read = prefix = prefix.replace(/^[a-zA-Z]:|\\/g, "/")

	    this.log('absolute: ', prefix, this.root, pattern, read)
	  } else {
	    read = prefix
	  }

	  this.log('readdir(%j)', read, this.cwd, this.root)

	  return this._readdir(read, function (er, entries) {
	    if (er) {
	      // not a directory!
	      // this means that, whatever else comes after this, it can never match
	      return cb()
	    }

	    // globstar is special
	    if (pattern[n] === minimatch.GLOBSTAR) {
	      // test without the globstar, and with every child both below
	      // and replacing the globstar.
	      var s = [ pattern.slice(0, n).concat(pattern.slice(n + 1)) ]
	      entries.forEach(function (e) {
	        if (e.charAt(0) === "." && !this.dot) return
	        // instead of the globstar
	        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1)))
	        // below the globstar
	        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n)))
	      }, this)

	      s = s.filter(function (pattern) {
	        var key = gsKey(pattern)
	        var seen = !this._globstars[key]
	        this._globstars[key] = true
	        return seen
	      }, this)

	      if (!s.length)
	        return cb()

	      // now asyncForEach over this
	      var l = s.length
	      , errState = null
	      s.forEach(function (gsPattern) {
	        this._process(gsPattern, depth + 1, index, function (er) {
	          if (errState) return
	          if (er) return cb(errState = er)
	          if (--l <= 0) return cb()
	        })
	      }, this)

	      return
	    }

	    // not a globstar
	    // It will only match dot entries if it starts with a dot, or if
	    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	    var pn = pattern[n]
	    var rawGlob = pattern[n]._glob
	    , dotOk = this.dot || rawGlob.charAt(0) === "."

	    entries = entries.filter(function (e) {
	      return (e.charAt(0) !== "." || dotOk) &&
	             e.match(pattern[n])
	    })

	    // If n === pattern.length - 1, then there's no need for the extra stat
	    // *unless* the user has specified "mark" or "stat" explicitly.
	    // We know that they exist, since the readdir returned them.
	    if (n === pattern.length - 1 &&
	        !this.mark &&
	        !this.stat) {
	      entries.forEach(function (e) {
	        if (prefix) {
	          if (prefix !== "/") e = prefix + "/" + e
	          else e = prefix + e
	        }
	        if (e.charAt(0) === "/" && !this.nomount) {
	          e = path.join(this.root, e)
	        }

	        if (process.platform === "win32")
	          e = e.replace(/\\/g, "/")

	        this.matches[index] = this.matches[index] || {}
	        this.matches[index][e] = true
	        this.emitMatch(e)
	      }, this)
	      return cb.call(this)
	    }


	    // now test all the remaining entries as stand-ins for that part
	    // of the pattern.
	    var l = entries.length
	    , errState = null
	    if (l === 0) return cb() // no matches possible
	    entries.forEach(function (e) {
	      var p = pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1))
	      this._process(p, depth + 1, index, function (er) {
	        if (errState) return
	        if (er) return cb(errState = er)
	        if (--l === 0) return cb.call(this)
	      })
	    }, this)
	  })

	}

	function gsKey (pattern) {
	  return '**' + pattern.map(function (p) {
	    return (p === minimatch.GLOBSTAR) ? '**' : (''+p)
	  }).join('/')
	}

	Glob.prototype._stat = function (f, cb) {
	  assert(this instanceof Glob)
	  var abs = f
	  if (f.charAt(0) === "/") {
	    abs = path.join(this.root, f)
	  } else if (this.changedCwd) {
	    abs = path.resolve(this.cwd, f)
	  }

	  if (f.length > this.maxLength) {
	    var er = new Error("Path name too long")
	    er.code = "ENAMETOOLONG"
	    er.path = f
	    return this._afterStat(f, abs, cb, er)
	  }

	  this.log('stat', [this.cwd, f, '=', abs])

	  if (!this.stat && this.cache.hasOwnProperty(f)) {
	    var exists = this.cache[f]
	    , isDir = exists && (Array.isArray(exists) || exists === 2)
	    if (this.sync) return cb.call(this, !!exists, isDir)
	    return process.nextTick(cb.bind(this, !!exists, isDir))
	  }

	  var stat = this.statCache[abs]
	  if (this.sync || stat) {
	    var er
	    try {
	      stat = fs.statSync(abs)
	    } catch (e) {
	      er = e
	    }
	    this._afterStat(f, abs, cb, er, stat)
	  } else {
	    fs.stat(abs, this._afterStat.bind(this, f, abs, cb))
	  }
	}

	Glob.prototype._afterStat = function (f, abs, cb, er, stat) {
	  var exists
	  assert(this instanceof Glob)

	  if (abs.slice(-1) === "/" && stat && !stat.isDirectory()) {
	    this.log("should be ENOTDIR, fake it")

	    er = new Error("ENOTDIR, not a directory '" + abs + "'")
	    er.path = abs
	    er.code = "ENOTDIR"
	    stat = null
	  }

	  var emit = !this.statCache[abs]
	  this.statCache[abs] = stat

	  if (er || !stat) {
	    exists = false
	  } else {
	    exists = stat.isDirectory() ? 2 : 1
	    if (emit)
	      this.emit('stat', f, stat)
	  }
	  this.cache[f] = this.cache[f] || exists
	  cb.call(this, !!exists, exists === 2)
	}

	Glob.prototype._readdir = function (f, cb) {
	  assert(this instanceof Glob)
	  var abs = f
	  if (f.charAt(0) === "/") {
	    abs = path.join(this.root, f)
	  } else if (isAbsolute(f)) {
	    abs = f
	  } else if (this.changedCwd) {
	    abs = path.resolve(this.cwd, f)
	  }

	  if (f.length > this.maxLength) {
	    var er = new Error("Path name too long")
	    er.code = "ENAMETOOLONG"
	    er.path = f
	    return this._afterReaddir(f, abs, cb, er)
	  }

	  this.log('readdir', [this.cwd, f, abs])
	  if (this.cache.hasOwnProperty(f)) {
	    var c = this.cache[f]
	    if (Array.isArray(c)) {
	      if (this.sync) return cb.call(this, null, c)
	      return process.nextTick(cb.bind(this, null, c))
	    }

	    if (!c || c === 1) {
	      // either ENOENT or ENOTDIR
	      var code = c ? "ENOTDIR" : "ENOENT"
	      , er = new Error((c ? "Not a directory" : "Not found") + ": " + f)
	      er.path = f
	      er.code = code
	      this.log(f, er)
	      if (this.sync) return cb.call(this, er)
	      return process.nextTick(cb.bind(this, er))
	    }

	    // at this point, c === 2, meaning it's a dir, but we haven't
	    // had to read it yet, or c === true, meaning it's *something*
	    // but we don't have any idea what.  Need to read it, either way.
	  }

	  if (this.sync) {
	    var er, entries
	    try {
	      entries = fs.readdirSync(abs)
	    } catch (e) {
	      er = e
	    }
	    return this._afterReaddir(f, abs, cb, er, entries)
	  }

	  fs.readdir(abs, this._afterReaddir.bind(this, f, abs, cb))
	}

	Glob.prototype._afterReaddir = function (f, abs, cb, er, entries) {
	  assert(this instanceof Glob)
	  if (entries && !er) {
	    this.cache[f] = entries
	    // if we haven't asked to stat everything for suresies, then just
	    // assume that everything in there exists, so we can avoid
	    // having to stat it a second time.  This also gets us one step
	    // further into ELOOP territory.
	    if (!this.mark && !this.stat) {
	      entries.forEach(function (e) {
	        if (f === "/") e = f + e
	        else e = f + "/" + e
	        this.cache[e] = true
	      }, this)
	    }

	    return cb.call(this, er, entries)
	  }

	  // now handle errors, and cache the information
	  if (er) switch (er.code) {
	    case "ENOTDIR": // totally normal. means it *does* exist.
	      this.cache[f] = 1
	      return cb.call(this, er)
	    case "ENOENT": // not terribly unusual
	    case "ELOOP":
	    case "ENAMETOOLONG":
	    case "UNKNOWN":
	      this.cache[f] = false
	      return cb.call(this, er)
	    default: // some unusual error.  Treat as failure.
	      this.cache[f] = false
	      if (this.strict) this.emit("error", er)
	      if (!this.silent) console.error("glob error", er)
	      return cb.call(this, er)
	  }
	}

	var isAbsolute = process.platform === "win32" ? absWin : absUnix

	function absWin (p) {
	  if (absUnix(p)) return true
	  // pull off the device/UNC bit from a windows path.
	  // from node's lib/path.js
	  var splitDeviceRe =
	      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
	    , result = splitDeviceRe.exec(p)
	    , device = result[1] || ''
	    , isUnc = device && device.charAt(1) !== ':'
	    , isAbsolute = !!result[2] || isUnc // UNC paths are always absolute

	  return isAbsolute
	}

	function absUnix (p) {
	  return p.charAt(0) === "/" || p === ""
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Monkey-patching the fs module.
	// It's ugly, but there is simply no other way to do this.
	var fs = module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))

	var assert = __webpack_require__(44)

	// fix up some busted stuff, mostly on windows and old nodes
	__webpack_require__(48)

	// The EMFILE enqueuing stuff

	var util = __webpack_require__(45)

	function noop () {}

	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs')
	else if (/\bgfs\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS: ' + m.split(/\n/).join('\nGFS: ')
	    console.error(m)
	  }

	if (/\bgfs\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug('fds', fds)
	    debug(queue)
	    assert.equal(queue.length, 0)
	  })
	}


	var originalOpen = fs.open
	fs.open = open

	function open(path, flags, mode, cb) {
	  if (typeof mode === "function") cb = mode, mode = null
	  if (typeof cb !== "function") cb = noop
	  new OpenReq(path, flags, mode, cb)
	}

	function OpenReq(path, flags, mode, cb) {
	  this.path = path
	  this.flags = flags
	  this.mode = mode
	  this.cb = cb
	  Req.call(this)
	}

	util.inherits(OpenReq, Req)

	OpenReq.prototype.process = function() {
	  originalOpen.call(fs, this.path, this.flags, this.mode, this.done)
	}

	var fds = {}
	OpenReq.prototype.done = function(er, fd) {
	  debug('open done', er, fd)
	  if (fd)
	    fds['fd' + fd] = this.path
	  Req.prototype.done.call(this, er, fd)
	}


	var originalReaddir = fs.readdir
	fs.readdir = readdir

	function readdir(path, cb) {
	  if (typeof cb !== "function") cb = noop
	  new ReaddirReq(path, cb)
	}

	function ReaddirReq(path, cb) {
	  this.path = path
	  this.cb = cb
	  Req.call(this)
	}

	util.inherits(ReaddirReq, Req)

	ReaddirReq.prototype.process = function() {
	  originalReaddir.call(fs, this.path, this.done)
	}

	ReaddirReq.prototype.done = function(er, files) {
	  if (files && files.sort)
	    files = files.sort()
	  Req.prototype.done.call(this, er, files)
	  onclose()
	}


	var originalClose = fs.close
	fs.close = close

	function close (fd, cb) {
	  debug('close', fd)
	  if (typeof cb !== "function") cb = noop
	  delete fds['fd' + fd]
	  originalClose.call(fs, fd, function(er) {
	    onclose()
	    cb(er)
	  })
	}


	var originalCloseSync = fs.closeSync
	fs.closeSync = closeSync

	function closeSync (fd) {
	  try {
	    return originalCloseSync(fd)
	  } finally {
	    onclose()
	  }
	}


	// Req class
	function Req () {
	  // start processing
	  this.done = this.done.bind(this)
	  this.failures = 0
	  this.process()
	}

	Req.prototype.done = function (er, result) {
	  var tryAgain = false
	  if (er) {
	    var code = er.code
	    var tryAgain = code === "EMFILE"
	    if (process.platform === "win32")
	      tryAgain = tryAgain || code === "OK"
	  }

	  if (tryAgain) {
	    this.failures ++
	    enqueue(this)
	  } else {
	    var cb = this.cb
	    cb(er, result)
	  }
	}

	var queue = []

	function enqueue(req) {
	  queue.push(req)
	  debug('enqueue %d %s', queue.length, req.constructor.name, req)
	}

	function onclose() {
	  var req = queue.shift()
	  if (req) {
	    debug('process', req.constructor.name, req)
	    req.process()
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(45);

	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;

	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}

	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}

	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;

	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }

	    return true;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }

	  return false;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }

	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};

	assert.ifError = function(err) { if (err) {throw err;}};

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(46);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(47);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(26)))

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 47 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))

	var origCwd = process.cwd
	var cwd = null
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}

	// (re-)implement some things that are known busted or missing.

	// lchmod, broken prior to 0.6.2
	// back-port the fix here.
	if (constants.hasOwnProperty('O_SYMLINK') &&
	    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          callback(err || err2)
	        })
	      })
	    })
	  }

	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var err, err2
	    try {
	      var ret = fs.fchmodSync(fd, mode)
	    } catch (er) {
	      err = er
	    }
	    try {
	      fs.closeSync(fd)
	    } catch (er) {
	      err2 = er
	    }
	    if (err || err2) throw (err || err2)
	    return ret
	  }
	}


	// lutimes implementation, or no-op
	if (!fs.lutimes) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop
	        if (er) return cb(er)
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2)
	          })
	        })
	      })
	    }

	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	        , err
	        , err2
	        , ret

	      try {
	        var ret = fs.futimesSync(fd, at, mt)
	      } catch (er) {
	        err = er
	      }
	      try {
	        fs.closeSync(fd)
	      } catch (er) {
	        err2 = er
	      }
	      if (err || err2) throw (err || err2)
	      return ret
	    }

	  } else if (fs.utimensat && constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")) {
	    // maybe utimensat will be bound soonish?
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)
	    }

	    fs.lutimesSync = function (path, at, mt) {
	      return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)
	    }

	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}


	// https://github.com/isaacs/node-graceful-fs/issues/4
	// Chown should not fail on einval or eperm if non-root.

	fs.chown = chownFix(fs.chown)
	fs.fchown = chownFix(fs.fchown)
	fs.lchown = chownFix(fs.lchown)

	fs.chownSync = chownFixSync(fs.chownSync)
	fs.fchownSync = chownFixSync(fs.fchownSync)
	fs.lchownSync = chownFixSync(fs.lchownSync)

	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null
	      cb(er, res)
	    })
	  }
	}

	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}

	function chownErOk (er) {
	  // if there's no getuid, or if getuid() is something other than 0,
	  // and the error is EINVAL or EPERM, then just ignore it.
	  // This specific case is a silent failure in cp, install, tar,
	  // and most other unix tools that manage permissions.
	  // When running as root, or if other types of errors are encountered,
	  // then it's strict.
	  if (!er || (!process.getuid || process.getuid() !== 0)
	      && (er.code === "EINVAL" || er.code === "EPERM")) return true
	}


	// if lchmod/lchown do not exist, then make them no-ops
	if (!fs.lchmod) {
	  fs.lchmod = function (path, mode, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchmodSync = function () {}
	}
	if (!fs.lchown) {
	  fs.lchown = function (path, uid, gid, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchownSync = function () {}
	}



	// on Windows, A/V software can lock the directory, causing this
	// to fail with an EACCES or EPERM if the directory contains newly
	// created files.  Try again on failure, for up to 1 second.
	if (process.platform === "win32") {
	  var rename_ = fs.rename
	  fs.rename = function rename (from, to, cb) {
	    var start = Date.now()
	    rename_(from, to, function CB (er) {
	      if (er
	          && (er.code === "EACCES" || er.code === "EPERM")
	          && Date.now() - start < 1000) {
	        return rename_(from, to, CB)
	      }
	      cb(er)
	    })
	  }
	}


	// if read() returns EAGAIN, then just try it again.
	var read = fs.read
	fs.read = function (fd, buffer, offset, length, position, callback_) {
	  var callback
	  if (callback_ && typeof callback_ === 'function') {
	    var eagCounter = 0
	    callback = function (er, _, __) {
	      if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        return read.call(fs, fd, buffer, offset, length, position, callback)
	      }
	      callback_.apply(this, arguments)
	    }
	  }
	  return read.call(fs, fd, buffer, offset, length, position, callback)
	}

	var readSync = fs.readSync
	fs.readSync = function (fd, buffer, offset, length, position) {
	  var eagCounter = 0
	  while (true) {
	    try {
	      return readSync.call(fs, fd, buffer, offset, length, position)
	    } catch (er) {
	      if (er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        continue
	      }
	      throw er
	    }
	  }
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 49 */,
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(module, process) {;(function (require, exports, module, platform) {

	if (module) module.exports = minimatch
	else exports.minimatch = minimatch

	if (!__webpack_require__(51)) {
	  require = function (id) {
	    switch (id) {
	      case "sigmund": return function sigmund (obj) {
	        return JSON.stringify(obj)
	      }
	      case "path": return { basename: function (f) {
	        f = f.split(/[\/\\]/)
	        var e = f.pop()
	        if (!e) e = f.pop()
	        return e
	      }}
	      case "lru-cache": return function LRUCache () {
	        // not quite an LRU, but still space-limited.
	        var cache = {}
	        var cnt = 0
	        this.set = function (k, v) {
	          cnt ++
	          if (cnt >= 100) cache = {}
	          cache[k] = v
	        }
	        this.get = function (k) { return cache[k] }
	      }
	    }
	  }
	}

	minimatch.Minimatch = Minimatch

	var LRU = require("lru-cache")
	  , cache = minimatch.cache = new LRU({max: 100})
	  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	  , sigmund = require("sigmund")

	var path = require("path")
	  // any single thing other than /
	  // don't need to escape / when using new RegExp()
	  , qmark = "[^/]"

	  // * => any number of characters
	  , star = qmark + "*?"

	  // ** when dots are allowed.  Anything goes, except .. and .
	  // not (^ or / followed by one or two dots followed by $ or /),
	  // followed by anything, any number of times.
	  , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"

	  // not a ^ or / followed by a dot,
	  // followed by anything, any number of times.
	  , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"

	  // characters that need to be escaped in RegExp.
	  , reSpecials = charSet("().*{}+?[]^$\\!")

	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split("").reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}

	// normalizes slashes.
	var slashSplit = /\/+/

	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}

	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch

	  var orig = minimatch

	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }

	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }

	  return m
	}

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}


	function minimatch (p, pattern, options) {
	  if (typeof pattern !== "string") {
	    throw new TypeError("glob pattern string required")
	  }

	  if (!options) options = {}

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === "#") {
	    return false
	  }

	  // "" only matches ""
	  if (pattern.trim() === "") return p === ""

	  return new Minimatch(pattern, options).match(p)
	}

	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options, cache)
	  }

	  if (typeof pattern !== "string") {
	    throw new TypeError("glob pattern string required")
	  }

	  if (!options) options = {}
	  pattern = pattern.trim()

	  // windows: need to use /, not \
	  // On other platforms, \ is a valid (albeit bad) filename char.
	  if (platform === "win32") {
	    pattern = pattern.split("\\").join("/")
	  }

	  // lru storage.
	  // these things aren't particularly big, but walking down the string
	  // and turning it into a regexp can get pretty costly.
	  var cacheKey = pattern + "\n" + sigmund(options)
	  var cached = minimatch.cache.get(cacheKey)
	  if (cached) return cached
	  minimatch.cache.set(cacheKey, this)

	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false

	  // make the set of regexps etc.
	  this.make()
	}

	Minimatch.prototype.debug = function() {}

	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return

	  var pattern = this.pattern
	  var options = this.options

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === "#") {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate()

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()

	  if (options.debug) this.debug = console.error

	  this.debug(this.pattern, set)

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })

	  this.debug(this.pattern, set)

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)

	  this.debug(this.pattern, set)

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return -1 === s.indexOf(false)
	  })

	  this.debug(this.pattern, set)

	  this.set = set
	}

	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	    , negate = false
	    , options = this.options
	    , negateOffset = 0

	  if (options.nonegate) return

	  for ( var i = 0, l = pattern.length
	      ; i < l && pattern.charAt(i) === "!"
	      ; i ++) {
	    negate = !negate
	    negateOffset ++
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return new Minimatch(pattern, options).braceExpand()
	}

	Minimatch.prototype.braceExpand = braceExpand
	function braceExpand (pattern, options) {
	  options = options || this.options
	  pattern = typeof pattern === "undefined"
	    ? this.pattern : pattern

	  if (typeof pattern === "undefined") {
	    throw new Error("undefined pattern")
	  }

	  if (options.nobrace ||
	      !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }

	  var escaping = false

	  // examples and comments refer to this crazy pattern:
	  // a{b,c{d,e},{f,g}h}x{y,z}
	  // expected:
	  // abxy
	  // abxz
	  // acdxy
	  // acdxz
	  // acexy
	  // acexz
	  // afhxy
	  // afhxz
	  // aghxy
	  // aghxz

	  // everything before the first \{ is just a prefix.
	  // So, we pluck that off, and work with the rest,
	  // and then prepend it to everything we find.
	  if (pattern.charAt(0) !== "{") {
	    this.debug(pattern)
	    var prefix = null
	    for (var i = 0, l = pattern.length; i < l; i ++) {
	      var c = pattern.charAt(i)
	      this.debug(i, c)
	      if (c === "\\") {
	        escaping = !escaping
	      } else if (c === "{" && !escaping) {
	        prefix = pattern.substr(0, i)
	        break
	      }
	    }

	    // actually no sets, all { were escaped.
	    if (prefix === null) {
	      this.debug("no sets")
	      return [pattern]
	    }

	   var tail = braceExpand.call(this, pattern.substr(i), options)
	    return tail.map(function (t) {
	      return prefix + t
	    })
	  }

	  // now we have something like:
	  // {b,c{d,e},{f,g}h}x{y,z}
	  // walk through the set, expanding each part, until
	  // the set ends.  then, we'll expand the suffix.
	  // If the set only has a single member, then'll put the {} back

	  // first, handle numeric sets, since they're easier
	  var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
	  if (numset) {
	    this.debug("numset", numset[1], numset[2])
	    var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)
	      , start = +numset[1]
	      , end = +numset[2]
	      , inc = start > end ? -1 : 1
	      , set = []
	    for (var i = start; i != (end + inc); i += inc) {
	      // append all the suffixes
	      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
	        set.push(i + suf[ii])
	      }
	    }
	    return set
	  }

	  // ok, walk through the set
	  // We hope, somewhat optimistically, that there
	  // will be a } at the end.
	  // If the closing brace isn't found, then the pattern is
	  // interpreted as braceExpand("\\" + pattern) so that
	  // the leading \{ will be interpreted literally.
	  var i = 1 // skip the \{
	    , depth = 1
	    , set = []
	    , member = ""
	    , sawEnd = false
	    , escaping = false

	  function addMember () {
	    set.push(member)
	    member = ""
	  }

	  this.debug("Entering for")
	  FOR: for (i = 1, l = pattern.length; i < l; i ++) {
	    var c = pattern.charAt(i)
	    this.debug("", i, c)

	    if (escaping) {
	      escaping = false
	      member += "\\" + c
	    } else {
	      switch (c) {
	        case "\\":
	          escaping = true
	          continue

	        case "{":
	          depth ++
	          member += "{"
	          continue

	        case "}":
	          depth --
	          // if this closes the actual set, then we're done
	          if (depth === 0) {
	            addMember()
	            // pluck off the close-brace
	            i ++
	            break FOR
	          } else {
	            member += c
	            continue
	          }

	        case ",":
	          if (depth === 1) {
	            addMember()
	          } else {
	            member += c
	          }
	          continue

	        default:
	          member += c
	          continue
	      } // switch
	    } // else
	  } // for

	  // now we've either finished the set, and the suffix is
	  // pattern.substr(i), or we have *not* closed the set,
	  // and need to escape the leading brace
	  if (depth !== 0) {
	    this.debug("didn't close", pattern)
	    return braceExpand.call(this, "\\" + pattern, options)
	  }

	  // x{y,z} -> ["xy", "xz"]
	  this.debug("set", set)
	  this.debug("suffix", pattern.substr(i))
	  var suf = braceExpand.call(this, pattern.substr(i), options)
	  // ["b", "c{d,e}","{f,g}h"] ->
	  //   [["b"], ["cd", "ce"], ["fh", "gh"]]
	  var addBraces = set.length === 1
	  this.debug("set pre-expanded", set)
	  set = set.map(function (p) {
	    return braceExpand.call(this, p, options)
	  }, this)
	  this.debug("set expanded", set)


	  // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
	  //   ["b", "cd", "ce", "fh", "gh"]
	  set = set.reduce(function (l, r) {
	    return l.concat(r)
	  })

	  if (addBraces) {
	    set = set.map(function (s) {
	      return "{" + s + "}"
	    })
	  }

	  // now attach the suffixes.
	  var ret = []
	  for (var i = 0, l = set.length; i < l; i ++) {
	    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
	      ret.push(set[i] + suf[ii])
	    }
	  }
	  return ret
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  var options = this.options

	  // shortcuts
	  if (!options.noglobstar && pattern === "**") return GLOBSTAR
	  if (pattern === "") return ""

	  var re = ""
	    , hasMagic = !!options.nocase
	    , escaping = false
	    // ? => one single character
	    , patternListStack = []
	    , plType
	    , stateChar
	    , inClass = false
	    , reClassStart = -1
	    , classStart = -1
	    // . and .. never match anything that doesn't start with .,
	    // even when options.dot is set.
	    , patternStart = pattern.charAt(0) === "." ? "" // anything
	      // not (start or / followed by . or .. followed by / or end)
	      : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
	      : "(?!\\.)"
	    , self = this

	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case "*":
	          re += star
	          hasMagic = true
	          break
	        case "?":
	          re += qmark
	          hasMagic = true
	          break
	        default:
	          re += "\\"+stateChar
	          break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }

	  for ( var i = 0, len = pattern.length, c
	      ; (i < len) && (c = pattern.charAt(i))
	      ; i ++ ) {

	    this.debug("%s\t%s %s %j", pattern, i, re, c)

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += "\\" + c
	      escaping = false
	      continue
	    }

	    SWITCH: switch (c) {
	      case "/":
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false

	      case "\\":
	        clearStateChar()
	        escaping = true
	        continue

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case "?":
	      case "*":
	      case "+":
	      case "@":
	      case "!":
	        this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c)

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === "!" && i === classStart + 1) c = "^"
	          re += c
	          continue
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	        continue

	      case "(":
	        if (inClass) {
	          re += "("
	          continue
	        }

	        if (!stateChar) {
	          re += "\\("
	          continue
	        }

	        plType = stateChar
	        patternListStack.push({ type: plType
	                              , start: i - 1
	                              , reStart: re.length })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === "!" ? "(?:(?!" : "(?:"
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	        continue

	      case ")":
	        if (inClass || !patternListStack.length) {
	          re += "\\)"
	          continue
	        }

	        clearStateChar()
	        hasMagic = true
	        re += ")"
	        plType = patternListStack.pop().type
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        switch (plType) {
	          case "!":
	            re += "[^/]*?)"
	            break
	          case "?":
	          case "+":
	          case "*": re += plType
	          case "@": break // the default anyway
	        }
	        continue

	      case "|":
	        if (inClass || !patternListStack.length || escaping) {
	          re += "\\|"
	          escaping = false
	          continue
	        }

	        clearStateChar()
	        re += "|"
	        continue

	      // these are mostly the same in regexp and glob
	      case "[":
	        // swallow any state-tracking char before the [
	        clearStateChar()

	        if (inClass) {
	          re += "\\" + c
	          continue
	        }

	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	        continue

	      case "]":
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += "\\" + c
	          escaping = false
	          continue
	        }

	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	        continue

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()

	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	                   && !(c === "^" && inClass)) {
	          re += "\\"
	        }

	        re += c

	    } // switch
	  } // for


	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    var cs = pattern.substr(classStart + 1)
	      , sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + "\\[" + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  var pl
	  while (pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + 3)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = "\\"
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + "|"
	    })

	    this.debug("tail=%j\n   %s", tail, tail)
	    var t = pl.type === "*" ? star
	          : pl.type === "?" ? qmark
	          : "\\" + pl.type

	    hasMagic = true
	    re = re.slice(0, pl.reStart)
	       + t + "\\("
	       + tail
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += "\\\\"
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case ".":
	    case "[":
	    case "(": addPatternStart = true
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== "" && hasMagic) re = "(?=.)" + re

	  if (addPatternStart) re = patternStart + re

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [ re, hasMagic ]
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }

	  var flags = options.nocase ? "i" : ""
	    , regExp = new RegExp("^" + re + "$", flags)

	  regExp._glob = pattern
	  regExp._src = re

	  return regExp
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}

	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set

	  if (!set.length) return this.regexp = false
	  var options = this.options

	  var twoStar = options.noglobstar ? star
	      : options.dot ? twoStarDot
	      : twoStarNoDot
	    , flags = options.nocase ? "i" : ""

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	           : (typeof p === "string") ? regExpEscape(p)
	           : p._src
	    }).join("\\\/")
	  }).join("|")

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = "^(?:" + re + ")$"

	  // can match anything, as long as it's not this.
	  if (this.negate) re = "^(?!" + re + ").*$"

	  try {
	    return this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    return this.regexp = false
	  }
	}

	minimatch.match = function (list, pattern, options) {
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}

	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug("match", f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ""

	  if (f === "/" && partial) return true

	  var options = this.options

	  // windows: need to use /, not \
	  // On other platforms, \ is a valid (albeit bad) filename char.
	  if (platform === "win32") {
	    f = f.split("\\").join("/")
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, "split", f)

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set
	  this.debug(this.pattern, "set", set)

	  var splitFile = path.basename(f.join("/")).split("/")

	  for (var i = 0, l = set.length; i < l; i ++) {
	    var pattern = set[i], file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = splitFile
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options

	  this.debug("matchOne",
	              { "this": this
	              , file: file
	              , pattern: pattern })

	  this.debug("matchOne", file.length, pattern.length)

	  for ( var fi = 0
	          , pi = 0
	          , fl = file.length
	          , pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi ++, pi ++ ) {

	    this.debug("matchOne loop")
	    var p = pattern[pi]
	      , f = file[fi]

	    this.debug(pattern, p, f)

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	        , pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for ( ; fi < fl; fi ++) {
	          if (file[fi] === "." || file[fi] === ".." ||
	              (!options.dot && file[fi].charAt(0) === ".")) return false
	        }
	        return true
	      }

	      // ok, let's see if we can swallow whatever we can.
	      WHILE: while (fr < fl) {
	        var swallowee = file[fr]

	        this.debug('\nglobstar while',
	                    file, fr, pattern, pr, swallowee)

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === "." || swallowee === ".." ||
	              (!options.dot && swallowee.charAt(0) === ".")) {
	            this.debug("dot detected!", file, fr, pattern, pr)
	            break WHILE
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr ++
	        }
	      }
	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then 
	      if (partial) {
	        // ran out of file
	        this.debug("\n>>> no match, partial?", file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === "string") {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug("string match", p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug("pattern match", p, f, hit)
	    }

	    if (!hit) return false
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")
	    return emptyFileEnd
	  }

	  // should be unreachable.
	  throw new Error("wtf?")
	}


	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, "$1")
	}


	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
	}

	})( typeof require === "function" ? require : null,
	    this,
	     true ? module : null,
	    typeof process === "object" ? process.platform : "win32"
	  )

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(28)(module), __webpack_require__(26)))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./minimatch": 50,
		"./minimatch.js": 50,
		"./test/basic": 55,
		"./test/basic.js": 55,
		"./test/brace-expand": 56,
		"./test/brace-expand.js": 56,
		"./test/caching": 57,
		"./test/caching.js": 57,
		"./test/defaults": 58,
		"./test/defaults.js": 58,
		"./test/extglob-ending-with-state-char": 59,
		"./test/extglob-ending-with-state-char.js": 59
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 51;


/***/ },
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test
	//
	// TODO: Some of these tests do very bad things with backslashes, and will
	// most likely fail badly on windows.  They should probably be skipped.

	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , globalBefore = Object.keys(global)
	  , mm = __webpack_require__(50)
	  , files = [ "a", "b", "c", "d", "abc"
	            , "abd", "abe", "bb", "bcd"
	            , "ca", "cb", "dd", "de"
	            , "bdir/", "bdir/cfile"]
	  , next = files.concat([ "a-b", "aXb"
	                        , ".x", ".y" ])


	var patterns =
	  [ "http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test"
	  , ["a*", ["a", "abc", "abd", "abe"]]
	  , ["X*", ["X*"], {nonull: true}]

	  // allow null glob expansion
	  , ["X*", []]

	  // isaacs: Slightly different than bash/sh/ksh
	  // \\* is not un-escaped to literal "*" in a failed match,
	  // but it does make it get treated as a literal star
	  , ["\\*", ["\\*"], {nonull: true}]
	  , ["\\**", ["\\**"], {nonull: true}]
	  , ["\\*\\*", ["\\*\\*"], {nonull: true}]

	  , ["b*/", ["bdir/"]]
	  , ["c*", ["c", "ca", "cb"]]
	  , ["**", files]

	  , ["\\.\\./*/", ["\\.\\./*/"], {nonull: true}]
	  , ["s/\\..*//", ["s/\\..*//"], {nonull: true}]

	  , "legendary larry crashes bashes"
	  , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"], {nonull: true}]
	  , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"], {nonull: true}]

	  , "character classes"
	  , ["[a-c]b*", ["abc", "abd", "abe", "bb", "cb"]]
	  , ["[a-y]*[^c]", ["abd", "abe", "bb", "bcd",
	     "bdir/", "ca", "cb", "dd", "de"]]
	  , ["a*[^c]", ["abd", "abe"]]
	  , function () { files.push("a-b", "aXb") }
	  , ["a[X-]b", ["a-b", "aXb"]]
	  , function () { files.push(".x", ".y") }
	  , ["[^a-c]*", ["d", "dd", "de"]]
	  , function () { files.push("a*b/", "a*b/ooo") }
	  , ["a\\*b/*", ["a*b/ooo"]]
	  , ["a\\*?/*", ["a*b/ooo"]]
	  , ["*\\\\!*", [], {null: true}, ["echo !7"]]
	  , ["*\\!*", ["echo !7"], null, ["echo !7"]]
	  , ["*.\\*", ["r.*"], null, ["r.*"]]
	  , ["a[b]c", ["abc"]]
	  , ["a[\\b]c", ["abc"]]
	  , ["a?c", ["abc"]]
	  , ["a\\*c", [], {null: true}, ["abc"]]
	  , ["", [""], { null: true }, [""]]

	  , "http://www.opensource.apple.com/source/bash/bash-23/" +
	    "bash/tests/glob-test"
	  , function () { files.push("man/", "man/man1/", "man/man1/bash.1") }
	  , ["*/man*/bash.*", ["man/man1/bash.1"]]
	  , ["man/man1/bash.1", ["man/man1/bash.1"]]
	  , ["a***c", ["abc"], null, ["abc"]]
	  , ["a*****?c", ["abc"], null, ["abc"]]
	  , ["?*****??", ["abc"], null, ["abc"]]
	  , ["*****??", ["abc"], null, ["abc"]]
	  , ["?*****?c", ["abc"], null, ["abc"]]
	  , ["?***?****c", ["abc"], null, ["abc"]]
	  , ["?***?****?", ["abc"], null, ["abc"]]
	  , ["?***?****", ["abc"], null, ["abc"]]
	  , ["*******c", ["abc"], null, ["abc"]]
	  , ["*******?", ["abc"], null, ["abc"]]
	  , ["a*cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??k***", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??***k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??***k**", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a****c**?**??*****", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["[-abc]", ["-"], null, ["-"]]
	  , ["[abc-]", ["-"], null, ["-"]]
	  , ["\\", ["\\"], null, ["\\"]]
	  , ["[\\\\]", ["\\"], null, ["\\"]]
	  , ["[[]", ["["], null, ["["]]
	  , ["[", ["["], null, ["["]]
	  , ["[*", ["[abc"], null, ["[abc"]]
	  , "a right bracket shall lose its special meaning and\n" +
	    "represent itself in a bracket expression if it occurs\n" +
	    "first in the list.  -- POSIX.2 2.8.3.2"
	  , ["[]]", ["]"], null, ["]"]]
	  , ["[]-]", ["]"], null, ["]"]]
	  , ["[a-\z]", ["p"], null, ["p"]]
	  , ["??**********?****?", [], { null: true }, ["abc"]]
	  , ["??**********?****c", [], { null: true }, ["abc"]]
	  , ["?************c****?****", [], { null: true }, ["abc"]]
	  , ["*c*?**", [], { null: true }, ["abc"]]
	  , ["a*****c*?**", [], { null: true }, ["abc"]]
	  , ["a********???*******", [], { null: true }, ["abc"]]
	  , ["[]", [], { null: true }, ["a"]]
	  , ["[abc", [], { null: true }, ["["]]

	  , "nocase tests"
	  , ["XYZ", ["xYz"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]
	  , ["ab*", ["ABC"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]
	  , ["[ia]?[ck]", ["ABC", "IjK"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]

	  // [ pattern, [matches], MM opts, files, TAP opts]
	  , "onestar/twostar"
	  , ["{/*,*}", [], {null: true}, ["/asdf/asdf/asdf"]]
	  , ["{/?,*}", ["/a", "bb"], {null: true}
	    , ["/a", "/b/b", "/a/b/c", "bb"]]

	  , "dots should not match unless requested"
	  , ["**", ["a/b"], {}, ["a/b", "a/.d", ".a/.d"]]

	  // .. and . can only match patterns starting with .,
	  // even when options.dot is set.
	  , function () {
	      files = ["a/./b", "a/../b", "a/c/b", "a/.d/b"]
	    }
	  , ["a/*/b", ["a/c/b", "a/.d/b"], {dot: true}]
	  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: true}]
	  , ["a/*/b", ["a/c/b"], {dot:false}]
	  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: false}]


	  // this also tests that changing the options needs
	  // to change the cache key, even if the pattern is
	  // the same!
	  , ["**", ["a/b","a/.d",".a/.d"], { dot: true }
	    , [ ".a/.d", "a/.d", "a/b"]]

	  , "paren sets cannot contain slashes"
	  , ["*(a/b)", ["*(a/b)"], {nonull: true}, ["a/b"]]

	  // brace sets trump all else.
	  //
	  // invalid glob pattern.  fails on bash4 and bsdglob.
	  // however, in this implementation, it's easier just
	  // to do the intuitive thing, and let brace-expansion
	  // actually come before parsing any extglob patterns,
	  // like the documentation seems to say.
	  //
	  // XXX: if anyone complains about this, either fix it
	  // or tell them to grow up and stop complaining.
	  //
	  // bash/bsdglob says this:
	  // , ["*(a|{b),c)}", ["*(a|{b),c)}"], {}, ["a", "ab", "ac", "ad"]]
	  // but we do this instead:
	  , ["*(a|{b),c)}", ["a", "ab", "ac"], {}, ["a", "ab", "ac", "ad"]]

	  // test partial parsing in the presence of comment/negation chars
	  , ["[!a*", ["[!ab"], {}, ["[!ab", "[ab"]]
	  , ["[#a*", ["[#ab"], {}, ["[#ab", "[ab"]]

	  // like: {a,b|c\\,d\\\|e} except it's unclosed, so it has to be escaped.
	  , ["+(a|*\\|c\\\\|d\\\\\\|e\\\\\\\\|f\\\\\\\\\\|g"
	    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g"]
	    , {}
	    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g", "a", "b\\c"]]


	  // crazy nested {,,} and *(||) tests.
	  , function () {
	      files = [ "a", "b", "c", "d"
	              , "ab", "ac", "ad"
	              , "bc", "cb"
	              , "bc,d", "c,db", "c,d"
	              , "d)", "(b|c", "*(b|c"
	              , "b|c", "b|cc", "cb|c"
	              , "x(a|b|c)", "x(a|c)"
	              , "(a|b|c)", "(a|c)"]
	    }
	  , ["*(a|{b,c})", ["a", "b", "c", "ab", "ac"]]
	  , ["{a,*(b|c,d)}", ["a","(b|c", "*(b|c", "d)"]]
	  // a
	  // *(b|c)
	  // *(b|d)
	  , ["{a,*(b|{c,d})}", ["a","b", "bc", "cb", "c", "d"]]
	  , ["*(a|{b|c,c})", ["a", "b", "c", "ab", "ac", "bc", "cb"]]


	  // test various flag settings.
	  , [ "*(a|{b|c,c})", ["x(a|b|c)", "x(a|c)", "(a|b|c)", "(a|c)"]
	    , { noext: true } ]
	  , ["a?b", ["x/y/acb", "acb/"], {matchBase: true}
	    , ["x/y/acb", "acb/", "acb/d/e", "x/y/acb/d"] ]
	  , ["#*", ["#a", "#b"], {nocomment: true}, ["#a", "#b", "c#d"]]


	  // begin channelling Boole and deMorgan...
	  , "negation tests"
	  , function () {
	      files = ["d", "e", "!ab", "!abc", "a!b", "\\!a"]
	    }

	  // anything that is NOT a* matches.
	  , ["!a*", ["\\!a", "d", "e", "!ab", "!abc"]]

	  // anything that IS !a* matches.
	  , ["!a*", ["!ab", "!abc"], {nonegate: true}]

	  // anything that IS a* matches
	  , ["!!a*", ["a!b"]]

	  // anything that is NOT !a* matches
	  , ["!\\!a*", ["a!b", "d", "e", "\\!a"]]

	  // negation nestled within a pattern
	  , function () {
	      files = [ "foo.js"
	              , "foo.bar"
	              // can't match this one without negative lookbehind.
	              , "foo.js.js"
	              , "blar.js"
	              , "foo."
	              , "boo.js.boo" ]
	    }
	  , ["*.!(js)", ["foo.bar", "foo.", "boo.js.boo"] ]

	  // https://github.com/isaacs/minimatch/issues/5
	  , function () {
	      files = [ 'a/b/.x/c'
	              , 'a/b/.x/c/d'
	              , 'a/b/.x/c/d/e'
	              , 'a/b/.x'
	              , 'a/b/.x/'
	              , 'a/.x/b'
	              , '.x'
	              , '.x/'
	              , '.x/a'
	              , '.x/a/b'
	              , 'a/.x/b/.x/c'
	              , '.x/.x' ]
	  }
	  , ["**/.x/**", [ '.x/'
	                 , '.x/a'
	                 , '.x/a/b'
	                 , 'a/.x/b'
	                 , 'a/b/.x/'
	                 , 'a/b/.x/c'
	                 , 'a/b/.x/c/d'
	                 , 'a/b/.x/c/d/e' ] ]

	  ]

	var regexps =
	  [ '/^(?:(?=.)a[^/]*?)$/',
	    '/^(?:(?=.)X[^/]*?)$/',
	    '/^(?:(?=.)X[^/]*?)$/',
	    '/^(?:\\*)$/',
	    '/^(?:(?=.)\\*[^/]*?)$/',
	    '/^(?:\\*\\*)$/',
	    '/^(?:(?=.)b[^/]*?\\/)$/',
	    '/^(?:(?=.)c[^/]*?)$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?)$/',
	    '/^(?:\\.\\.\\/(?!\\.)(?=.)[^/]*?\\/)$/',
	    '/^(?:s\\/(?=.)\\.\\.[^/]*?\\/)$/',
	    '/^(?:\\/\\^root:\\/\\{s\\/(?=.)\\^[^:][^/]*?:[^:][^/]*?:\\([^:]\\)[^/]*?\\.[^/]*?\\$\\/1\\/)$/',
	    '/^(?:\\/\\^root:\\/\\{s\\/(?=.)\\^[^:][^/]*?:[^:][^/]*?:\\([^:]\\)[^/]*?\\.[^/]*?\\$\\/\u0001\\/)$/',
	    '/^(?:(?!\\.)(?=.)[a-c]b[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[a-y][^/]*?[^c])$/',
	    '/^(?:(?=.)a[^/]*?[^c])$/',
	    '/^(?:(?=.)a[X-]b)$/',
	    '/^(?:(?!\\.)(?=.)[^a-c][^/]*?)$/',
	    '/^(?:a\\*b\\/(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?=.)a\\*[^/]\\/(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\\\\\![^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\![^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\.\\*)$/',
	    '/^(?:(?=.)a[b]c)$/',
	    '/^(?:(?=.)a[b]c)$/',
	    '/^(?:(?=.)a[^/]c)$/',
	    '/^(?:a\\*c)$/',
	    'false',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\/(?=.)man[^/]*?\\/(?=.)bash\\.[^/]*?)$/',
	    '/^(?:man\\/man1\\/bash\\.1)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?=.)a[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k[^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[-abc])$/',
	    '/^(?:(?!\\.)(?=.)[abc-])$/',
	    '/^(?:\\\\)$/',
	    '/^(?:(?!\\.)(?=.)[\\\\])$/',
	    '/^(?:(?!\\.)(?=.)[\\[])$/',
	    '/^(?:\\[)$/',
	    '/^(?:(?=.)\\[(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[\\]])$/',
	    '/^(?:(?!\\.)(?=.)[\\]-])$/',
	    '/^(?:(?!\\.)(?=.)[a-z])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:\\[\\])$/',
	    '/^(?:\\[abc)$/',
	    '/^(?:(?=.)XYZ)$/i',
	    '/^(?:(?=.)ab[^/]*?)$/i',
	    '/^(?:(?!\\.)(?=.)[ia][^/][ck])$/i',
	    '/^(?:\\/(?!\\.)(?=.)[^/]*?|(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:\\/(?!\\.)(?=.)[^/]|(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?)$/',
	    '/^(?:a\\/(?!(?:^|\\/)\\.{1,2}(?:$|\\/))(?=.)[^/]*?\\/b)$/',
	    '/^(?:a\\/(?=.)\\.[^/]*?\\/b)$/',
	    '/^(?:a\\/(?!\\.)(?=.)[^/]*?\\/b)$/',
	    '/^(?:a\\/(?=.)\\.[^/]*?\\/b)$/',
	    '/^(?:(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\(a\\/b\\))$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:(?=.)\\[(?=.)\\!a[^/]*?)$/',
	    '/^(?:(?=.)\\[(?=.)#a[^/]*?)$/',
	    '/^(?:(?=.)\\+\\(a\\|[^/]*?\\|c\\\\\\\\\\|d\\\\\\\\\\|e\\\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\\\|g)$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:a|(?!\\.)(?=.)[^/]*?\\(b\\|c|d\\))$/',
	    '/^(?:a|(?!\\.)(?=.)(?:b|c)*|(?!\\.)(?=.)(?:b|d)*)$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b|c)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\(a\\|b\\|c\\)|(?!\\.)(?=.)[^/]*?\\(a\\|c\\))$/',
	    '/^(?:(?=.)a[^/]b)$/',
	    '/^(?:(?=.)#[^/]*?)$/',
	    '/^(?!^(?:(?=.)a[^/]*?)$).*$/',
	    '/^(?:(?=.)\\!a[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?)$/',
	    '/^(?!^(?:(?=.)\\!a[^/]*?)$).*$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\.(?:(?!js)[^/]*?))$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?\\/\\.x\\/(?:(?!(?:\\/|^)\\.).)*?)$/' ]
	var re = 0;

	tap.test("basic tests", function (t) {
	  var start = Date.now()

	  // [ pattern, [matches], MM opts, files, TAP opts]
	  patterns.forEach(function (c) {
	    if (typeof c === "function") return c()
	    if (typeof c === "string") return t.comment(c)

	    var pattern = c[0]
	      , expect = c[1].sort(alpha)
	      , options = c[2] || {}
	      , f = c[3] || files
	      , tapOpts = c[4] || {}

	    // options.debug = true
	    var m = new mm.Minimatch(pattern, options)
	    var r = m.makeRe()
	    var expectRe = regexps[re++]
	    tapOpts.re = String(r) || JSON.stringify(r)
	    tapOpts.files = JSON.stringify(f)
	    tapOpts.pattern = pattern
	    tapOpts.set = m.set
	    tapOpts.negated = m.negate

	    var actual = mm.match(f, pattern, options)
	    actual.sort(alpha)

	    t.equivalent( actual, expect
	                , JSON.stringify(pattern) + " " + JSON.stringify(expect)
	                , tapOpts )

	    t.equal(tapOpts.re, expectRe, tapOpts)
	  })

	  t.comment("time=" + (Date.now() - start) + "ms")
	  t.end()
	})

	tap.test("global leak test", function (t) {
	  var globalAfter = Object.keys(global)
	  t.equivalent(globalAfter, globalBefore, "no new globals, please")
	  t.end()
	})

	function alpha (a, b) {
	  return a > b ? 1 : -1
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , minimatch = __webpack_require__(50)

	tap.test("brace expansion", function (t) {
	  // [ pattern, [expanded] ]
	  ; [ [ "a{b,c{d,e},{f,g}h}x{y,z}"
	      , [ "abxy"
	        , "abxz"
	        , "acdxy"
	        , "acdxz"
	        , "acexy"
	        , "acexz"
	        , "afhxy"
	        , "afhxz"
	        , "aghxy"
	        , "aghxz" ] ]
	    , [ "a{1..5}b"
	      , [ "a1b"
	        , "a2b"
	        , "a3b"
	        , "a4b"
	        , "a5b" ] ]
	    , [ "a{b}c", ["a{b}c"] ]
	  ].forEach(function (tc) {
	    var p = tc[0]
	      , expect = tc[1]
	    t.equivalent(minimatch.braceExpand(p), expect, p)
	  })
	  console.error("ending")
	  t.end()
	})




/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var Minimatch = __webpack_require__(50).Minimatch
	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	tap.test("cache test", function (t) {
	  var mm1 = new Minimatch("a?b")
	  var mm2 = new Minimatch("a?b")
	  t.equal(mm1, mm2, "should get the same object")
	  // the lru should drop it after 100 entries
	  for (var i = 0; i < 100; i ++) {
	    new Minimatch("a"+i)
	  }
	  mm2 = new Minimatch("a?b")
	  t.notEqual(mm1, mm2, "cache should have dropped")
	  t.end()
	})


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test
	//
	// TODO: Some of these tests do very bad things with backslashes, and will
	// most likely fail badly on windows.  They should probably be skipped.

	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , globalBefore = Object.keys(global)
	  , mm = __webpack_require__(50)
	  , files = [ "a", "b", "c", "d", "abc"
	            , "abd", "abe", "bb", "bcd"
	            , "ca", "cb", "dd", "de"
	            , "bdir/", "bdir/cfile"]
	  , next = files.concat([ "a-b", "aXb"
	                        , ".x", ".y" ])

	tap.test("basic tests", function (t) {
	  var start = Date.now()

	  // [ pattern, [matches], MM opts, files, TAP opts]
	  ; [ "http://www.bashcookbook.com/bashinfo" +
	      "/source/bash-1.14.7/tests/glob-test"
	    , ["a*", ["a", "abc", "abd", "abe"]]
	    , ["X*", ["X*"], {nonull: true}]

	    // allow null glob expansion
	    , ["X*", []]

	    // isaacs: Slightly different than bash/sh/ksh
	    // \\* is not un-escaped to literal "*" in a failed match,
	    // but it does make it get treated as a literal star
	    , ["\\*", ["\\*"], {nonull: true}]
	    , ["\\**", ["\\**"], {nonull: true}]
	    , ["\\*\\*", ["\\*\\*"], {nonull: true}]

	    , ["b*/", ["bdir/"]]
	    , ["c*", ["c", "ca", "cb"]]
	    , ["**", files]

	    , ["\\.\\./*/", ["\\.\\./*/"], {nonull: true}]
	    , ["s/\\..*//", ["s/\\..*//"], {nonull: true}]

	    , "legendary larry crashes bashes"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"
	      , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"], {nonull: true}]
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"
	      , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"], {nonull: true}]

	    , "character classes"
	    , ["[a-c]b*", ["abc", "abd", "abe", "bb", "cb"]]
	    , ["[a-y]*[^c]", ["abd", "abe", "bb", "bcd",
	       "bdir/", "ca", "cb", "dd", "de"]]
	    , ["a*[^c]", ["abd", "abe"]]
	    , function () { files.push("a-b", "aXb") }
	    , ["a[X-]b", ["a-b", "aXb"]]
	    , function () { files.push(".x", ".y") }
	    , ["[^a-c]*", ["d", "dd", "de"]]
	    , function () { files.push("a*b/", "a*b/ooo") }
	    , ["a\\*b/*", ["a*b/ooo"]]
	    , ["a\\*?/*", ["a*b/ooo"]]
	    , ["*\\\\!*", [], {null: true}, ["echo !7"]]
	    , ["*\\!*", ["echo !7"], null, ["echo !7"]]
	    , ["*.\\*", ["r.*"], null, ["r.*"]]
	    , ["a[b]c", ["abc"]]
	    , ["a[\\b]c", ["abc"]]
	    , ["a?c", ["abc"]]
	    , ["a\\*c", [], {null: true}, ["abc"]]
	    , ["", [""], { null: true }, [""]]

	    , "http://www.opensource.apple.com/source/bash/bash-23/" +
	      "bash/tests/glob-test"
	    , function () { files.push("man/", "man/man1/", "man/man1/bash.1") }
	    , ["*/man*/bash.*", ["man/man1/bash.1"]]
	    , ["man/man1/bash.1", ["man/man1/bash.1"]]
	    , ["a***c", ["abc"], null, ["abc"]]
	    , ["a*****?c", ["abc"], null, ["abc"]]
	    , ["?*****??", ["abc"], null, ["abc"]]
	    , ["*****??", ["abc"], null, ["abc"]]
	    , ["?*****?c", ["abc"], null, ["abc"]]
	    , ["?***?****c", ["abc"], null, ["abc"]]
	    , ["?***?****?", ["abc"], null, ["abc"]]
	    , ["?***?****", ["abc"], null, ["abc"]]
	    , ["*******c", ["abc"], null, ["abc"]]
	    , ["*******?", ["abc"], null, ["abc"]]
	    , ["a*cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??k***", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??***k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??***k**", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a****c**?**??*****", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["[-abc]", ["-"], null, ["-"]]
	    , ["[abc-]", ["-"], null, ["-"]]
	    , ["\\", ["\\"], null, ["\\"]]
	    , ["[\\\\]", ["\\"], null, ["\\"]]
	    , ["[[]", ["["], null, ["["]]
	    , ["[", ["["], null, ["["]]
	    , ["[*", ["[abc"], null, ["[abc"]]
	    , "a right bracket shall lose its special meaning and\n" +
	      "represent itself in a bracket expression if it occurs\n" +
	      "first in the list.  -- POSIX.2 2.8.3.2"
	    , ["[]]", ["]"], null, ["]"]]
	    , ["[]-]", ["]"], null, ["]"]]
	    , ["[a-\z]", ["p"], null, ["p"]]
	    , ["??**********?****?", [], { null: true }, ["abc"]]
	    , ["??**********?****c", [], { null: true }, ["abc"]]
	    , ["?************c****?****", [], { null: true }, ["abc"]]
	    , ["*c*?**", [], { null: true }, ["abc"]]
	    , ["a*****c*?**", [], { null: true }, ["abc"]]
	    , ["a********???*******", [], { null: true }, ["abc"]]
	    , ["[]", [], { null: true }, ["a"]]
	    , ["[abc", [], { null: true }, ["["]]

	    , "nocase tests"
	    , ["XYZ", ["xYz"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]
	    , ["ab*", ["ABC"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]
	    , ["[ia]?[ck]", ["ABC", "IjK"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]

	    // [ pattern, [matches], MM opts, files, TAP opts]
	    , "onestar/twostar"
	    , ["{/*,*}", [], {null: true}, ["/asdf/asdf/asdf"]]
	    , ["{/?,*}", ["/a", "bb"], {null: true}
	      , ["/a", "/b/b", "/a/b/c", "bb"]]

	    , "dots should not match unless requested"
	    , ["**", ["a/b"], {}, ["a/b", "a/.d", ".a/.d"]]

	    // .. and . can only match patterns starting with .,
	    // even when options.dot is set.
	    , function () {
	        files = ["a/./b", "a/../b", "a/c/b", "a/.d/b"]
	      }
	    , ["a/*/b", ["a/c/b", "a/.d/b"], {dot: true}]
	    , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: true}]
	    , ["a/*/b", ["a/c/b"], {dot:false}]
	    , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: false}]


	    // this also tests that changing the options needs
	    // to change the cache key, even if the pattern is
	    // the same!
	    , ["**", ["a/b","a/.d",".a/.d"], { dot: true }
	      , [ ".a/.d", "a/.d", "a/b"]]

	    , "paren sets cannot contain slashes"
	    , ["*(a/b)", ["*(a/b)"], {nonull: true}, ["a/b"]]

	    // brace sets trump all else.
	    //
	    // invalid glob pattern.  fails on bash4 and bsdglob.
	    // however, in this implementation, it's easier just
	    // to do the intuitive thing, and let brace-expansion
	    // actually come before parsing any extglob patterns,
	    // like the documentation seems to say.
	    //
	    // XXX: if anyone complains about this, either fix it
	    // or tell them to grow up and stop complaining.
	    //
	    // bash/bsdglob says this:
	    // , ["*(a|{b),c)}", ["*(a|{b),c)}"], {}, ["a", "ab", "ac", "ad"]]
	    // but we do this instead:
	    , ["*(a|{b),c)}", ["a", "ab", "ac"], {}, ["a", "ab", "ac", "ad"]]

	    // test partial parsing in the presence of comment/negation chars
	    , ["[!a*", ["[!ab"], {}, ["[!ab", "[ab"]]
	    , ["[#a*", ["[#ab"], {}, ["[#ab", "[ab"]]

	    // like: {a,b|c\\,d\\\|e} except it's unclosed, so it has to be escaped.
	    , ["+(a|*\\|c\\\\|d\\\\\\|e\\\\\\\\|f\\\\\\\\\\|g"
	      , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g"]
	      , {}
	      , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g", "a", "b\\c"]]


	    // crazy nested {,,} and *(||) tests.
	    , function () {
	        files = [ "a", "b", "c", "d"
	                , "ab", "ac", "ad"
	                , "bc", "cb"
	                , "bc,d", "c,db", "c,d"
	                , "d)", "(b|c", "*(b|c"
	                , "b|c", "b|cc", "cb|c"
	                , "x(a|b|c)", "x(a|c)"
	                , "(a|b|c)", "(a|c)"]
	      }
	    , ["*(a|{b,c})", ["a", "b", "c", "ab", "ac"]]
	    , ["{a,*(b|c,d)}", ["a","(b|c", "*(b|c", "d)"]]
	    // a
	    // *(b|c)
	    // *(b|d)
	    , ["{a,*(b|{c,d})}", ["a","b", "bc", "cb", "c", "d"]]
	    , ["*(a|{b|c,c})", ["a", "b", "c", "ab", "ac", "bc", "cb"]]


	    // test various flag settings.
	    , [ "*(a|{b|c,c})", ["x(a|b|c)", "x(a|c)", "(a|b|c)", "(a|c)"]
	      , { noext: true } ]
	    , ["a?b", ["x/y/acb", "acb/"], {matchBase: true}
	      , ["x/y/acb", "acb/", "acb/d/e", "x/y/acb/d"] ]
	    , ["#*", ["#a", "#b"], {nocomment: true}, ["#a", "#b", "c#d"]]


	    // begin channelling Boole and deMorgan...
	    , "negation tests"
	    , function () {
	        files = ["d", "e", "!ab", "!abc", "a!b", "\\!a"]
	      }

	    // anything that is NOT a* matches.
	    , ["!a*", ["\\!a", "d", "e", "!ab", "!abc"]]

	    // anything that IS !a* matches.
	    , ["!a*", ["!ab", "!abc"], {nonegate: true}]

	    // anything that IS a* matches
	    , ["!!a*", ["a!b"]]

	    // anything that is NOT !a* matches
	    , ["!\\!a*", ["a!b", "d", "e", "\\!a"]]

	    // negation nestled within a pattern
	    , function () {
	        files = [ "foo.js"
	                , "foo.bar"
	                // can't match this one without negative lookbehind.
	                , "foo.js.js"
	                , "blar.js"
	                , "foo."
	                , "boo.js.boo" ]
	      }
	    , ["*.!(js)", ["foo.bar", "foo.", "boo.js.boo"] ]

	    ].forEach(function (c) {
	      if (typeof c === "function") return c()
	      if (typeof c === "string") return t.comment(c)

	      var pattern = c[0]
	        , expect = c[1].sort(alpha)
	        , options = c[2] || {}
	        , f = c[3] || files
	        , tapOpts = c[4] || {}

	      // options.debug = true
	      var Class = mm.defaults(options).Minimatch
	      var m = new Class(pattern, {})
	      var r = m.makeRe()
	      tapOpts.re = String(r) || JSON.stringify(r)
	      tapOpts.files = JSON.stringify(f)
	      tapOpts.pattern = pattern
	      tapOpts.set = m.set
	      tapOpts.negated = m.negate

	      var actual = mm.match(f, pattern, options)
	      actual.sort(alpha)

	      t.equivalent( actual, expect
	                  , JSON.stringify(pattern) + " " + JSON.stringify(expect)
	                  , tapOpts )
	    })

	  t.comment("time=" + (Date.now() - start) + "ms")
	  t.end()
	})

	tap.test("global leak test", function (t) {
	  var globalAfter = Object.keys(global)
	  t.equivalent(globalAfter, globalBefore, "no new globals, please")
	  t.end()
	})

	function alpha (a, b) {
	  return a > b ? 1 : -1
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var minimatch = __webpack_require__(50)

	test('extglob ending with statechar', function(t) {
	  t.notOk(minimatch('ax', 'a?(b*)'))
	  t.ok(minimatch('ax', '?(a*|b)'))
	  t.end()
	})


/***/ },
/* 60 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var argv = process.argv;

	module.exports = (function () {
		if (argv.indexOf('--no-color') !== -1 ||
			argv.indexOf('--no-colors') !== -1 ||
			argv.indexOf('--color=false') !== -1) {
			return false;
		}

		if (argv.indexOf('--color') !== -1 ||
			argv.indexOf('--colors') !== -1 ||
			argv.indexOf('--color=true') !== -1 ||
			argv.indexOf('--color=always') !== -1) {
			return true;
		}

		if (process.stdout && !process.stdout.isTTY) {
			return false;
		}

		if (process.platform === 'win32') {
			return true;
		}

		if ('COLORTERM' in process.env) {
			return true;
		}

		if (process.env.TERM === 'dumb') {
			return false;
		}

		if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
			return true;
		}

		return false;
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var inherits = __webpack_require__(36).inherits;
	var color = Base.color;

	/**
	 * Expose `Dot`.
	 */

	exports = module.exports = Dot;

	/**
	 * Initialize a new `Dot` matrix test reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function Dot(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var width = Base.window.width * .75 | 0;
	  var n = -1;

	  runner.on('start', function() {
	    process.stdout.write('\n');
	  });

	  runner.on('pending', function() {
	    if (++n % width === 0) {
	      process.stdout.write('\n  ');
	    }
	    process.stdout.write(color('pending', Base.symbols.dot));
	  });

	  runner.on('pass', function(test) {
	    if (++n % width === 0) {
	      process.stdout.write('\n  ');
	    }
	    if (test.speed === 'slow') {
	      process.stdout.write(color('bright yellow', Base.symbols.dot));
	    } else {
	      process.stdout.write(color(test.speed, Base.symbols.dot));
	    }
	  });

	  runner.on('fail', function() {
	    if (++n % width === 0) {
	      process.stdout.write('\n  ');
	    }
	    process.stdout.write(color('fail', Base.symbols.dot));
	  });

	  runner.on('end', function() {
	    console.log();
	    self.epilogue();
	  });
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(Dot, Base);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var utils = __webpack_require__(36);

	/**
	 * Expose `Doc`.
	 */

	exports = module.exports = Doc;

	/**
	 * Initialize a new `Doc` reporter.
	 *
	 * @param {Runner} runner
	 * @api public
	 */
	function Doc(runner) {
	  Base.call(this, runner);

	  var indents = 2;

	  function indent() {
	    return Array(indents).join('  ');
	  }

	  runner.on('suite', function(suite) {
	    if (suite.root) {
	      return;
	    }
	    ++indents;
	    console.log('%s<section class="suite">', indent());
	    ++indents;
	    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));
	    console.log('%s<dl>', indent());
	  });

	  runner.on('suite end', function(suite) {
	    if (suite.root) {
	      return;
	    }
	    console.log('%s</dl>', indent());
	    --indents;
	    console.log('%s</section>', indent());
	    --indents;
	  });

	  runner.on('pass', function(test) {
	    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));
	    var code = utils.escape(utils.clean(test.body));
	    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);
	  });

	  runner.on('fail', function(test, err) {
	    console.log('%s  <dt class="error">%s</dt>', indent(), utils.escape(test.title));
	    var code = utils.escape(utils.clean(test.fn.body));
	    console.log('%s  <dd class="error"><pre><code>%s</code></pre></dd>', indent(), code);
	    console.log('%s  <dd class="error">%s</dd>', indent(), utils.escape(err));
	  });
	}


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);

	/**
	 * Expose `TAP`.
	 */

	exports = module.exports = TAP;

	/**
	 * Initialize a new `TAP` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function TAP(runner) {
	  Base.call(this, runner);

	  var n = 1;
	  var passes = 0;
	  var failures = 0;

	  runner.on('start', function() {
	    var total = runner.grepTotal(runner.suite);
	    console.log('%d..%d', 1, total);
	  });

	  runner.on('test end', function() {
	    ++n;
	  });

	  runner.on('pending', function(test) {
	    console.log('ok %d %s # SKIP -', n, title(test));
	  });

	  runner.on('pass', function(test) {
	    passes++;
	    console.log('ok %d %s', n, title(test));
	  });

	  runner.on('fail', function(test, err) {
	    failures++;
	    console.log('not ok %d %s', n, title(test));
	    if (err.stack) {
	      console.log(err.stack.replace(/^/gm, '  '));
	    }
	  });

	  runner.on('end', function() {
	    console.log('# tests ' + (passes + failures));
	    console.log('# pass ' + passes);
	    console.log('# fail ' + failures);
	  });
	}

	/**
	 * Return a TAP-safe title of `test`
	 *
	 * @api private
	 * @param {Object} test
	 * @return {String}
	 */
	function title(test) {
	  return test.fullTitle().replace(/#/g, '');
	}


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);

	/**
	 * Expose `JSON`.
	 */

	exports = module.exports = JSONReporter;

	/**
	 * Initialize a new `JSON` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function JSONReporter(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var tests = [];
	  var pending = [];
	  var failures = [];
	  var passes = [];

	  runner.on('test end', function(test) {
	    tests.push(test);
	  });

	  runner.on('pass', function(test) {
	    passes.push(test);
	  });

	  runner.on('fail', function(test) {
	    failures.push(test);
	  });

	  runner.on('pending', function(test) {
	    pending.push(test);
	  });

	  runner.on('end', function() {
	    var obj = {
	      stats: self.stats,
	      tests: tests.map(clean),
	      pending: pending.map(clean),
	      failures: failures.map(clean),
	      passes: passes.map(clean)
	    };

	    runner.testResults = obj;

	    process.stdout.write(JSON.stringify(obj, null, 2));
	  });
	}

	/**
	 * Return a plain-object representation of `test`
	 * free of cyclic properties etc.
	 *
	 * @api private
	 * @param {Object} test
	 * @return {Object}
	 */
	function clean(test) {
	  return {
	    title: test.title,
	    fullTitle: test.fullTitle(),
	    duration: test.duration,
	    currentRetry: test.currentRetry(),
	    err: errorJSON(test.err || {})
	  };
	}

	/**
	 * Transform `error` into a JSON object.
	 *
	 * @api private
	 * @param {Error} err
	 * @return {Object}
	 */
	function errorJSON(err) {
	  var res = {};
	  Object.getOwnPropertyNames(err).forEach(function(key) {
	    res[key] = err[key];
	  }, err);
	  return res;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* eslint-env browser */

	/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var utils = __webpack_require__(36);
	var Progress = __webpack_require__(67);
	var escapeRe = __webpack_require__(29);
	var escape = utils.escape;

	/**
	 * Save timer references to avoid Sinon interfering (see GH-237).
	 */

	/* eslint-disable no-unused-vars, no-native-reassign */
	var Date = global.Date;
	var setTimeout = global.setTimeout;
	var setInterval = global.setInterval;
	var clearTimeout = global.clearTimeout;
	var clearInterval = global.clearInterval;
	/* eslint-enable no-unused-vars, no-native-reassign */

	/**
	 * Expose `HTML`.
	 */

	exports = module.exports = HTML;

	/**
	 * Stats template.
	 */

	var statsTemplate = '<ul id="mocha-stats">'
	  + '<li class="progress"><canvas width="40" height="40"></canvas></li>'
	  + '<li class="passes"><a href="javascript:void(0);">passes:</a> <em>0</em></li>'
	  + '<li class="failures"><a href="javascript:void(0);">failures:</a> <em>0</em></li>'
	  + '<li class="duration">duration: <em>0</em>s</li>'
	  + '</ul>';

	/**
	 * Initialize a new `HTML` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function HTML(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var stats = this.stats;
	  var stat = fragment(statsTemplate);
	  var items = stat.getElementsByTagName('li');
	  var passes = items[1].getElementsByTagName('em')[0];
	  var passesLink = items[1].getElementsByTagName('a')[0];
	  var failures = items[2].getElementsByTagName('em')[0];
	  var failuresLink = items[2].getElementsByTagName('a')[0];
	  var duration = items[3].getElementsByTagName('em')[0];
	  var canvas = stat.getElementsByTagName('canvas')[0];
	  var report = fragment('<ul id="mocha-report"></ul>');
	  var stack = [report];
	  var progress;
	  var ctx;
	  var root = document.getElementById('mocha');

	  if (canvas.getContext) {
	    var ratio = window.devicePixelRatio || 1;
	    canvas.style.width = canvas.width;
	    canvas.style.height = canvas.height;
	    canvas.width *= ratio;
	    canvas.height *= ratio;
	    ctx = canvas.getContext('2d');
	    ctx.scale(ratio, ratio);
	    progress = new Progress();
	  }

	  if (!root) {
	    return error('#mocha div missing, add it to your document');
	  }

	  // pass toggle
	  on(passesLink, 'click', function() {
	    unhide();
	    var name = (/pass/).test(report.className) ? '' : ' pass';
	    report.className = report.className.replace(/fail|pass/g, '') + name;
	    if (report.className.trim()) {
	      hideSuitesWithout('test pass');
	    }
	  });

	  // failure toggle
	  on(failuresLink, 'click', function() {
	    unhide();
	    var name = (/fail/).test(report.className) ? '' : ' fail';
	    report.className = report.className.replace(/fail|pass/g, '') + name;
	    if (report.className.trim()) {
	      hideSuitesWithout('test fail');
	    }
	  });

	  root.appendChild(stat);
	  root.appendChild(report);

	  if (progress) {
	    progress.size(40);
	  }

	  runner.on('suite', function(suite) {
	    if (suite.root) {
	      return;
	    }

	    // suite
	    var url = self.suiteURL(suite);
	    var el = fragment('<li class="suite"><h1><a href="%s">%s</a></h1></li>', url, escape(suite.title));

	    // container
	    stack[0].appendChild(el);
	    stack.unshift(document.createElement('ul'));
	    el.appendChild(stack[0]);
	  });

	  runner.on('suite end', function(suite) {
	    if (suite.root) {
	      return;
	    }
	    stack.shift();
	  });

	  runner.on('fail', function(test) {
	    // For type = 'test' its possible that the test failed due to multiple
	    // done() calls. So report the issue here.
	    if (test.type === 'hook'
	      || test.type === 'test') {
	      runner.emit('test end', test);
	    }
	  });

	  runner.on('test end', function(test) {
	    // TODO: add to stats
	    var percent = stats.tests / this.total * 100 | 0;
	    if (progress) {
	      progress.update(percent).draw(ctx);
	    }

	    // update stats
	    var ms = new Date() - stats.start;
	    text(passes, stats.passes);
	    text(failures, stats.failures);
	    text(duration, (ms / 1000).toFixed(2));

	    // test
	    var el;
	    if (test.state === 'passed') {
	      var url = self.testURL(test);
	      el = fragment('<li class="test pass %e"><h2>%e<span class="duration">%ems</span> <a href="%s" class="replay"></a></h2></li>', test.speed, test.title, test.duration, url);
	    } else if (test.pending) {
	      el = fragment('<li class="test pass pending"><h2>%e</h2></li>', test.title);
	    } else {
	      el = fragment('<li class="test fail"><h2>%e <a href="%e" class="replay"></a></h2></li>', test.title, self.testURL(test));
	      var stackString; // Note: Includes leading newline
	      var message = test.err.toString();

	      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we
	      // check for the result of the stringifying.
	      if (message === '[object Error]') {
	        message = test.err.message;
	      }

	      if (test.err.stack) {
	        var indexOfMessage = test.err.stack.indexOf(test.err.message);
	        if (indexOfMessage === -1) {
	          stackString = test.err.stack;
	        } else {
	          stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);
	        }
	      } else if (test.err.sourceURL && test.err.line !== undefined) {
	        // Safari doesn't give you a stack. Let's at least provide a source line.
	        stackString = '\n(' + test.err.sourceURL + ':' + test.err.line + ')';
	      }

	      stackString = stackString || '';

	      if (test.err.htmlMessage && stackString) {
	        el.appendChild(fragment('<div class="html-error">%s\n<pre class="error">%e</pre></div>', test.err.htmlMessage, stackString));
	      } else if (test.err.htmlMessage) {
	        el.appendChild(fragment('<div class="html-error">%s</div>', test.err.htmlMessage));
	      } else {
	        el.appendChild(fragment('<pre class="error">%e%e</pre>', message, stackString));
	      }
	    }

	    // toggle code
	    // TODO: defer
	    if (!test.pending) {
	      var h2 = el.getElementsByTagName('h2')[0];

	      on(h2, 'click', function() {
	        pre.style.display = pre.style.display === 'none' ? 'block' : 'none';
	      });

	      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.body));
	      el.appendChild(pre);
	      pre.style.display = 'none';
	    }

	    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.
	    if (stack[0]) {
	      stack[0].appendChild(el);
	    }
	  });
	}

	/**
	 * Makes a URL, preserving querystring ("search") parameters.
	 *
	 * @param {string} s
	 * @return {string} A new URL.
	 */
	function makeUrl(s) {
	  var search = window.location.search;

	  // Remove previous grep query parameter if present
	  if (search) {
	    search = search.replace(/[?&]grep=[^&\s]*/g, '').replace(/^&/, '?');
	  }

	  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));
	}

	/**
	 * Provide suite URL.
	 *
	 * @param {Object} [suite]
	 */
	HTML.prototype.suiteURL = function(suite) {
	  return makeUrl(suite.fullTitle());
	};

	/**
	 * Provide test URL.
	 *
	 * @param {Object} [test]
	 */
	HTML.prototype.testURL = function(test) {
	  return makeUrl(test.fullTitle());
	};

	/**
	 * Display error `msg`.
	 *
	 * @param {string} msg
	 */
	function error(msg) {
	  document.body.appendChild(fragment('<div id="mocha-error">%s</div>', msg));
	}

	/**
	 * Return a DOM fragment from `html`.
	 *
	 * @param {string} html
	 */
	function fragment(html) {
	  var args = arguments;
	  var div = document.createElement('div');
	  var i = 1;

	  div.innerHTML = html.replace(/%([se])/g, function(_, type) {
	    switch (type) {
	      case 's': return String(args[i++]);
	      case 'e': return escape(args[i++]);
	      // no default
	    }
	  });

	  return div.firstChild;
	}

	/**
	 * Check for suites that do not have elements
	 * with `classname`, and hide them.
	 *
	 * @param {text} classname
	 */
	function hideSuitesWithout(classname) {
	  var suites = document.getElementsByClassName('suite');
	  for (var i = 0; i < suites.length; i++) {
	    var els = suites[i].getElementsByClassName(classname);
	    if (!els.length) {
	      suites[i].className += ' hidden';
	    }
	  }
	}

	/**
	 * Unhide .hidden suites.
	 */
	function unhide() {
	  var els = document.getElementsByClassName('suite hidden');
	  for (var i = 0; i < els.length; ++i) {
	    els[i].className = els[i].className.replace('suite hidden', 'suite');
	  }
	}

	/**
	 * Set an element's text contents.
	 *
	 * @param {HTMLElement} el
	 * @param {string} contents
	 */
	function text(el, contents) {
	  if (el.textContent) {
	    el.textContent = contents;
	  } else {
	    el.innerText = contents;
	  }
	}

	/**
	 * Listen on `event` with callback `fn`.
	 */
	function on(el, event, fn) {
	  if (el.addEventListener) {
	    el.addEventListener(event, fn, false);
	  } else {
	    el.attachEvent('on' + event, fn);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 67 */
/***/ function(module, exports) {

	/**
	 * Expose `Progress`.
	 */

	module.exports = Progress;

	/**
	 * Initialize a new `Progress` indicator.
	 */
	function Progress() {
	  this.percent = 0;
	  this.size(0);
	  this.fontSize(11);
	  this.font('helvetica, arial, sans-serif');
	}

	/**
	 * Set progress size to `size`.
	 *
	 * @api public
	 * @param {number} size
	 * @return {Progress} Progress instance.
	 */
	Progress.prototype.size = function(size) {
	  this._size = size;
	  return this;
	};

	/**
	 * Set text to `text`.
	 *
	 * @api public
	 * @param {string} text
	 * @return {Progress} Progress instance.
	 */
	Progress.prototype.text = function(text) {
	  this._text = text;
	  return this;
	};

	/**
	 * Set font size to `size`.
	 *
	 * @api public
	 * @param {number} size
	 * @return {Progress} Progress instance.
	 */
	Progress.prototype.fontSize = function(size) {
	  this._fontSize = size;
	  return this;
	};

	/**
	 * Set font to `family`.
	 *
	 * @param {string} family
	 * @return {Progress} Progress instance.
	 */
	Progress.prototype.font = function(family) {
	  this._font = family;
	  return this;
	};

	/**
	 * Update percentage to `n`.
	 *
	 * @param {number} n
	 * @return {Progress} Progress instance.
	 */
	Progress.prototype.update = function(n) {
	  this.percent = n;
	  return this;
	};

	/**
	 * Draw on `ctx`.
	 *
	 * @param {CanvasRenderingContext2d} ctx
	 * @return {Progress} Progress instance.
	 */
	Progress.prototype.draw = function(ctx) {
	  try {
	    var percent = Math.min(this.percent, 100);
	    var size = this._size;
	    var half = size / 2;
	    var x = half;
	    var y = half;
	    var rad = half - 1;
	    var fontSize = this._fontSize;

	    ctx.font = fontSize + 'px ' + this._font;

	    var angle = Math.PI * 2 * (percent / 100);
	    ctx.clearRect(0, 0, size, size);

	    // outer circle
	    ctx.strokeStyle = '#9f9f9f';
	    ctx.beginPath();
	    ctx.arc(x, y, rad, 0, angle, false);
	    ctx.stroke();

	    // inner circle
	    ctx.strokeStyle = '#eee';
	    ctx.beginPath();
	    ctx.arc(x, y, rad - 1, 0, angle, true);
	    ctx.stroke();

	    // text
	    var text = this._text || (percent | 0) + '%';
	    var w = ctx.measureText(text).width;

	    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);
	  } catch (err) {
	    // don't fail if we can't render progress
	  }
	  return this;
	};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var inherits = __webpack_require__(36).inherits;
	var color = Base.color;
	var cursor = Base.cursor;

	/**
	 * Expose `List`.
	 */

	exports = module.exports = List;

	/**
	 * Initialize a new `List` test reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function List(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var n = 0;

	  runner.on('start', function() {
	    console.log();
	  });

	  runner.on('test', function(test) {
	    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));
	  });

	  runner.on('pending', function(test) {
	    var fmt = color('checkmark', '  -')
	      + color('pending', ' %s');
	    console.log(fmt, test.fullTitle());
	  });

	  runner.on('pass', function(test) {
	    var fmt = color('checkmark', '  ' + Base.symbols.dot)
	      + color('pass', ' %s: ')
	      + color(test.speed, '%dms');
	    cursor.CR();
	    console.log(fmt, test.fullTitle(), test.duration);
	  });

	  runner.on('fail', function(test) {
	    cursor.CR();
	    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());
	  });

	  runner.on('end', self.epilogue.bind(self));
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(List, Base);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var inherits = __webpack_require__(36).inherits;

	/**
	 * Expose `Min`.
	 */

	exports = module.exports = Min;

	/**
	 * Initialize a new `Min` minimal test reporter (best used with --watch).
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function Min(runner) {
	  Base.call(this, runner);

	  runner.on('start', function() {
	    // clear screen
	    process.stdout.write('\u001b[2J');
	    // set cursor position
	    process.stdout.write('\u001b[1;3H');
	  });

	  runner.on('end', this.epilogue.bind(this));
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(Min, Base);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var inherits = __webpack_require__(36).inherits;
	var color = Base.color;
	var cursor = Base.cursor;

	/**
	 * Expose `Spec`.
	 */

	exports = module.exports = Spec;

	/**
	 * Initialize a new `Spec` test reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function Spec(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var indents = 0;
	  var n = 0;

	  function indent() {
	    return Array(indents).join('  ');
	  }

	  runner.on('start', function() {
	    console.log();
	  });

	  runner.on('suite', function(suite) {
	    ++indents;
	    console.log(color('suite', '%s%s'), indent(), suite.title);
	  });

	  runner.on('suite end', function() {
	    --indents;
	    if (indents === 1) {
	      console.log();
	    }
	  });

	  runner.on('pending', function(test) {
	    var fmt = indent() + color('pending', '  - %s');
	    console.log(fmt, test.title);
	  });

	  runner.on('pass', function(test) {
	    var fmt;
	    if (test.speed === 'fast') {
	      fmt = indent()
	        + color('checkmark', '  ' + Base.symbols.ok)
	        + color('pass', ' %s');
	      cursor.CR();
	      console.log(fmt, test.title);
	    } else {
	      fmt = indent()
	        + color('checkmark', '  ' + Base.symbols.ok)
	        + color('pass', ' %s')
	        + color(test.speed, ' (%dms)');
	      cursor.CR();
	      console.log(fmt, test.title, test.duration);
	    }
	  });

	  runner.on('fail', function(test) {
	    cursor.CR();
	    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);
	  });

	  runner.on('end', self.epilogue.bind(self));
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(Spec, Base);


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var inherits = __webpack_require__(36).inherits;

	/**
	 * Expose `Dot`.
	 */

	exports = module.exports = NyanCat;

	/**
	 * Initialize a new `Dot` matrix test reporter.
	 *
	 * @param {Runner} runner
	 * @api public
	 */

	function NyanCat(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var width = Base.window.width * .75 | 0;
	  var nyanCatWidth = this.nyanCatWidth = 11;

	  this.colorIndex = 0;
	  this.numberOfLines = 4;
	  this.rainbowColors = self.generateColors();
	  this.scoreboardWidth = 5;
	  this.tick = 0;
	  this.trajectories = [[], [], [], []];
	  this.trajectoryWidthMax = (width - nyanCatWidth);

	  runner.on('start', function() {
	    Base.cursor.hide();
	    self.draw();
	  });

	  runner.on('pending', function() {
	    self.draw();
	  });

	  runner.on('pass', function() {
	    self.draw();
	  });

	  runner.on('fail', function() {
	    self.draw();
	  });

	  runner.on('end', function() {
	    Base.cursor.show();
	    for (var i = 0; i < self.numberOfLines; i++) {
	      write('\n');
	    }
	    self.epilogue();
	  });
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(NyanCat, Base);

	/**
	 * Draw the nyan cat
	 *
	 * @api private
	 */

	NyanCat.prototype.draw = function() {
	  this.appendRainbow();
	  this.drawScoreboard();
	  this.drawRainbow();
	  this.drawNyanCat();
	  this.tick = !this.tick;
	};

	/**
	 * Draw the "scoreboard" showing the number
	 * of passes, failures and pending tests.
	 *
	 * @api private
	 */

	NyanCat.prototype.drawScoreboard = function() {
	  var stats = this.stats;

	  function draw(type, n) {
	    write(' ');
	    write(Base.color(type, n));
	    write('\n');
	  }

	  draw('green', stats.passes);
	  draw('fail', stats.failures);
	  draw('pending', stats.pending);
	  write('\n');

	  this.cursorUp(this.numberOfLines);
	};

	/**
	 * Append the rainbow.
	 *
	 * @api private
	 */

	NyanCat.prototype.appendRainbow = function() {
	  var segment = this.tick ? '_' : '-';
	  var rainbowified = this.rainbowify(segment);

	  for (var index = 0; index < this.numberOfLines; index++) {
	    var trajectory = this.trajectories[index];
	    if (trajectory.length >= this.trajectoryWidthMax) {
	      trajectory.shift();
	    }
	    trajectory.push(rainbowified);
	  }
	};

	/**
	 * Draw the rainbow.
	 *
	 * @api private
	 */

	NyanCat.prototype.drawRainbow = function() {
	  var self = this;

	  this.trajectories.forEach(function(line) {
	    write('\u001b[' + self.scoreboardWidth + 'C');
	    write(line.join(''));
	    write('\n');
	  });

	  this.cursorUp(this.numberOfLines);
	};

	/**
	 * Draw the nyan cat
	 *
	 * @api private
	 */
	NyanCat.prototype.drawNyanCat = function() {
	  var self = this;
	  var startWidth = this.scoreboardWidth + this.trajectories[0].length;
	  var dist = '\u001b[' + startWidth + 'C';
	  var padding = '';

	  write(dist);
	  write('_,------,');
	  write('\n');

	  write(dist);
	  padding = self.tick ? '  ' : '   ';
	  write('_|' + padding + '/\\_/\\ ');
	  write('\n');

	  write(dist);
	  padding = self.tick ? '_' : '__';
	  var tail = self.tick ? '~' : '^';
	  write(tail + '|' + padding + this.face() + ' ');
	  write('\n');

	  write(dist);
	  padding = self.tick ? ' ' : '  ';
	  write(padding + '""  "" ');
	  write('\n');

	  this.cursorUp(this.numberOfLines);
	};

	/**
	 * Draw nyan cat face.
	 *
	 * @api private
	 * @return {string}
	 */

	NyanCat.prototype.face = function() {
	  var stats = this.stats;
	  if (stats.failures) {
	    return '( x .x)';
	  } else if (stats.pending) {
	    return '( o .o)';
	  } else if (stats.passes) {
	    return '( ^ .^)';
	  }
	  return '( - .-)';
	};

	/**
	 * Move cursor up `n`.
	 *
	 * @api private
	 * @param {number} n
	 */

	NyanCat.prototype.cursorUp = function(n) {
	  write('\u001b[' + n + 'A');
	};

	/**
	 * Move cursor down `n`.
	 *
	 * @api private
	 * @param {number} n
	 */

	NyanCat.prototype.cursorDown = function(n) {
	  write('\u001b[' + n + 'B');
	};

	/**
	 * Generate rainbow colors.
	 *
	 * @api private
	 * @return {Array}
	 */
	NyanCat.prototype.generateColors = function() {
	  var colors = [];

	  for (var i = 0; i < (6 * 7); i++) {
	    var pi3 = Math.floor(Math.PI / 3);
	    var n = (i * (1.0 / 6));
	    var r = Math.floor(3 * Math.sin(n) + 3);
	    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);
	    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);
	    colors.push(36 * r + 6 * g + b + 16);
	  }

	  return colors;
	};

	/**
	 * Apply rainbow to the given `str`.
	 *
	 * @api private
	 * @param {string} str
	 * @return {string}
	 */
	NyanCat.prototype.rainbowify = function(str) {
	  if (!Base.useColors) {
	    return str;
	  }
	  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];
	  this.colorIndex += 1;
	  return '\u001b[38;5;' + color + 'm' + str + '\u001b[0m';
	};

	/**
	 * Stdout helper.
	 *
	 * @param {string} string A message to write to stdout.
	 */
	function write(string) {
	  process.stdout.write(string);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var utils = __webpack_require__(36);
	var inherits = utils.inherits;
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var escape = utils.escape;
	var mkdirp = __webpack_require__(73);
	var path = __webpack_require__(30);

	/**
	 * Save timer references to avoid Sinon interfering (see GH-237).
	 */

	/* eslint-disable no-unused-vars, no-native-reassign */
	var Date = global.Date;
	var setTimeout = global.setTimeout;
	var setInterval = global.setInterval;
	var clearTimeout = global.clearTimeout;
	var clearInterval = global.clearInterval;
	/* eslint-enable no-unused-vars, no-native-reassign */

	/**
	 * Expose `XUnit`.
	 */

	exports = module.exports = XUnit;

	/**
	 * Initialize a new `XUnit` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function XUnit(runner, options) {
	  Base.call(this, runner);

	  var stats = this.stats;
	  var tests = [];
	  var self = this;

	  if (options.reporterOptions && options.reporterOptions.output) {
	    if (!fs.createWriteStream) {
	      throw new Error('file output not supported in browser');
	    }
	    mkdirp.sync(path.dirname(options.reporterOptions.output));
	    self.fileStream = fs.createWriteStream(options.reporterOptions.output);
	  }

	  runner.on('pending', function(test) {
	    tests.push(test);
	  });

	  runner.on('pass', function(test) {
	    tests.push(test);
	  });

	  runner.on('fail', function(test) {
	    tests.push(test);
	  });

	  runner.on('end', function() {
	    self.write(tag('testsuite', {
	      name: 'Mocha Tests',
	      tests: stats.tests,
	      failures: stats.failures,
	      errors: stats.failures,
	      skipped: stats.tests - stats.failures - stats.passes,
	      timestamp: (new Date()).toUTCString(),
	      time: (stats.duration / 1000) || 0
	    }, false));

	    tests.forEach(function(t) {
	      self.test(t);
	    });

	    self.write('</testsuite>');
	  });
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(XUnit, Base);

	/**
	 * Override done to close the stream (if it's a file).
	 *
	 * @param failures
	 * @param {Function} fn
	 */
	XUnit.prototype.done = function(failures, fn) {
	  if (this.fileStream) {
	    this.fileStream.end(function() {
	      fn(failures);
	    });
	  } else {
	    fn(failures);
	  }
	};

	/**
	 * Write out the given line.
	 *
	 * @param {string} line
	 */
	XUnit.prototype.write = function(line) {
	  if (this.fileStream) {
	    this.fileStream.write(line + '\n');
	  } else if (typeof process === 'object' && process.stdout) {
	    process.stdout.write(line + '\n');
	  } else {
	    console.log(line);
	  }
	};

	/**
	 * Output tag for the given `test.`
	 *
	 * @param {Test} test
	 */
	XUnit.prototype.test = function(test) {
	  var attrs = {
	    classname: test.parent.fullTitle(),
	    name: test.title,
	    time: (test.duration / 1000) || 0
	  };

	  if (test.state === 'failed') {
	    var err = test.err;
	    this.write(tag('testcase', attrs, false, tag('failure', {}, false, cdata(escape(err.message) + '\n' + err.stack))));
	  } else if (test.pending) {
	    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));
	  } else {
	    this.write(tag('testcase', attrs, true));
	  }
	};

	/**
	 * HTML tag helper.
	 *
	 * @param name
	 * @param attrs
	 * @param close
	 * @param content
	 * @return {string}
	 */
	function tag(name, attrs, close, content) {
	  var end = close ? '/>' : '>';
	  var pairs = [];
	  var tag;

	  for (var key in attrs) {
	    if (Object.prototype.hasOwnProperty.call(attrs, key)) {
	      pairs.push(key + '="' + escape(attrs[key]) + '"');
	    }
	  }

	  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;
	  if (content) {
	    tag += content + '</' + name + end;
	  }
	  return tag;
	}

	/**
	 * Return cdata escaped CDATA `str`.
	 */

	function cdata(str) {
	  return '<![CDATA[' + escape(str) + ']]>';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(26)))

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(30);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var _0777 = parseInt('0777', 8);

	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}

	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;

	    p = path.resolve(p);

	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }

	    return made;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var utils = __webpack_require__(36);

	/**
	 * Constants
	 */

	var SUITE_PREFIX = '$';

	/**
	 * Expose `Markdown`.
	 */

	exports = module.exports = Markdown;

	/**
	 * Initialize a new `Markdown` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function Markdown(runner) {
	  Base.call(this, runner);

	  var level = 0;
	  var buf = '';

	  function title(str) {
	    return Array(level).join('#') + ' ' + str;
	  }

	  function mapTOC(suite, obj) {
	    var ret = obj;
	    var key = SUITE_PREFIX + suite.title;

	    obj = obj[key] = obj[key] || { suite: suite };
	    suite.suites.forEach(function(suite) {
	      mapTOC(suite, obj);
	    });

	    return ret;
	  }

	  function stringifyTOC(obj, level) {
	    ++level;
	    var buf = '';
	    var link;
	    for (var key in obj) {
	      if (key === 'suite') {
	        continue;
	      }
	      if (key !== SUITE_PREFIX) {
	        link = ' - [' + key.substring(1) + ']';
	        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\n';
	        buf += Array(level).join('  ') + link;
	      }
	      buf += stringifyTOC(obj[key], level);
	    }
	    return buf;
	  }

	  function generateTOC(suite) {
	    var obj = mapTOC(suite, {});
	    return stringifyTOC(obj, 0);
	  }

	  generateTOC(runner.suite);

	  runner.on('suite', function(suite) {
	    ++level;
	    var slug = utils.slug(suite.fullTitle());
	    buf += '<a name="' + slug + '"></a>' + '\n';
	    buf += title(suite.title) + '\n';
	  });

	  runner.on('suite end', function() {
	    --level;
	  });

	  runner.on('pass', function(test) {
	    var code = utils.clean(test.body);
	    buf += test.title + '.\n';
	    buf += '\n```js\n';
	    buf += code + '\n';
	    buf += '```\n\n';
	  });

	  runner.on('end', function() {
	    process.stdout.write('# TOC\n');
	    process.stdout.write(generateTOC(runner.suite));
	    process.stdout.write(buf);
	  });
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var inherits = __webpack_require__(36).inherits;
	var color = Base.color;
	var cursor = Base.cursor;

	/**
	 * Expose `Progress`.
	 */

	exports = module.exports = Progress;

	/**
	 * General progress bar color.
	 */

	Base.colors.progress = 90;

	/**
	 * Initialize a new `Progress` bar test reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 * @param {Object} options
	 */
	function Progress(runner, options) {
	  Base.call(this, runner);

	  var self = this;
	  var width = Base.window.width * .50 | 0;
	  var total = runner.total;
	  var complete = 0;
	  var lastN = -1;

	  // default chars
	  options = options || {};
	  options.open = options.open || '[';
	  options.complete = options.complete || '';
	  options.incomplete = options.incomplete || Base.symbols.dot;
	  options.close = options.close || ']';
	  options.verbose = false;

	  // tests started
	  runner.on('start', function() {
	    console.log();
	    cursor.hide();
	  });

	  // tests complete
	  runner.on('test end', function() {
	    complete++;

	    var percent = complete / total;
	    var n = width * percent | 0;
	    var i = width - n;

	    if (n === lastN && !options.verbose) {
	      // Don't re-render the line if it hasn't changed
	      return;
	    }
	    lastN = n;

	    cursor.CR();
	    process.stdout.write('\u001b[J');
	    process.stdout.write(color('progress', '  ' + options.open));
	    process.stdout.write(Array(n).join(options.complete));
	    process.stdout.write(Array(i).join(options.incomplete));
	    process.stdout.write(color('progress', options.close));
	    if (options.verbose) {
	      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));
	    }
	  });

	  // tests are complete, output some stats
	  // and the failures if any
	  runner.on('end', function() {
	    cursor.show();
	    console.log();
	    self.epilogue();
	  });
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(Progress, Base);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);
	var inherits = __webpack_require__(36).inherits;
	var cursor = Base.cursor;
	var color = Base.color;

	/**
	 * Expose `Landing`.
	 */

	exports = module.exports = Landing;

	/**
	 * Airplane color.
	 */

	Base.colors.plane = 0;

	/**
	 * Airplane crash color.
	 */

	Base.colors['plane crash'] = 31;

	/**
	 * Runway color.
	 */

	Base.colors.runway = 90;

	/**
	 * Initialize a new `Landing` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function Landing(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var width = Base.window.width * .75 | 0;
	  var total = runner.total;
	  var stream = process.stdout;
	  var plane = color('plane', '');
	  var crashed = -1;
	  var n = 0;

	  function runway() {
	    var buf = Array(width).join('-');
	    return '  ' + color('runway', buf);
	  }

	  runner.on('start', function() {
	    stream.write('\n\n\n  ');
	    cursor.hide();
	  });

	  runner.on('test end', function(test) {
	    // check if the plane crashed
	    var col = crashed === -1 ? width * ++n / total | 0 : crashed;

	    // show the crash
	    if (test.state === 'failed') {
	      plane = color('plane crash', '');
	      crashed = col;
	    }

	    // render landing strip
	    stream.write('\u001b[' + (width + 1) + 'D\u001b[2A');
	    stream.write(runway());
	    stream.write('\n  ');
	    stream.write(color('runway', Array(col).join('')));
	    stream.write(plane);
	    stream.write(color('runway', Array(width - col).join('') + '\n'));
	    stream.write(runway());
	    stream.write('\u001b[0m');
	  });

	  runner.on('end', function() {
	    cursor.show();
	    console.log();
	    self.epilogue();
	  });
	}

	/**
	 * Inherit from `Base.prototype`.
	 */
	inherits(Landing, Base);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);

	/**
	 * Expose `JSONCov`.
	 */

	exports = module.exports = JSONCov;

	/**
	 * Initialize a new `JsCoverage` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 * @param {boolean} output
	 */
	function JSONCov(runner, output) {
	  Base.call(this, runner);

	  output = arguments.length === 1 || output;
	  var self = this;
	  var tests = [];
	  var failures = [];
	  var passes = [];

	  runner.on('test end', function(test) {
	    tests.push(test);
	  });

	  runner.on('pass', function(test) {
	    passes.push(test);
	  });

	  runner.on('fail', function(test) {
	    failures.push(test);
	  });

	  runner.on('end', function() {
	    var cov = global._$jscoverage || {};
	    var result = self.cov = map(cov);
	    result.stats = self.stats;
	    result.tests = tests.map(clean);
	    result.failures = failures.map(clean);
	    result.passes = passes.map(clean);
	    if (!output) {
	      return;
	    }
	    process.stdout.write(JSON.stringify(result, null, 2));
	  });
	}

	/**
	 * Map jscoverage data to a JSON structure
	 * suitable for reporting.
	 *
	 * @api private
	 * @param {Object} cov
	 * @return {Object}
	 */

	function map(cov) {
	  var ret = {
	    instrumentation: 'node-jscoverage',
	    sloc: 0,
	    hits: 0,
	    misses: 0,
	    coverage: 0,
	    files: []
	  };

	  for (var filename in cov) {
	    if (Object.prototype.hasOwnProperty.call(cov, filename)) {
	      var data = coverage(filename, cov[filename]);
	      ret.files.push(data);
	      ret.hits += data.hits;
	      ret.misses += data.misses;
	      ret.sloc += data.sloc;
	    }
	  }

	  ret.files.sort(function(a, b) {
	    return a.filename.localeCompare(b.filename);
	  });

	  if (ret.sloc > 0) {
	    ret.coverage = (ret.hits / ret.sloc) * 100;
	  }

	  return ret;
	}

	/**
	 * Map jscoverage data for a single source file
	 * to a JSON structure suitable for reporting.
	 *
	 * @api private
	 * @param {string} filename name of the source file
	 * @param {Object} data jscoverage coverage data
	 * @return {Object}
	 */
	function coverage(filename, data) {
	  var ret = {
	    filename: filename,
	    coverage: 0,
	    hits: 0,
	    misses: 0,
	    sloc: 0,
	    source: {}
	  };

	  data.source.forEach(function(line, num) {
	    num++;

	    if (data[num] === 0) {
	      ret.misses++;
	      ret.sloc++;
	    } else if (data[num] !== undefined) {
	      ret.hits++;
	      ret.sloc++;
	    }

	    ret.source[num] = {
	      source: line,
	      coverage: data[num] === undefined ? '' : data[num]
	    };
	  });

	  ret.coverage = ret.hits / ret.sloc * 100;

	  return ret;
	}

	/**
	 * Return a plain-object representation of `test`
	 * free of cyclic properties etc.
	 *
	 * @api private
	 * @param {Object} test
	 * @return {Object}
	 */
	function clean(test) {
	  return {
	    duration: test.duration,
	    currentRetry: test.currentRetry(),
	    fullTitle: test.fullTitle(),
	    title: test.title
	  };
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(26)))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, process) {/**
	 * Module dependencies.
	 */

	var JSONCov = __webpack_require__(77);
	var readFileSync = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFileSync;
	var join = __webpack_require__(30).join;

	/**
	 * Expose `HTMLCov`.
	 */

	exports = module.exports = HTMLCov;

	/**
	 * Initialize a new `JsCoverage` reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function HTMLCov(runner) {
	  var jade = __webpack_require__(79);
	  var file = join(__dirname, '/templates/coverage.jade');
	  var str = readFileSync(file, 'utf8');
	  var fn = jade.compile(str, { filename: file });
	  var self = this;

	  JSONCov.call(this, runner, false);

	  runner.on('end', function() {
	    process.stdout.write(fn({
	      cov: self.cov,
	      coverageClass: coverageClass
	    }));
	  });
	}

	/**
	 * Return coverage class for a given coverage percentage.
	 *
	 * @api private
	 * @param {number} coveragePctg
	 * @return {string}
	 */
	function coverageClass(coveragePctg) {
	  if (coveragePctg >= 75) {
	    return 'high';
	  }
	  if (coveragePctg >= 50) {
	    return 'medium';
	  }
	  if (coveragePctg >= 25) {
	    return 'low';
	  }
	  return 'terrible';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(26)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	module.exports = process.env.JADE_COV
	  ? __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./lib-cov/jade\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  : __webpack_require__(80);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Jade
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Parser = __webpack_require__(81)
	  , Lexer = __webpack_require__(82)
	  , Compiler = __webpack_require__(99)
	  , runtime = __webpack_require__(105)
	// if node
	  , fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	// end

	/**
	 * Library version.
	 */

	exports.version = '0.26.3';

	/**
	 * Expose self closing tags.
	 */

	exports.selfClosing = __webpack_require__(104);

	/**
	 * Default supported doctypes.
	 */

	exports.doctypes = __webpack_require__(103);

	/**
	 * Text filters.
	 */

	exports.filters = __webpack_require__(100);

	/**
	 * Utilities.
	 */

	exports.utils = __webpack_require__(106);

	/**
	 * Expose `Compiler`.
	 */

	exports.Compiler = Compiler;

	/**
	 * Expose `Parser`.
	 */

	exports.Parser = Parser;

	/**
	 * Expose `Lexer`.
	 */

	exports.Lexer = Lexer;

	/**
	 * Nodes.
	 */

	exports.nodes = __webpack_require__(83);

	/**
	 * Jade runtime helpers.
	 */

	exports.runtime = runtime;

	/**
	 * Template function cache.
	 */

	exports.cache = {};

	/**
	 * Parse the given `str` of jade and return a function body.
	 *
	 * @param {String} str
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function parse(str, options){
	  try {
	    // Parse
	    var parser = new Parser(str, options.filename, options);

	    // Compile
	    var compiler = new (options.compiler || Compiler)(parser.parse(), options)
	      , js = compiler.compile();

	    // Debug compiler
	    if (options.debug) {
	      console.error('\nCompiled Function:\n\n\033[90m%s\033[0m', js.replace(/^/gm, '  '));
	    }

	    return ''
	      + 'var buf = [];\n'
	      + (options.self
	        ? 'var self = locals || {};\n' + js
	        : 'with (locals || {}) {\n' + js + '\n}\n')
	      + 'return buf.join("");';
	  } catch (err) {
	    parser = parser.context();
	    runtime.rethrow(err, parser.filename, parser.lexer.lineno);
	  }
	}

	/**
	 * Compile a `Function` representation of the given jade `str`.
	 *
	 * Options:
	 *
	 *   - `compileDebug` when `false` debugging code is stripped from the compiled template
	 *   - `client` when `true` the helper functions `escape()` etc will reference `jade.escape()`
	 *      for use with the Jade client-side runtime.js
	 *
	 * @param {String} str
	 * @param {Options} options
	 * @return {Function}
	 * @api public
	 */

	exports.compile = function(str, options){
	  var options = options || {}
	    , client = options.client
	    , filename = options.filename
	      ? JSON.stringify(options.filename)
	      : 'undefined'
	    , fn;

	  if (options.compileDebug !== false) {
	    fn = [
	        'var __jade = [{ lineno: 1, filename: ' + filename + ' }];'
	      , 'try {'
	      , parse(String(str), options)
	      , '} catch (err) {'
	      , '  rethrow(err, __jade[0].filename, __jade[0].lineno);'
	      , '}'
	    ].join('\n');
	  } else {
	    fn = parse(String(str), options);
	  }

	  if (client) {
	    fn = 'attrs = attrs || jade.attrs; escape = escape || jade.escape; rethrow = rethrow || jade.rethrow; merge = merge || jade.merge;\n' + fn;
	  }

	  fn = new Function('locals, attrs, escape, rethrow, merge', fn);

	  if (client) return fn;

	  return function(locals){
	    return fn(locals, runtime.attrs, runtime.escape, runtime.rethrow, runtime.merge);
	  };
	};

	/**
	 * Render the given `str` of jade and invoke
	 * the callback `fn(err, str)`.
	 *
	 * Options:
	 *
	 *   - `cache` enable template caching
	 *   - `filename` filename required for `include` / `extends` and caching
	 *
	 * @param {String} str
	 * @param {Object|Function} options or fn
	 * @param {Function} fn
	 * @api public
	 */

	exports.render = function(str, options, fn){
	  // swap args
	  if ('function' == typeof options) {
	    fn = options, options = {};
	  }

	  // cache requires .filename
	  if (options.cache && !options.filename) {
	    return fn(new Error('the "filename" option is required for caching'));
	  }

	  try {
	    var path = options.filename;
	    var tmpl = options.cache
	      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))
	      : exports.compile(str, options);
	    fn(null, tmpl(options));
	  } catch (err) {
	    fn(err);
	  }
	};

	/**
	 * Render a Jade file at the given `path` and callback `fn(err, str)`.
	 *
	 * @param {String} path
	 * @param {Object|Function} options or callback
	 * @param {Function} fn
	 * @api public
	 */

	exports.renderFile = function(path, options, fn){
	  var key = path + ':string';

	  if ('function' == typeof options) {
	    fn = options, options = {};
	  }

	  try {
	    options.filename = path;
	    var str = options.cache
	      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
	      : fs.readFileSync(path, 'utf8');
	    exports.render(str, options, fn);
	  } catch (err) {
	    fn(err);
	  }
	};

	/**
	 * Express support.
	 */

	exports.__express = exports.renderFile;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - Parser
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Lexer = __webpack_require__(82)
	  , nodes = __webpack_require__(83);

	/**
	 * Initialize `Parser` with the given input `str` and `filename`.
	 *
	 * @param {String} str
	 * @param {String} filename
	 * @param {Object} options
	 * @api public
	 */

	var Parser = exports = module.exports = function Parser(str, filename, options){
	  this.input = str;
	  this.lexer = new Lexer(str, options);
	  this.filename = filename;
	  this.blocks = {};
	  this.mixins = {};
	  this.options = options;
	  this.contexts = [this];
	};

	/**
	 * Tags that may not contain tags.
	 */

	var textOnly = exports.textOnly = ['script', 'style'];

	/**
	 * Parser prototype.
	 */

	Parser.prototype = {

	  /**
	   * Push `parser` onto the context stack,
	   * or pop and return a `Parser`.
	   */

	  context: function(parser){
	    if (parser) {
	      this.contexts.push(parser);
	    } else {
	      return this.contexts.pop();
	    }
	  },

	  /**
	   * Return the next token object.
	   *
	   * @return {Object}
	   * @api private
	   */

	  advance: function(){
	    return this.lexer.advance();
	  },

	  /**
	   * Skip `n` tokens.
	   *
	   * @param {Number} n
	   * @api private
	   */

	  skip: function(n){
	    while (n--) this.advance();
	  },
	  
	  /**
	   * Single token lookahead.
	   *
	   * @return {Object}
	   * @api private
	   */
	  
	  peek: function() {
	    return this.lookahead(1);
	  },
	  
	  /**
	   * Return lexer lineno.
	   *
	   * @return {Number}
	   * @api private
	   */
	  
	  line: function() {
	    return this.lexer.lineno;
	  },
	  
	  /**
	   * `n` token lookahead.
	   *
	   * @param {Number} n
	   * @return {Object}
	   * @api private
	   */
	  
	  lookahead: function(n){
	    return this.lexer.lookahead(n);
	  },
	  
	  /**
	   * Parse input returning a string of js for evaluation.
	   *
	   * @return {String}
	   * @api public
	   */
	  
	  parse: function(){
	    var block = new nodes.Block, parser;
	    block.line = this.line();

	    while ('eos' != this.peek().type) {
	      if ('newline' == this.peek().type) {
	        this.advance();
	      } else {
	        block.push(this.parseExpr());
	      }
	    }

	    if (parser = this.extending) {
	      this.context(parser);
	      var ast = parser.parse();
	      this.context();
	      // hoist mixins
	      for (var name in this.mixins)
	        ast.unshift(this.mixins[name]);
	      return ast;
	    }

	    return block;
	  },
	  
	  /**
	   * Expect the given type, or throw an exception.
	   *
	   * @param {String} type
	   * @api private
	   */
	  
	  expect: function(type){
	    if (this.peek().type === type) {
	      return this.advance();
	    } else {
	      throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
	    }
	  },
	  
	  /**
	   * Accept the given `type`.
	   *
	   * @param {String} type
	   * @api private
	   */
	  
	  accept: function(type){
	    if (this.peek().type === type) {
	      return this.advance();
	    }
	  },
	  
	  /**
	   *   tag
	   * | doctype
	   * | mixin
	   * | include
	   * | filter
	   * | comment
	   * | text
	   * | each
	   * | code
	   * | yield
	   * | id
	   * | class
	   * | interpolation
	   */
	  
	  parseExpr: function(){
	    switch (this.peek().type) {
	      case 'tag':
	        return this.parseTag();
	      case 'mixin':
	        return this.parseMixin();
	      case 'block':
	        return this.parseBlock();
	      case 'case':
	        return this.parseCase();
	      case 'when':
	        return this.parseWhen();
	      case 'default':
	        return this.parseDefault();
	      case 'extends':
	        return this.parseExtends();
	      case 'include':
	        return this.parseInclude();
	      case 'doctype':
	        return this.parseDoctype();
	      case 'filter':
	        return this.parseFilter();
	      case 'comment':
	        return this.parseComment();
	      case 'text':
	        return this.parseText();
	      case 'each':
	        return this.parseEach();
	      case 'code':
	        return this.parseCode();
	      case 'call':
	        return this.parseCall();
	      case 'interpolation':
	        return this.parseInterpolation();
	      case 'yield':
	        this.advance();
	        var block = new nodes.Block;
	        block.yield = true;
	        return block;
	      case 'id':
	      case 'class':
	        var tok = this.advance();
	        this.lexer.defer(this.lexer.tok('tag', 'div'));
	        this.lexer.defer(tok);
	        return this.parseExpr();
	      default:
	        throw new Error('unexpected token "' + this.peek().type + '"');
	    }
	  },
	  
	  /**
	   * Text
	   */
	  
	  parseText: function(){
	    var tok = this.expect('text')
	      , node = new nodes.Text(tok.val);
	    node.line = this.line();
	    return node;
	  },

	  /**
	   *   ':' expr
	   * | block
	   */

	  parseBlockExpansion: function(){
	    if (':' == this.peek().type) {
	      this.advance();
	      return new nodes.Block(this.parseExpr());
	    } else {
	      return this.block();
	    }
	  },

	  /**
	   * case
	   */

	  parseCase: function(){
	    var val = this.expect('case').val
	      , node = new nodes.Case(val);
	    node.line = this.line();
	    node.block = this.block();
	    return node;
	  },

	  /**
	   * when
	   */

	  parseWhen: function(){
	    var val = this.expect('when').val
	    return new nodes.Case.When(val, this.parseBlockExpansion());
	  },
	  
	  /**
	   * default
	   */

	  parseDefault: function(){
	    this.expect('default');
	    return new nodes.Case.When('default', this.parseBlockExpansion());
	  },

	  /**
	   * code
	   */
	  
	  parseCode: function(){
	    var tok = this.expect('code')
	      , node = new nodes.Code(tok.val, tok.buffer, tok.escape)
	      , block
	      , i = 1;
	    node.line = this.line();
	    while (this.lookahead(i) && 'newline' == this.lookahead(i).type) ++i;
	    block = 'indent' == this.lookahead(i).type;
	    if (block) {
	      this.skip(i-1);
	      node.block = this.block();
	    }
	    return node;
	  },
	  
	  /**
	   * comment
	   */
	  
	  parseComment: function(){
	    var tok = this.expect('comment')
	      , node;

	    if ('indent' == this.peek().type) {
	      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);
	    } else {
	      node = new nodes.Comment(tok.val, tok.buffer);
	    }

	    node.line = this.line();
	    return node;
	  },
	  
	  /**
	   * doctype
	   */
	  
	  parseDoctype: function(){
	    var tok = this.expect('doctype')
	      , node = new nodes.Doctype(tok.val);
	    node.line = this.line();
	    return node;
	  },
	  
	  /**
	   * filter attrs? text-block
	   */
	  
	  parseFilter: function(){
	    var block
	      , tok = this.expect('filter')
	      , attrs = this.accept('attrs');

	    this.lexer.pipeless = true;
	    block = this.parseTextBlock();
	    this.lexer.pipeless = false;

	    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);
	    node.line = this.line();
	    return node;
	  },
	  
	  /**
	   * tag ':' attrs? block
	   */
	  
	  parseASTFilter: function(){
	    var block
	      , tok = this.expect('tag')
	      , attrs = this.accept('attrs');

	    this.expect(':');
	    block = this.block();

	    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);
	    node.line = this.line();
	    return node;
	  },
	  
	  /**
	   * each block
	   */
	  
	  parseEach: function(){
	    var tok = this.expect('each')
	      , node = new nodes.Each(tok.code, tok.val, tok.key);
	    node.line = this.line();
	    node.block = this.block();
	    return node;
	  },

	  /**
	   * 'extends' name
	   */

	  parseExtends: function(){
	    var path = __webpack_require__(30)
	      , fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	      , dirname = path.dirname
	      , basename = path.basename
	      , join = path.join;

	    if (!this.filename)
	      throw new Error('the "filename" option is required to extend templates');

	    var path = this.expect('extends').val.trim()
	      , dir = dirname(this.filename);

	    var path = join(dir, path + '.jade')
	      , str = fs.readFileSync(path, 'utf8')
	      , parser = new Parser(str, path, this.options);

	    parser.blocks = this.blocks;
	    parser.contexts = this.contexts;
	    this.extending = parser;

	    // TODO: null node
	    return new nodes.Literal('');
	  },

	  /**
	   * 'block' name block
	   */

	  parseBlock: function(){
	    var block = this.expect('block')
	      , mode = block.mode
	      , name = block.val.trim();

	    block = 'indent' == this.peek().type
	      ? this.block()
	      : new nodes.Block(new nodes.Literal(''));

	    var prev = this.blocks[name];

	    if (prev) {
	      switch (prev.mode) {
	        case 'append':
	          block.nodes = block.nodes.concat(prev.nodes);
	          prev = block;
	          break;
	        case 'prepend':
	          block.nodes = prev.nodes.concat(block.nodes);
	          prev = block;
	          break;
	      }
	    }

	    block.mode = mode;
	    return this.blocks[name] = prev || block;
	  },

	  /**
	   * include block?
	   */

	  parseInclude: function(){
	    var path = __webpack_require__(30)
	      , fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	      , dirname = path.dirname
	      , basename = path.basename
	      , join = path.join;

	    var path = this.expect('include').val.trim()
	      , dir = dirname(this.filename);

	    if (!this.filename)
	      throw new Error('the "filename" option is required to use includes');

	    // no extension
	    if (!~basename(path).indexOf('.')) {
	      path += '.jade';
	    }

	    // non-jade
	    if ('.jade' != path.substr(-5)) {
	      var path = join(dir, path)
	        , str = fs.readFileSync(path, 'utf8');
	      return new nodes.Literal(str);
	    }

	    var path = join(dir, path)
	      , str = fs.readFileSync(path, 'utf8')
	     , parser = new Parser(str, path, this.options);
	    parser.blocks = this.blocks;
	    parser.mixins = this.mixins;

	    this.context(parser);
	    var ast = parser.parse();
	    this.context();
	    ast.filename = path;

	    if ('indent' == this.peek().type) {
	      ast.includeBlock().push(this.block());
	    }

	    return ast;
	  },

	  /**
	   * call ident block
	   */

	  parseCall: function(){
	    var tok = this.expect('call')
	      , name = tok.val
	      , args = tok.args
	      , mixin = new nodes.Mixin(name, args, new nodes.Block, true);

	    this.tag(mixin);
	    if (mixin.block.isEmpty()) mixin.block = null;
	    return mixin;
	  },

	  /**
	   * mixin block
	   */

	  parseMixin: function(){
	    var tok = this.expect('mixin')
	      , name = tok.val
	      , args = tok.args
	      , mixin;

	    // definition
	    if ('indent' == this.peek().type) {
	      mixin = new nodes.Mixin(name, args, this.block(), false);
	      this.mixins[name] = mixin;
	      return mixin;
	    // call
	    } else {
	      return new nodes.Mixin(name, args, null, true);
	    }
	  },

	  /**
	   * indent (text | newline)* outdent
	   */

	  parseTextBlock: function(){
	    var block = new nodes.Block;
	    block.line = this.line();
	    var spaces = this.expect('indent').val;
	    if (null == this._spaces) this._spaces = spaces;
	    var indent = Array(spaces - this._spaces + 1).join(' ');
	    while ('outdent' != this.peek().type) {
	      switch (this.peek().type) {
	        case 'newline':
	          this.advance();
	          break;
	        case 'indent':
	          this.parseTextBlock().nodes.forEach(function(node){
	            block.push(node);
	          });
	          break;
	        default:
	          var text = new nodes.Text(indent + this.advance().val);
	          text.line = this.line();
	          block.push(text);
	      }
	    }

	    if (spaces == this._spaces) this._spaces = null;
	    this.expect('outdent');
	    return block;
	  },

	  /**
	   * indent expr* outdent
	   */
	  
	  block: function(){
	    var block = new nodes.Block;
	    block.line = this.line();
	    this.expect('indent');
	    while ('outdent' != this.peek().type) {
	      if ('newline' == this.peek().type) {
	        this.advance();
	      } else {
	        block.push(this.parseExpr());
	      }
	    }
	    this.expect('outdent');
	    return block;
	  },

	  /**
	   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
	   */
	  
	  parseInterpolation: function(){
	    var tok = this.advance();
	    var tag = new nodes.Tag(tok.val);
	    tag.buffer = true;
	    return this.tag(tag);
	  },

	  /**
	   * tag (attrs | class | id)* (text | code | ':')? newline* block?
	   */
	  
	  parseTag: function(){
	    // ast-filter look-ahead
	    var i = 2;
	    if ('attrs' == this.lookahead(i).type) ++i;
	    if (':' == this.lookahead(i).type) {
	      if ('indent' == this.lookahead(++i).type) {
	        return this.parseASTFilter();
	      }
	    }

	    var tok = this.advance()
	      , tag = new nodes.Tag(tok.val);

	    tag.selfClosing = tok.selfClosing;

	    return this.tag(tag);
	  },

	  /**
	   * Parse tag.
	   */

	  tag: function(tag){
	    var dot;

	    tag.line = this.line();

	    // (attrs | class | id)*
	    out:
	      while (true) {
	        switch (this.peek().type) {
	          case 'id':
	          case 'class':
	            var tok = this.advance();
	            tag.setAttribute(tok.type, "'" + tok.val + "'");
	            continue;
	          case 'attrs':
	            var tok = this.advance()
	              , obj = tok.attrs
	              , escaped = tok.escaped
	              , names = Object.keys(obj);

	            if (tok.selfClosing) tag.selfClosing = true;

	            for (var i = 0, len = names.length; i < len; ++i) {
	              var name = names[i]
	                , val = obj[name];
	              tag.setAttribute(name, val, escaped[name]);
	            }
	            continue;
	          default:
	            break out;
	        }
	      }

	    // check immediate '.'
	    if ('.' == this.peek().val) {
	      dot = tag.textOnly = true;
	      this.advance();
	    }

	    // (text | code | ':')?
	    switch (this.peek().type) {
	      case 'text':
	        tag.block.push(this.parseText());
	        break;
	      case 'code':
	        tag.code = this.parseCode();
	        break;
	      case ':':
	        this.advance();
	        tag.block = new nodes.Block;
	        tag.block.push(this.parseExpr());
	        break;
	    }

	    // newline*
	    while ('newline' == this.peek().type) this.advance();

	    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);

	    // script special-case
	    if ('script' == tag.name) {
	      var type = tag.getAttribute('type');
	      if (!dot && type && 'text/javascript' != type.replace(/^['"]|['"]$/g, '')) {
	        tag.textOnly = false;
	      }
	    }

	    // block?
	    if ('indent' == this.peek().type) {
	      if (tag.textOnly) {
	        this.lexer.pipeless = true;
	        tag.block = this.parseTextBlock();
	        this.lexer.pipeless = false;
	      } else {
	        var block = this.block();
	        if (tag.block) {
	          for (var i = 0, len = block.nodes.length; i < len; ++i) {
	            tag.block.push(block.nodes[i]);
	          }
	        } else {
	          tag.block = block;
	        }
	      }
	    }
	    
	    return tag;
	  }
	};


/***/ },
/* 82 */
/***/ function(module, exports) {

	
	/*!
	 * Jade - Lexer
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Initialize `Lexer` with the given `str`.
	 *
	 * Options:
	 *
	 *   - `colons` allow colons for attr delimiters
	 *
	 * @param {String} str
	 * @param {Object} options
	 * @api private
	 */

	var Lexer = module.exports = function Lexer(str, options) {
	  options = options || {};
	  this.input = str.replace(/\r\n|\r/g, '\n');
	  this.colons = options.colons;
	  this.deferredTokens = [];
	  this.lastIndents = 0;
	  this.lineno = 1;
	  this.stash = [];
	  this.indentStack = [];
	  this.indentRe = null;
	  this.pipeless = false;
	};

	/**
	 * Lexer prototype.
	 */

	Lexer.prototype = {
	  
	  /**
	   * Construct a token with the given `type` and `val`.
	   *
	   * @param {String} type
	   * @param {String} val
	   * @return {Object}
	   * @api private
	   */
	  
	  tok: function(type, val){
	    return {
	        type: type
	      , line: this.lineno
	      , val: val
	    }
	  },
	  
	  /**
	   * Consume the given `len` of input.
	   *
	   * @param {Number} len
	   * @api private
	   */
	  
	  consume: function(len){
	    this.input = this.input.substr(len);
	  },
	  
	  /**
	   * Scan for `type` with the given `regexp`.
	   *
	   * @param {String} type
	   * @param {RegExp} regexp
	   * @return {Object}
	   * @api private
	   */
	  
	  scan: function(regexp, type){
	    var captures;
	    if (captures = regexp.exec(this.input)) {
	      this.consume(captures[0].length);
	      return this.tok(type, captures[1]);
	    }
	  },
	  
	  /**
	   * Defer the given `tok`.
	   *
	   * @param {Object} tok
	   * @api private
	   */
	  
	  defer: function(tok){
	    this.deferredTokens.push(tok);
	  },
	  
	  /**
	   * Lookahead `n` tokens.
	   *
	   * @param {Number} n
	   * @return {Object}
	   * @api private
	   */
	  
	  lookahead: function(n){
	    var fetch = n - this.stash.length;
	    while (fetch-- > 0) this.stash.push(this.next());
	    return this.stash[--n];
	  },
	  
	  /**
	   * Return the indexOf `start` / `end` delimiters.
	   *
	   * @param {String} start
	   * @param {String} end
	   * @return {Number}
	   * @api private
	   */
	  
	  indexOfDelimiters: function(start, end){
	    var str = this.input
	      , nstart = 0
	      , nend = 0
	      , pos = 0;
	    for (var i = 0, len = str.length; i < len; ++i) {
	      if (start == str.charAt(i)) {
	        ++nstart;
	      } else if (end == str.charAt(i)) {
	        if (++nend == nstart) {
	          pos = i;
	          break;
	        }
	      }
	    }
	    return pos;
	  },
	  
	  /**
	   * Stashed token.
	   */
	  
	  stashed: function() {
	    return this.stash.length
	      && this.stash.shift();
	  },
	  
	  /**
	   * Deferred token.
	   */
	  
	  deferred: function() {
	    return this.deferredTokens.length 
	      && this.deferredTokens.shift();
	  },
	  
	  /**
	   * end-of-source.
	   */
	  
	  eos: function() {
	    if (this.input.length) return;
	    if (this.indentStack.length) {
	      this.indentStack.shift();
	      return this.tok('outdent');
	    } else {
	      return this.tok('eos');
	    }
	  },

	  /**
	   * Blank line.
	   */
	  
	  blank: function() {
	    var captures;
	    if (captures = /^\n *\n/.exec(this.input)) {
	      this.consume(captures[0].length - 1);
	      if (this.pipeless) return this.tok('text', '');
	      return this.next();
	    }
	  },

	  /**
	   * Comment.
	   */
	  
	  comment: function() {
	    var captures;
	    if (captures = /^ *\/\/(-)?([^\n]*)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok = this.tok('comment', captures[2]);
	      tok.buffer = '-' != captures[1];
	      return tok;
	    }
	  },

	  /**
	   * Interpolated tag.
	   */

	  interpolation: function() {
	    var captures;
	    if (captures = /^#\{(.*?)\}/.exec(this.input)) {
	      this.consume(captures[0].length);
	      return this.tok('interpolation', captures[1]);
	    }
	  },

	  /**
	   * Tag.
	   */
	  
	  tag: function() {
	    var captures;
	    if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok, name = captures[1];
	      if (':' == name[name.length - 1]) {
	        name = name.slice(0, -1);
	        tok = this.tok('tag', name);
	        this.defer(this.tok(':'));
	        while (' ' == this.input[0]) this.input = this.input.substr(1);
	      } else {
	        tok = this.tok('tag', name);
	      }
	      tok.selfClosing = !! captures[2];
	      return tok;
	    }
	  },
	  
	  /**
	   * Filter.
	   */
	  
	  filter: function() {
	    return this.scan(/^:(\w+)/, 'filter');
	  },
	  
	  /**
	   * Doctype.
	   */
	  
	  doctype: function() {
	    return this.scan(/^(?:!!!|doctype) *([^\n]+)?/, 'doctype');
	  },

	  /**
	   * Id.
	   */
	  
	  id: function() {
	    return this.scan(/^#([\w-]+)/, 'id');
	  },
	  
	  /**
	   * Class.
	   */
	  
	  className: function() {
	    return this.scan(/^\.([\w-]+)/, 'class');
	  },
	  
	  /**
	   * Text.
	   */
	  
	  text: function() {
	    return this.scan(/^(?:\| ?| ?)?([^\n]+)/, 'text');
	  },

	  /**
	   * Extends.
	   */
	  
	  "extends": function() {
	    return this.scan(/^extends? +([^\n]+)/, 'extends');
	  },

	  /**
	   * Block prepend.
	   */
	  
	  prepend: function() {
	    var captures;
	    if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var mode = 'prepend'
	        , name = captures[1]
	        , tok = this.tok('block', name);
	      tok.mode = mode;
	      return tok;
	    }
	  },
	  
	  /**
	   * Block append.
	   */
	  
	  append: function() {
	    var captures;
	    if (captures = /^append +([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var mode = 'append'
	        , name = captures[1]
	        , tok = this.tok('block', name);
	      tok.mode = mode;
	      return tok;
	    }
	  },

	  /**
	   * Block.
	   */
	  
	  block: function() {
	    var captures;
	    if (captures = /^block\b *(?:(prepend|append) +)?([^\n]*)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var mode = captures[1] || 'replace'
	        , name = captures[2]
	        , tok = this.tok('block', name);

	      tok.mode = mode;
	      return tok;
	    }
	  },

	  /**
	   * Yield.
	   */
	  
	  yield: function() {
	    return this.scan(/^yield */, 'yield');
	  },

	  /**
	   * Include.
	   */
	  
	  include: function() {
	    return this.scan(/^include +([^\n]+)/, 'include');
	  },

	  /**
	   * Case.
	   */
	  
	  "case": function() {
	    return this.scan(/^case +([^\n]+)/, 'case');
	  },

	  /**
	   * When.
	   */
	  
	  when: function() {
	    return this.scan(/^when +([^:\n]+)/, 'when');
	  },

	  /**
	   * Default.
	   */
	  
	  "default": function() {
	    return this.scan(/^default */, 'default');
	  },

	  /**
	   * Assignment.
	   */
	  
	  assignment: function() {
	    var captures;
	    if (captures = /^(\w+) += *([^;\n]+)( *;? *)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var name = captures[1]
	        , val = captures[2];
	      return this.tok('code', 'var ' + name + ' = (' + val + ');');
	    }
	  },

	  /**
	   * Call mixin.
	   */
	  
	  call: function(){
	    var captures;
	    if (captures = /^\+([-\w]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok = this.tok('call', captures[1]);
	      
	      // Check for args (not attributes)
	      if (captures = /^ *\((.*?)\)/.exec(this.input)) {
	        if (!/^ *[-\w]+ *=/.test(captures[1])) {
	          this.consume(captures[0].length);
	          tok.args = captures[1];
	        }
	      }
	      
	      return tok;
	    }
	  },

	  /**
	   * Mixin.
	   */

	  mixin: function(){
	    var captures;
	    if (captures = /^mixin +([-\w]+)(?: *\((.*)\))?/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok = this.tok('mixin', captures[1]);
	      tok.args = captures[2];
	      return tok;
	    }
	  },

	  /**
	   * Conditional.
	   */
	  
	  conditional: function() {
	    var captures;
	    if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var type = captures[1]
	        , js = captures[2];

	      switch (type) {
	        case 'if': js = 'if (' + js + ')'; break;
	        case 'unless': js = 'if (!(' + js + '))'; break;
	        case 'else if': js = 'else if (' + js + ')'; break;
	        case 'else': js = 'else'; break;
	      }

	      return this.tok('code', js);
	    }
	  },

	  /**
	   * While.
	   */
	  
	  "while": function() {
	    var captures;
	    if (captures = /^while +([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      return this.tok('code', 'while (' + captures[1] + ')');
	    }
	  },

	  /**
	   * Each.
	   */
	  
	  each: function() {
	    var captures;
	    if (captures = /^(?:- *)?(?:each|for) +(\w+)(?: *, *(\w+))? * in *([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var tok = this.tok('each', captures[1]);
	      tok.key = captures[2] || '$index';
	      tok.code = captures[3];
	      return tok;
	    }
	  },
	  
	  /**
	   * Code.
	   */
	  
	  code: function() {
	    var captures;
	    if (captures = /^(!?=|-)([^\n]+)/.exec(this.input)) {
	      this.consume(captures[0].length);
	      var flags = captures[1];
	      captures[1] = captures[2];
	      var tok = this.tok('code', captures[1]);
	      tok.escape = flags[0] === '=';
	      tok.buffer = flags[0] === '=' || flags[1] === '=';
	      return tok;
	    }
	  },
	  
	  /**
	   * Attributes.
	   */
	  
	  attrs: function() {
	    if ('(' == this.input.charAt(0)) {
	      var index = this.indexOfDelimiters('(', ')')
	        , str = this.input.substr(1, index-1)
	        , tok = this.tok('attrs')
	        , len = str.length
	        , colons = this.colons
	        , states = ['key']
	        , escapedAttr
	        , key = ''
	        , val = ''
	        , quote
	        , c
	        , p;

	      function state(){
	        return states[states.length - 1];
	      }

	      function interpolate(attr) {
	        return attr.replace(/#\{([^}]+)\}/g, function(_, expr){
	          return quote + " + (" + expr + ") + " + quote;
	        });
	      }

	      this.consume(index + 1);
	      tok.attrs = {};
	      tok.escaped = {};

	      function parse(c) {
	        var real = c;
	        // TODO: remove when people fix ":"
	        if (colons && ':' == c) c = '=';
	        switch (c) {
	          case ',':
	          case '\n':
	            switch (state()) {
	              case 'expr':
	              case 'array':
	              case 'string':
	              case 'object':
	                val += c;
	                break;
	              default:
	                states.push('key');
	                val = val.trim();
	                key = key.trim();
	                if ('' == key) return;
	                key = key.replace(/^['"]|['"]$/g, '').replace('!', '');
	                tok.escaped[key] = escapedAttr;
	                tok.attrs[key] = '' == val
	                  ? true
	                  : interpolate(val);
	                key = val = '';
	            }
	            break;
	          case '=':
	            switch (state()) {
	              case 'key char':
	                key += real;
	                break;
	              case 'val':
	              case 'expr':
	              case 'array':
	              case 'string':
	              case 'object':
	                val += real;
	                break;
	              default:
	                escapedAttr = '!' != p;
	                states.push('val');
	            }
	            break;
	          case '(':
	            if ('val' == state()
	              || 'expr' == state()) states.push('expr');
	            val += c;
	            break;
	          case ')':
	            if ('expr' == state()
	              || 'val' == state()) states.pop();
	            val += c;
	            break;
	          case '{':
	            if ('val' == state()) states.push('object');
	            val += c;
	            break;
	          case '}':
	            if ('object' == state()) states.pop();
	            val += c;
	            break;
	          case '[':
	            if ('val' == state()) states.push('array');
	            val += c;
	            break;
	          case ']':
	            if ('array' == state()) states.pop();
	            val += c;
	            break;
	          case '"':
	          case "'":
	            switch (state()) {
	              case 'key':
	                states.push('key char');
	                break;
	              case 'key char':
	                states.pop();
	                break;
	              case 'string':
	                if (c == quote) states.pop();
	                val += c;
	                break;
	              default:
	                states.push('string');
	                val += c;
	                quote = c;
	            }
	            break;
	          case '':
	            break;
	          default:
	            switch (state()) {
	              case 'key':
	              case 'key char':
	                key += c;
	                break;
	              default:
	                val += c;
	            }
	        }
	        p = c;
	      }

	      for (var i = 0; i < len; ++i) {
	        parse(str.charAt(i));
	      }

	      parse(',');

	      if ('/' == this.input.charAt(0)) {
	        this.consume(1);
	        tok.selfClosing = true;
	      }

	      return tok;
	    }
	  },
	  
	  /**
	   * Indent | Outdent | Newline.
	   */
	  
	  indent: function() {
	    var captures, re;

	    // established regexp
	    if (this.indentRe) {
	      captures = this.indentRe.exec(this.input);
	    // determine regexp
	    } else {
	      // tabs
	      re = /^\n(\t*) */;
	      captures = re.exec(this.input);

	      // spaces
	      if (captures && !captures[1].length) {
	        re = /^\n( *)/;
	        captures = re.exec(this.input);
	      }

	      // established
	      if (captures && captures[1].length) this.indentRe = re;
	    }

	    if (captures) {
	      var tok
	        , indents = captures[1].length;

	      ++this.lineno;
	      this.consume(indents + 1);

	      if (' ' == this.input[0] || '\t' == this.input[0]) {
	        throw new Error('Invalid indentation, you can use tabs or spaces but not both');
	      }

	      // blank line
	      if ('\n' == this.input[0]) return this.tok('newline');

	      // outdent
	      if (this.indentStack.length && indents < this.indentStack[0]) {
	        while (this.indentStack.length && this.indentStack[0] > indents) {
	          this.stash.push(this.tok('outdent'));
	          this.indentStack.shift();
	        }
	        tok = this.stash.pop();
	      // indent
	      } else if (indents && indents != this.indentStack[0]) {
	        this.indentStack.unshift(indents);
	        tok = this.tok('indent', indents);
	      // newline
	      } else {
	        tok = this.tok('newline');
	      }

	      return tok;
	    }
	  },

	  /**
	   * Pipe-less text consumed only when 
	   * pipeless is true;
	   */

	  pipelessText: function() {
	    if (this.pipeless) {
	      if ('\n' == this.input[0]) return;
	      var i = this.input.indexOf('\n');
	      if (-1 == i) i = this.input.length;
	      var str = this.input.substr(0, i);
	      this.consume(str.length);
	      return this.tok('text', str);
	    }
	  },

	  /**
	   * ':'
	   */

	  colon: function() {
	    return this.scan(/^: */, ':');
	  },

	  /**
	   * Return the next token object, or those
	   * previously stashed by lookahead.
	   *
	   * @return {Object}
	   * @api private
	   */
	  
	  advance: function(){
	    return this.stashed()
	      || this.next();
	  },
	  
	  /**
	   * Return the next token object.
	   *
	   * @return {Object}
	   * @api private
	   */
	  
	  next: function() {
	    return this.deferred()
	      || this.blank()
	      || this.eos()
	      || this.pipelessText()
	      || this.yield()
	      || this.doctype()
	      || this.interpolation()
	      || this["case"]()
	      || this.when()
	      || this["default"]()
	      || this["extends"]()
	      || this.append()
	      || this.prepend()
	      || this.block()
	      || this.include()
	      || this.mixin()
	      || this.call()
	      || this.conditional()
	      || this.each()
	      || this["while"]()
	      || this.assignment()
	      || this.tag()
	      || this.filter()
	      || this.code()
	      || this.id()
	      || this.className()
	      || this.attrs()
	      || this.indent()
	      || this.comment()
	      || this.colon()
	      || this.text();
	  }
	};


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	exports.Node = __webpack_require__(84);
	exports.Tag = __webpack_require__(85);
	exports.Code = __webpack_require__(89);
	exports.Each = __webpack_require__(90);
	exports.Case = __webpack_require__(91);
	exports.Text = __webpack_require__(92);
	exports.Block = __webpack_require__(87);
	exports.Mixin = __webpack_require__(93);
	exports.Filter = __webpack_require__(94);
	exports.Comment = __webpack_require__(95);
	exports.Literal = __webpack_require__(96);
	exports.BlockComment = __webpack_require__(97);
	exports.Doctype = __webpack_require__(98);


/***/ },
/* 84 */
/***/ function(module, exports) {

	
	/*!
	 * Jade - nodes - Node
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Initialize a `Node`.
	 *
	 * @api public
	 */

	var Node = module.exports = function Node(){};

	/**
	 * Clone this node (return itself)
	 *
	 * @return {Node}
	 * @api private
	 */

	Node.prototype.clone = function(){
	  return this;
	};


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Tag
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Attrs = __webpack_require__(86),
	    Block = __webpack_require__(87),
	    inlineTags = __webpack_require__(88);

	/**
	 * Initialize a `Tag` node with the given tag `name` and optional `block`.
	 *
	 * @param {String} name
	 * @param {Block} block
	 * @api public
	 */

	var Tag = module.exports = function Tag(name, block) {
	  this.name = name;
	  this.attrs = [];
	  this.block = block || new Block;
	};

	/**
	 * Inherit from `Attrs`.
	 */

	Tag.prototype.__proto__ = Attrs.prototype;

	/**
	 * Clone this tag.
	 *
	 * @return {Tag}
	 * @api private
	 */

	Tag.prototype.clone = function(){
	  var clone = new Tag(this.name, this.block.clone());
	  clone.line = this.line;
	  clone.attrs = this.attrs;
	  clone.textOnly = this.textOnly;
	  return clone;
	};

	/**
	 * Check if this tag is an inline tag.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	Tag.prototype.isInline = function(){
	  return ~inlineTags.indexOf(this.name);
	};

	/**
	 * Check if this tag's contents can be inlined.  Used for pretty printing.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	Tag.prototype.canInline = function(){
	  var nodes = this.block.nodes;

	  function isInline(node){
	    // Recurse if the node is a block
	    if (node.isBlock) return node.nodes.every(isInline);
	    return node.isText || (node.isInline && node.isInline());
	  }
	  
	  // Empty tag
	  if (!nodes.length) return true;
	  
	  // Text-only or inline-only tag
	  if (1 == nodes.length) return isInline(nodes[0]);
	  
	  // Multi-line inline-only tag
	  if (this.block.nodes.every(isInline)) {
	    for (var i = 1, len = nodes.length; i < len; ++i) {
	      if (nodes[i-1].isText && nodes[i].isText)
	        return false;
	    }
	    return true;
	  }
	  
	  // Mixed tag
	  return false;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Attrs
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84),
	    Block = __webpack_require__(87);

	/**
	 * Initialize a `Attrs` node.
	 *
	 * @api public
	 */

	var Attrs = module.exports = function Attrs() {
	  this.attrs = [];
	};

	/**
	 * Inherit from `Node`.
	 */

	Attrs.prototype.__proto__ = Node.prototype;

	/**
	 * Set attribute `name` to `val`, keep in mind these become
	 * part of a raw js object literal, so to quote a value you must
	 * '"quote me"', otherwise or example 'user.name' is literal JavaScript.
	 *
	 * @param {String} name
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @return {Tag} for chaining
	 * @api public
	 */

	Attrs.prototype.setAttribute = function(name, val, escaped){
	  this.attrs.push({ name: name, val: val, escaped: escaped });
	  return this;
	};

	/**
	 * Remove attribute `name` when present.
	 *
	 * @param {String} name
	 * @api public
	 */

	Attrs.prototype.removeAttribute = function(name){
	  for (var i = 0, len = this.attrs.length; i < len; ++i) {
	    if (this.attrs[i] && this.attrs[i].name == name) {
	      delete this.attrs[i];
	    }
	  }
	};

	/**
	 * Get attribute value by `name`.
	 *
	 * @param {String} name
	 * @return {String}
	 * @api public
	 */

	Attrs.prototype.getAttribute = function(name){
	  for (var i = 0, len = this.attrs.length; i < len; ++i) {
	    if (this.attrs[i] && this.attrs[i].name == name) {
	      return this.attrs[i].val;
	    }
	  }
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Block
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a new `Block` with an optional `node`.
	 *
	 * @param {Node} node
	 * @api public
	 */

	var Block = module.exports = function Block(node){
	  this.nodes = [];
	  if (node) this.push(node);
	};

	/**
	 * Inherit from `Node`.
	 */

	Block.prototype.__proto__ = Node.prototype;

	/**
	 * Block flag.
	 */

	Block.prototype.isBlock = true;

	/**
	 * Replace the nodes in `other` with the nodes
	 * in `this` block.
	 *
	 * @param {Block} other
	 * @api private
	 */

	Block.prototype.replace = function(other){
	  other.nodes = this.nodes;
	};

	/**
	 * Pust the given `node`.
	 *
	 * @param {Node} node
	 * @return {Number}
	 * @api public
	 */

	Block.prototype.push = function(node){
	  return this.nodes.push(node);
	};

	/**
	 * Check if this block is empty.
	 *
	 * @return {Boolean}
	 * @api public
	 */

	Block.prototype.isEmpty = function(){
	  return 0 == this.nodes.length;
	};

	/**
	 * Unshift the given `node`.
	 *
	 * @param {Node} node
	 * @return {Number}
	 * @api public
	 */

	Block.prototype.unshift = function(node){
	  return this.nodes.unshift(node);
	};

	/**
	 * Return the "last" block, or the first `yield` node.
	 *
	 * @return {Block}
	 * @api private
	 */

	Block.prototype.includeBlock = function(){
	  var ret = this
	    , node;

	  for (var i = 0, len = this.nodes.length; i < len; ++i) {
	    node = this.nodes[i];
	    if (node.yield) return node;
	    else if (node.textOnly) continue;
	    else if (node.includeBlock) ret = node.includeBlock();
	    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();
	  }

	  return ret;
	};

	/**
	 * Return a clone of this block.
	 *
	 * @return {Block}
	 * @api private
	 */

	Block.prototype.clone = function(){
	  var clone = new Block;
	  for (var i = 0, len = this.nodes.length; i < len; ++i) {
	    clone.push(this.nodes[i].clone());
	  }
	  return clone;
	};



/***/ },
/* 88 */
/***/ function(module, exports) {

	
	/*!
	 * Jade - inline tags
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	module.exports = [
	    'a'
	  , 'abbr'
	  , 'acronym'
	  , 'b'
	  , 'br'
	  , 'code'
	  , 'em'
	  , 'font'
	  , 'i'
	  , 'img'
	  , 'ins'
	  , 'kbd'
	  , 'map'
	  , 'samp'
	  , 'small'
	  , 'span'
	  , 'strong'
	  , 'sub'
	  , 'sup'
	];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Code
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a `Code` node with the given code `val`.
	 * Code may also be optionally buffered and escaped.
	 *
	 * @param {String} val
	 * @param {Boolean} buffer
	 * @param {Boolean} escape
	 * @api public
	 */

	var Code = module.exports = function Code(val, buffer, escape) {
	  this.val = val;
	  this.buffer = buffer;
	  this.escape = escape;
	  if (val.match(/^ *else/)) this.debug = false;
	};

	/**
	 * Inherit from `Node`.
	 */

	Code.prototype.__proto__ = Node.prototype;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Each
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize an `Each` node, representing iteration
	 *
	 * @param {String} obj
	 * @param {String} val
	 * @param {String} key
	 * @param {Block} block
	 * @api public
	 */

	var Each = module.exports = function Each(obj, val, key, block) {
	  this.obj = obj;
	  this.val = val;
	  this.key = key;
	  this.block = block;
	};

	/**
	 * Inherit from `Node`.
	 */

	Each.prototype.__proto__ = Node.prototype;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Case
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a new `Case` with `expr`.
	 *
	 * @param {String} expr
	 * @api public
	 */

	var Case = exports = module.exports = function Case(expr, block){
	  this.expr = expr;
	  this.block = block;
	};

	/**
	 * Inherit from `Node`.
	 */

	Case.prototype.__proto__ = Node.prototype;

	var When = exports.When = function When(expr, block){
	  this.expr = expr;
	  this.block = block;
	  this.debug = false;
	};

	/**
	 * Inherit from `Node`.
	 */

	When.prototype.__proto__ = Node.prototype;



/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Text
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a `Text` node with optional `line`.
	 *
	 * @param {String} line
	 * @api public
	 */

	var Text = module.exports = function Text(line) {
	  this.val = '';
	  if ('string' == typeof line) this.val = line;
	};

	/**
	 * Inherit from `Node`.
	 */

	Text.prototype.__proto__ = Node.prototype;

	/**
	 * Flag as text.
	 */

	Text.prototype.isText = true;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Mixin
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Attrs = __webpack_require__(86);

	/**
	 * Initialize a new `Mixin` with `name` and `block`.
	 *
	 * @param {String} name
	 * @param {String} args
	 * @param {Block} block
	 * @api public
	 */

	var Mixin = module.exports = function Mixin(name, args, block, call){
	  this.name = name;
	  this.args = args;
	  this.block = block;
	  this.attrs = [];
	  this.call = call;
	};

	/**
	 * Inherit from `Attrs`.
	 */

	Mixin.prototype.__proto__ = Attrs.prototype;



/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Filter
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84)
	  , Block = __webpack_require__(87);

	/**
	 * Initialize a `Filter` node with the given 
	 * filter `name` and `block`.
	 *
	 * @param {String} name
	 * @param {Block|Node} block
	 * @api public
	 */

	var Filter = module.exports = function Filter(name, block, attrs) {
	  this.name = name;
	  this.block = block;
	  this.attrs = attrs;
	  this.isASTFilter = !block.nodes.every(function(node){ return node.isText });
	};

	/**
	 * Inherit from `Node`.
	 */

	Filter.prototype.__proto__ = Node.prototype;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Comment
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a `Comment` with the given `val`, optionally `buffer`,
	 * otherwise the comment may render in the output.
	 *
	 * @param {String} val
	 * @param {Boolean} buffer
	 * @api public
	 */

	var Comment = module.exports = function Comment(val, buffer) {
	  this.val = val;
	  this.buffer = buffer;
	};

	/**
	 * Inherit from `Node`.
	 */

	Comment.prototype.__proto__ = Node.prototype;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Literal
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a `Literal` node with the given `str.
	 *
	 * @param {String} str
	 * @api public
	 */

	var Literal = module.exports = function Literal(str) {
	  this.str = str
	    .replace(/\\/g, "\\\\")
	    .replace(/\n|\r\n/g, "\\n")
	    .replace(/'/g, "\\'");
	};

	/**
	 * Inherit from `Node`.
	 */

	Literal.prototype.__proto__ = Node.prototype;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - BlockComment
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a `BlockComment` with the given `block`.
	 *
	 * @param {String} val
	 * @param {Block} block
	 * @param {Boolean} buffer
	 * @api public
	 */

	var BlockComment = module.exports = function BlockComment(val, block, buffer) {
	  this.block = block;
	  this.val = val;
	  this.buffer = buffer;
	};

	/**
	 * Inherit from `Node`.
	 */

	BlockComment.prototype.__proto__ = Node.prototype;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - nodes - Doctype
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var Node = __webpack_require__(84);

	/**
	 * Initialize a `Doctype` with the given `val`. 
	 *
	 * @param {String} val
	 * @api public
	 */

	var Doctype = module.exports = function Doctype(val) {
	  this.val = val;
	};

	/**
	 * Inherit from `Node`.
	 */

	Doctype.prototype.__proto__ = Node.prototype;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - Compiler
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var nodes = __webpack_require__(83)
	  , filters = __webpack_require__(100)
	  , doctypes = __webpack_require__(103)
	  , selfClosing = __webpack_require__(104)
	  , runtime = __webpack_require__(105)
	  , utils = __webpack_require__(106);

	// if browser
	//
	// if (!Object.keys) {
	//   Object.keys = function(obj){
	//     var arr = [];
	//     for (var key in obj) {
	//       if (obj.hasOwnProperty(key)) {
	//         arr.push(key);
	//       }
	//     }
	//     return arr;
	//   }
	// }
	//
	// if (!String.prototype.trimLeft) {
	//   String.prototype.trimLeft = function(){
	//     return this.replace(/^\s+/, '');
	//   }
	// }
	//
	// end


	/**
	 * Initialize `Compiler` with the given `node`.
	 *
	 * @param {Node} node
	 * @param {Object} options
	 * @api public
	 */

	var Compiler = module.exports = function Compiler(node, options) {
	  this.options = options = options || {};
	  this.node = node;
	  this.hasCompiledDoctype = false;
	  this.hasCompiledTag = false;
	  this.pp = options.pretty || false;
	  this.debug = false !== options.compileDebug;
	  this.indents = 0;
	  this.parentIndents = 0;
	  if (options.doctype) this.setDoctype(options.doctype);
	};

	/**
	 * Compiler prototype.
	 */

	Compiler.prototype = {

	  /**
	   * Compile parse tree to JavaScript.
	   *
	   * @api public
	   */

	  compile: function(){
	    this.buf = ['var interp;'];
	    if (this.pp) this.buf.push("var __indent = [];");
	    this.lastBufferedIdx = -1;
	    this.visit(this.node);
	    return this.buf.join('\n');
	  },

	  /**
	   * Sets the default doctype `name`. Sets terse mode to `true` when
	   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
	   * and boolean attributes are not mirrored.
	   *
	   * @param {string} name
	   * @api public
	   */

	  setDoctype: function(name){
	    var doctype = doctypes[(name || 'default').toLowerCase()];
	    doctype = doctype || '<!DOCTYPE ' + name + '>';
	    this.doctype = doctype;
	    this.terse = '5' == name || 'html' == name;
	    this.xml = 0 == this.doctype.indexOf('<?xml');
	  },

	  /**
	   * Buffer the given `str` optionally escaped.
	   *
	   * @param {String} str
	   * @param {Boolean} esc
	   * @api public
	   */

	  buffer: function(str, esc){
	    if (esc) str = utils.escape(str);

	    if (this.lastBufferedIdx == this.buf.length) {
	      this.lastBuffered += str;
	      this.buf[this.lastBufferedIdx - 1] = "buf.push('" + this.lastBuffered + "');"
	    } else {
	      this.buf.push("buf.push('" + str + "');");
	      this.lastBuffered = str;
	      this.lastBufferedIdx = this.buf.length;
	    }
	  },

	  /**
	   * Buffer an indent based on the current `indent`
	   * property and an additional `offset`.
	   *
	   * @param {Number} offset
	   * @param {Boolean} newline
	   * @api public
	   */
	  
	  prettyIndent: function(offset, newline){
	    offset = offset || 0;
	    newline = newline ? '\\n' : '';
	    this.buffer(newline + Array(this.indents + offset).join('  '));
	    if (this.parentIndents)
	      this.buf.push("buf.push.apply(buf, __indent);");
	  },

	  /**
	   * Visit `node`.
	   *
	   * @param {Node} node
	   * @api public
	   */

	  visit: function(node){
	    var debug = this.debug;

	    if (debug) {
	      this.buf.push('__jade.unshift({ lineno: ' + node.line
	        + ', filename: ' + (node.filename
	          ? JSON.stringify(node.filename)
	          : '__jade[0].filename')
	        + ' });');
	    }

	    // Massive hack to fix our context
	    // stack for - else[ if] etc
	    if (false === node.debug && this.debug) {
	      this.buf.pop();
	      this.buf.pop();
	    }

	    this.visitNode(node);

	    if (debug) this.buf.push('__jade.shift();');
	  },

	  /**
	   * Visit `node`.
	   *
	   * @param {Node} node
	   * @api public
	   */

	  visitNode: function(node){
	    var name = node.constructor.name
	      || node.constructor.toString().match(/function ([^(\s]+)()/)[1];
	    return this['visit' + name](node);
	  },

	  /**
	   * Visit case `node`.
	   *
	   * @param {Literal} node
	   * @api public
	   */

	  visitCase: function(node){
	    var _ = this.withinCase;
	    this.withinCase = true;
	    this.buf.push('switch (' + node.expr + '){');
	    this.visit(node.block);
	    this.buf.push('}');
	    this.withinCase = _;
	  },

	  /**
	   * Visit when `node`.
	   *
	   * @param {Literal} node
	   * @api public
	   */

	  visitWhen: function(node){
	    if ('default' == node.expr) {
	      this.buf.push('default:');
	    } else {
	      this.buf.push('case ' + node.expr + ':');
	    }
	    this.visit(node.block);
	    this.buf.push('  break;');
	  },

	  /**
	   * Visit literal `node`.
	   *
	   * @param {Literal} node
	   * @api public
	   */

	  visitLiteral: function(node){
	    var str = node.str.replace(/\n/g, '\\\\n');
	    this.buffer(str);
	  },

	  /**
	   * Visit all nodes in `block`.
	   *
	   * @param {Block} block
	   * @api public
	   */

	  visitBlock: function(block){
	    var len = block.nodes.length
	      , escape = this.escape
	      , pp = this.pp
	    
	    // Block keyword has a special meaning in mixins
	    if (this.parentIndents && block.mode) {
	      if (pp) this.buf.push("__indent.push('" + Array(this.indents + 1).join('  ') + "');")
	      this.buf.push('block && block();');
	      if (pp) this.buf.push("__indent.pop();")
	      return;
	    }
	    
	    // Pretty print multi-line text
	    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)
	      this.prettyIndent(1, true);
	    
	    for (var i = 0; i < len; ++i) {
	      // Pretty print text
	      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)
	        this.prettyIndent(1, false);
	      
	      this.visit(block.nodes[i]);
	      // Multiple text nodes are separated by newlines
	      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)
	        this.buffer('\\n');
	    }
	  },

	  /**
	   * Visit `doctype`. Sets terse mode to `true` when html 5
	   * is used, causing self-closing tags to end with ">" vs "/>",
	   * and boolean attributes are not mirrored.
	   *
	   * @param {Doctype} doctype
	   * @api public
	   */

	  visitDoctype: function(doctype){
	    if (doctype && (doctype.val || !this.doctype)) {
	      this.setDoctype(doctype.val || 'default');
	    }

	    if (this.doctype) this.buffer(this.doctype);
	    this.hasCompiledDoctype = true;
	  },

	  /**
	   * Visit `mixin`, generating a function that
	   * may be called within the template.
	   *
	   * @param {Mixin} mixin
	   * @api public
	   */

	  visitMixin: function(mixin){
	    var name = mixin.name.replace(/-/g, '_') + '_mixin'
	      , args = mixin.args || ''
	      , block = mixin.block
	      , attrs = mixin.attrs
	      , pp = this.pp;

	    if (mixin.call) {
	      if (pp) this.buf.push("__indent.push('" + Array(this.indents + 1).join('  ') + "');")
	      if (block || attrs.length) {
	        
	        this.buf.push(name + '.call({');
	        
	        if (block) {
	          this.buf.push('block: function(){');
	          
	          // Render block with no indents, dynamically added when rendered
	          this.parentIndents++;
	          var _indents = this.indents;
	          this.indents = 0;
	          this.visit(mixin.block);
	          this.indents = _indents;
	          this.parentIndents--;
	          
	          if (attrs.length) {
	            this.buf.push('},');
	          } else {
	            this.buf.push('}');
	          }
	        }
	        
	        if (attrs.length) {
	          var val = this.attrs(attrs);
	          if (val.inherits) {
	            this.buf.push('attributes: merge({' + val.buf
	                + '}, attributes), escaped: merge(' + val.escaped + ', escaped, true)');
	          } else {
	            this.buf.push('attributes: {' + val.buf + '}, escaped: ' + val.escaped);
	          }
	        }
	        
	        if (args) {
	          this.buf.push('}, ' + args + ');');
	        } else {
	          this.buf.push('});');
	        }
	        
	      } else {
	        this.buf.push(name + '(' + args + ');');
	      }
	      if (pp) this.buf.push("__indent.pop();")
	    } else {
	      this.buf.push('var ' + name + ' = function(' + args + '){');
	      this.buf.push('var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};');
	      this.parentIndents++;
	      this.visit(block);
	      this.parentIndents--;
	      this.buf.push('};');
	    }
	  },

	  /**
	   * Visit `tag` buffering tag markup, generating
	   * attributes, visiting the `tag`'s code and block.
	   *
	   * @param {Tag} tag
	   * @api public
	   */

	  visitTag: function(tag){
	    this.indents++;
	    var name = tag.name
	      , pp = this.pp;

	    if (tag.buffer) name = "' + (" + name + ") + '";

	    if (!this.hasCompiledTag) {
	      if (!this.hasCompiledDoctype && 'html' == name) {
	        this.visitDoctype();
	      }
	      this.hasCompiledTag = true;
	    }

	    // pretty print
	    if (pp && !tag.isInline())
	      this.prettyIndent(0, true);

	    if ((~selfClosing.indexOf(name) || tag.selfClosing) && !this.xml) {
	      this.buffer('<' + name);
	      this.visitAttributes(tag.attrs);
	      this.terse
	        ? this.buffer('>')
	        : this.buffer('/>');
	    } else {
	      // Optimize attributes buffering
	      if (tag.attrs.length) {
	        this.buffer('<' + name);
	        if (tag.attrs.length) this.visitAttributes(tag.attrs);
	        this.buffer('>');
	      } else {
	        this.buffer('<' + name + '>');
	      }
	      if (tag.code) this.visitCode(tag.code);
	      this.escape = 'pre' == tag.name;
	      this.visit(tag.block);

	      // pretty print
	      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())
	        this.prettyIndent(0, true);

	      this.buffer('</' + name + '>');
	    }
	    this.indents--;
	  },

	  /**
	   * Visit `filter`, throwing when the filter does not exist.
	   *
	   * @param {Filter} filter
	   * @api public
	   */

	  visitFilter: function(filter){
	    var fn = filters[filter.name];

	    // unknown filter
	    if (!fn) {
	      if (filter.isASTFilter) {
	        throw new Error('unknown ast filter "' + filter.name + ':"');
	      } else {
	        throw new Error('unknown filter ":' + filter.name + '"');
	      }
	    }

	    if (filter.isASTFilter) {
	      this.buf.push(fn(filter.block, this, filter.attrs));
	    } else {
	      var text = filter.block.nodes.map(function(node){ return node.val }).join('\n');
	      filter.attrs = filter.attrs || {};
	      filter.attrs.filename = this.options.filename;
	      this.buffer(utils.text(fn(text, filter.attrs)));
	    }
	  },

	  /**
	   * Visit `text` node.
	   *
	   * @param {Text} text
	   * @api public
	   */

	  visitText: function(text){
	    text = utils.text(text.val.replace(/\\/g, '\\\\'));
	    if (this.escape) text = escape(text);
	    this.buffer(text);
	  },

	  /**
	   * Visit a `comment`, only buffering when the buffer flag is set.
	   *
	   * @param {Comment} comment
	   * @api public
	   */

	  visitComment: function(comment){
	    if (!comment.buffer) return;
	    if (this.pp) this.prettyIndent(1, true);
	    this.buffer('<!--' + utils.escape(comment.val) + '-->');
	  },

	  /**
	   * Visit a `BlockComment`.
	   *
	   * @param {Comment} comment
	   * @api public
	   */

	  visitBlockComment: function(comment){
	    if (!comment.buffer) return;
	    if (0 == comment.val.trim().indexOf('if')) {
	      this.buffer('<!--[' + comment.val.trim() + ']>');
	      this.visit(comment.block);
	      this.buffer('<![endif]-->');
	    } else {
	      this.buffer('<!--' + comment.val);
	      this.visit(comment.block);
	      this.buffer('-->');
	    }
	  },

	  /**
	   * Visit `code`, respecting buffer / escape flags.
	   * If the code is followed by a block, wrap it in
	   * a self-calling function.
	   *
	   * @param {Code} code
	   * @api public
	   */

	  visitCode: function(code){
	    // Wrap code blocks with {}.
	    // we only wrap unbuffered code blocks ATM
	    // since they are usually flow control

	    // Buffer code
	    if (code.buffer) {
	      var val = code.val.trimLeft();
	      this.buf.push('var __val__ = ' + val);
	      val = 'null == __val__ ? "" : __val__';
	      if (code.escape) val = 'escape(' + val + ')';
	      this.buf.push("buf.push(" + val + ");");
	    } else {
	      this.buf.push(code.val);
	    }

	    // Block support
	    if (code.block) {
	      if (!code.buffer) this.buf.push('{');
	      this.visit(code.block);
	      if (!code.buffer) this.buf.push('}');
	    }
	  },

	  /**
	   * Visit `each` block.
	   *
	   * @param {Each} each
	   * @api public
	   */

	  visitEach: function(each){
	    this.buf.push(''
	      + '// iterate ' + each.obj + '\n'
	      + ';(function(){\n'
	      + '  if (\'number\' == typeof ' + each.obj + '.length) {\n'
	      + '    for (var ' + each.key + ' = 0, $$l = ' + each.obj + '.length; ' + each.key + ' < $$l; ' + each.key + '++) {\n'
	      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\n');

	    this.visit(each.block);

	    this.buf.push(''
	      + '    }\n'
	      + '  } else {\n'
	      + '    for (var ' + each.key + ' in ' + each.obj + ') {\n'
	      // if browser
	      // + '      if (' + each.obj + '.hasOwnProperty(' + each.key + ')){'
	      // end
	      + '      var ' + each.val + ' = ' + each.obj + '[' + each.key + '];\n');

	    this.visit(each.block);

	    // if browser
	    // this.buf.push('      }\n');
	    // end

	    this.buf.push('   }\n  }\n}).call(this);\n');
	  },

	  /**
	   * Visit `attrs`.
	   *
	   * @param {Array} attrs
	   * @api public
	   */

	  visitAttributes: function(attrs){
	    var val = this.attrs(attrs);
	    if (val.inherits) {
	      this.buf.push("buf.push(attrs(merge({ " + val.buf +
	          " }, attributes), merge(" + val.escaped + ", escaped, true)));");
	    } else if (val.constant) {
	      eval('var buf={' + val.buf + '};');
	      this.buffer(runtime.attrs(buf, JSON.parse(val.escaped)), true);
	    } else {
	      this.buf.push("buf.push(attrs({ " + val.buf + " }, " + val.escaped + "));");
	    }
	  },

	  /**
	   * Compile attributes.
	   */

	  attrs: function(attrs){
	    var buf = []
	      , classes = []
	      , escaped = {}
	      , constant = attrs.every(function(attr){ return isConstant(attr.val) })
	      , inherits = false;

	    if (this.terse) buf.push('terse: true');

	    attrs.forEach(function(attr){
	      if (attr.name == 'attributes') return inherits = true;
	      escaped[attr.name] = attr.escaped;
	      if (attr.name == 'class') {
	        classes.push('(' + attr.val + ')');
	      } else {
	        var pair = "'" + attr.name + "':(" + attr.val + ')';
	        buf.push(pair);
	      }
	    });

	    if (classes.length) {
	      classes = classes.join(" + ' ' + ");
	      buf.push("class: " + classes);
	    }

	    return {
	      buf: buf.join(', ').replace('class:', '"class":'),
	      escaped: JSON.stringify(escaped),
	      inherits: inherits,
	      constant: constant
	    };
	  }
	};

	/**
	 * Check if expression can be evaluated to a constant
	 *
	 * @param {String} expression
	 * @return {Boolean}
	 * @api private
	 */

	function isConstant(val){
	  // Check strings/literals
	  if (/^ *("([^"\\]*(\\.[^"\\]*)*)"|'([^'\\]*(\\.[^'\\]*)*)'|true|false|null|undefined) *$/i.test(val))
	    return true;
	  
	  // Check numbers
	  if (!isNaN(Number(val)))
	    return true;
	  
	  // Check arrays
	  var matches;
	  if (matches = /^ *\[(.*)\] *$/.exec(val))
	    return matches[1].split(',').every(isConstant);
	  
	  return false;
	}

	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */

	function escape(html){
	  return String(html)
	    .replace(/&(?!\w+;)/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;');
	}

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - filters
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	module.exports = {
	  
	  /**
	   * Wrap text with CDATA block.
	   */
	  
	  cdata: function(str){
	    return '<![CDATA[\\n' + str + '\\n]]>';
	  },
	  
	  /**
	   * Transform sass to css, wrapped in style tags.
	   */
	  
	  sass: function(str){
	    str = str.replace(/\\n/g, '\n');
	    var sass = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"sass\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).render(str).replace(/\n/g, '\\n');
	    return '<style type="text/css">' + sass + '</style>'; 
	  },
	  
	  /**
	   * Transform stylus to css, wrapped in style tags.
	   */
	  
	  stylus: function(str, options){
	    var ret;
	    str = str.replace(/\\n/g, '\n');
	    var stylus = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"stylus\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	    stylus(str, options).render(function(err, css){
	      if (err) throw err;
	      ret = css.replace(/\n/g, '\\n');
	    });
	    return '<style type="text/css">' + ret + '</style>'; 
	  },
	  
	  /**
	   * Transform less to css, wrapped in style tags.
	   */
	  
	  less: function(str){
	    var ret;
	    str = str.replace(/\\n/g, '\n');
	    __webpack_require__(101).render(str, function(err, css){
	      if (err) throw err;
	      ret = '<style type="text/css">' + css.replace(/\n/g, '\\n') + '</style>';  
	    });
	    return ret;
	  },
	  
	  /**
	   * Transform markdown to html.
	   */
	  
	  markdown: function(str){
	    var md;

	    // support markdown / discount
	    try {
	      md = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"markdown\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	    } catch (err){
	      try {
	        md = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"discount\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	      } catch (err) {
	        try {
	          md = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"markdown-js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	        } catch (err) {
	          try {
	            md = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"marked\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	          } catch (err) {
	            throw new
	              Error('Cannot find markdown library, install markdown, discount, or marked.');
	          }
	        }
	      }
	    }

	    str = str.replace(/\\n/g, '\n');
	    return md.parse(str).replace(/\n/g, '\\n').replace(/'/g,'&#39;');
	  },
	  
	  /**
	   * Transform coffeescript to javascript.
	   */

	  coffeescript: function(str){
	    str = str.replace(/\\n/g, '\n');
	    var js = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"coffee-script\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).compile(str).replace(/\\/g, '\\\\').replace(/\n/g, '\\n');
	    return '<script type="text/javascript">\\n' + js + '</script>';
	  }
	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
	 * Less - Leaner CSS v2.6.0
	 * http://lesscss.org
	 *
	 * Copyright (c) 2009-2016, Alexis Sellier <self@cloudhead.net>
	 * Licensed under the  License.
	 *
	 */

	 /** * @license 
	 */

	(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.less = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	var addDataAttr = require("./utils").addDataAttr,
	    browser = require("./browser");

	module.exports = function(window, options) {

	    // use options from the current script tag data attribues
	    addDataAttr(options, browser.currentScript(window));

	    if (options.isFileProtocol === undefined) {
	        options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);
	    }

	    // Load styles asynchronously (default: false)
	    //
	    // This is set to `false` by default, so that the body
	    // doesn't start loading before the stylesheets are parsed.
	    // Setting this to `true` can result in flickering.
	    //
	    options.async = options.async || false;
	    options.fileAsync = options.fileAsync || false;

	    // Interval between watch polls
	    options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);

	    options.env = options.env || (window.location.hostname == '127.0.0.1' ||
	        window.location.hostname == '0.0.0.0'   ||
	        window.location.hostname == 'localhost' ||
	        (window.location.port &&
	            window.location.port.length > 0)      ||
	        options.isFileProtocol                   ? 'development'
	        : 'production');

	    var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);
	    if (dumpLineNumbers) {
	        options.dumpLineNumbers = dumpLineNumbers[1];
	    }

	    if (options.useFileCache === undefined) {
	        options.useFileCache = true;
	    }

	    if (options.onReady === undefined) {
	        options.onReady = true;
	    }

	};

	},{"./browser":3,"./utils":10}],2:[function(require,module,exports){
	/**
	 * Kicks off less and compiles any stylesheets
	 * used in the browser distributed version of less
	 * to kick-start less using the browser api
	 */
	/*global window, document */

	// shim Promise if required
	require('promise/polyfill.js');

	var options = window.less || {};
	require("./add-default-options")(window, options);

	var less = module.exports = require("./index")(window, options);

	window.less = less;

	var css, head, style;

	// Always restore page visibility
	function resolveOrReject(data) {
	    if (data.filename) {
	        console.warn(data);
	    }
	    if (!options.async) {
	        head.removeChild(style);
	    }
	}

	if (options.onReady) {
	    if (/!watch/.test(window.location.hash)) {
	        less.watch();
	    }
	    // Simulate synchronous stylesheet loading by blocking page rendering
	    if (!options.async) {
	        css = 'body { display: none !important }';
	        head = document.head || document.getElementsByTagName('head')[0];
	        style = document.createElement('style');

	        style.type = 'text/css';
	        if (style.styleSheet) {
	            style.styleSheet.cssText = css;
	        } else {
	            style.appendChild(document.createTextNode(css));
	        }

	        head.appendChild(style);
	    }
	    less.registerStylesheetsImmediately();
	    less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);
	}

	},{"./add-default-options":1,"./index":8,"promise/polyfill.js":97}],3:[function(require,module,exports){
	var utils = require("./utils");
	module.exports = {
	    createCSS: function (document, styles, sheet) {
	        // Strip the query-string
	        var href = sheet.href || '';

	        // If there is no title set, use the filename, minus the extension
	        var id = 'less:' + (sheet.title || utils.extractId(href));

	        // If this has already been inserted into the DOM, we may need to replace it
	        var oldStyleNode = document.getElementById(id);
	        var keepOldStyleNode = false;

	        // Create a new stylesheet node for insertion or (if necessary) replacement
	        var styleNode = document.createElement('style');
	        styleNode.setAttribute('type', 'text/css');
	        if (sheet.media) {
	            styleNode.setAttribute('media', sheet.media);
	        }
	        styleNode.id = id;

	        if (!styleNode.styleSheet) {
	            styleNode.appendChild(document.createTextNode(styles));

	            // If new contents match contents of oldStyleNode, don't replace oldStyleNode
	            keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&
	                oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);
	        }

	        var head = document.getElementsByTagName('head')[0];

	        // If there is no oldStyleNode, just append; otherwise, only append if we need
	        // to replace oldStyleNode with an updated stylesheet
	        if (oldStyleNode === null || keepOldStyleNode === false) {
	            var nextEl = sheet && sheet.nextSibling || null;
	            if (nextEl) {
	                nextEl.parentNode.insertBefore(styleNode, nextEl);
	            } else {
	                head.appendChild(styleNode);
	            }
	        }
	        if (oldStyleNode && keepOldStyleNode === false) {
	            oldStyleNode.parentNode.removeChild(oldStyleNode);
	        }

	        // For IE.
	        // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.
	        // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head
	        if (styleNode.styleSheet) {
	            try {
	                styleNode.styleSheet.cssText = styles;
	            } catch (e) {
	                throw new Error("Couldn't reassign styleSheet.cssText.");
	            }
	        }
	    },
	    currentScript: function(window) {
	        var document = window.document;
	        return document.currentScript || (function() {
	            var scripts = document.getElementsByTagName("script");
	            return scripts[scripts.length - 1];
	        })();
	    }
	};

	},{"./utils":10}],4:[function(require,module,exports){
	// Cache system is a bit outdated and could do with work

	module.exports = function(window, options, logger) {
	    var cache = null;
	    if (options.env !== 'development') {
	        try {
	            cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;
	        } catch (_) {}
	    }
	    return {
	        setCSS: function(path, lastModified, modifyVars, styles) {
	            if (cache) {
	                logger.info('saving ' + path + ' to cache.');
	                try {
	                    cache.setItem(path, styles);
	                    cache.setItem(path + ':timestamp', lastModified);
	                    if (modifyVars) {
	                        cache.setItem(path + ':vars', JSON.stringify(modifyVars));
	                    }
	                } catch(e) {
	                    //TODO - could do with adding more robust error handling
	                    logger.error('failed to save "' + path + '" to local storage for caching.');
	                }
	            }
	        },
	        getCSS: function(path, webInfo, modifyVars) {
	            var css       = cache && cache.getItem(path),
	                timestamp = cache && cache.getItem(path + ':timestamp'),
	                vars      = cache && cache.getItem(path + ':vars');

	            modifyVars = modifyVars || {};

	            if (timestamp && webInfo.lastModified &&
	                (new Date(webInfo.lastModified).valueOf() ===
	                    new Date(timestamp).valueOf()) &&
	                (!modifyVars && !vars || JSON.stringify(modifyVars) === vars)) {
	                // Use local copy
	                return css;
	            }
	        }
	    };
	};

	},{}],5:[function(require,module,exports){
	var utils = require("./utils"),
	    browser = require("./browser");

	module.exports = function(window, less, options) {

	    function errorHTML(e, rootHref) {
	        var id = 'less-error-message:' + utils.extractId(rootHref || "");
	        var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
	        var elem = window.document.createElement('div'), timer, content, errors = [];
	        var filename = e.filename || rootHref;
	        var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];

	        elem.id        = id;
	        elem.className = "less-error-message";

	        content = '<h3>'  + (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
	            '</h3>' + '<p>in <a href="' + filename   + '">' + filenameNoPath + "</a> ";

	        var errorline = function (e, i, classname) {
	            if (e.extract[i] !== undefined) {
	                errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
	                    .replace(/\{class\}/, classname)
	                    .replace(/\{content\}/, e.extract[i]));
	            }
	        };

	        if (e.extract) {
	            errorline(e, 0, '');
	            errorline(e, 1, 'line');
	            errorline(e, 2, '');
	            content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':</p>' +
	                '<ul>' + errors.join('') + '</ul>';
	        }
	        if (e.stack && (e.extract || options.logLevel >= 4)) {
	            content += '<br/>Stack Trace</br />' + e.stack.split('\n').slice(1).join('<br/>');
	        }
	        elem.innerHTML = content;

	        // CSS for error messages
	        browser.createCSS(window.document, [
	            '.less-error-message ul, .less-error-message li {',
	            'list-style-type: none;',
	            'margin-right: 15px;',
	            'padding: 4px 0;',
	            'margin: 0;',
	            '}',
	            '.less-error-message label {',
	            'font-size: 12px;',
	            'margin-right: 15px;',
	            'padding: 4px 0;',
	            'color: #cc7777;',
	            '}',
	            '.less-error-message pre {',
	            'color: #dd6666;',
	            'padding: 4px 0;',
	            'margin: 0;',
	            'display: inline-block;',
	            '}',
	            '.less-error-message pre.line {',
	            'color: #ff0000;',
	            '}',
	            '.less-error-message h3 {',
	            'font-size: 20px;',
	            'font-weight: bold;',
	            'padding: 15px 0 5px 0;',
	            'margin: 0;',
	            '}',
	            '.less-error-message a {',
	            'color: #10a',
	            '}',
	            '.less-error-message .error {',
	            'color: red;',
	            'font-weight: bold;',
	            'padding-bottom: 2px;',
	            'border-bottom: 1px dashed red;',
	            '}'
	        ].join('\n'), { title: 'error-message' });

	        elem.style.cssText = [
	            "font-family: Arial, sans-serif",
	            "border: 1px solid #e00",
	            "background-color: #eee",
	            "border-radius: 5px",
	            "-webkit-border-radius: 5px",
	            "-moz-border-radius: 5px",
	            "color: #e00",
	            "padding: 15px",
	            "margin-bottom: 15px"
	        ].join(';');

	        if (options.env === 'development') {
	            timer = setInterval(function () {
	                var document = window.document,
	                    body = document.body;
	                if (body) {
	                    if (document.getElementById(id)) {
	                        body.replaceChild(elem, document.getElementById(id));
	                    } else {
	                        body.insertBefore(elem, body.firstChild);
	                    }
	                    clearInterval(timer);
	                }
	            }, 10);
	        }
	    }

	    function error(e, rootHref) {
	        if (!options.errorReporting || options.errorReporting === "html") {
	            errorHTML(e, rootHref);
	        } else if (options.errorReporting === "console") {
	            errorConsole(e, rootHref);
	        } else if (typeof options.errorReporting === 'function') {
	            options.errorReporting("add", e, rootHref);
	        }
	    }

	    function removeErrorHTML(path) {
	        var node = window.document.getElementById('less-error-message:' + utils.extractId(path));
	        if (node) {
	            node.parentNode.removeChild(node);
	        }
	    }

	    function removeErrorConsole(path) {
	        //no action
	    }

	    function removeError(path) {
	        if (!options.errorReporting || options.errorReporting === "html") {
	            removeErrorHTML(path);
	        } else if (options.errorReporting === "console") {
	            removeErrorConsole(path);
	        } else if (typeof options.errorReporting === 'function') {
	            options.errorReporting("remove", path);
	        }
	    }

	    function errorConsole(e, rootHref) {
	        var template = '{line} {content}';
	        var filename = e.filename || rootHref;
	        var errors = [];
	        var content = (e.type || "Syntax") + "Error: " + (e.message || 'There is an error in your .less file') +
	            " in " + filename + " ";

	        var errorline = function (e, i, classname) {
	            if (e.extract[i] !== undefined) {
	                errors.push(template.replace(/\{line\}/, (parseInt(e.line, 10) || 0) + (i - 1))
	                    .replace(/\{class\}/, classname)
	                    .replace(/\{content\}/, e.extract[i]));
	            }
	        };

	        if (e.extract) {
	            errorline(e, 0, '');
	            errorline(e, 1, 'line');
	            errorline(e, 2, '');
	            content += 'on line ' + e.line + ', column ' + (e.column + 1) + ':\n' +
	                errors.join('\n');
	        }
	        if (e.stack && (e.extract || options.logLevel >= 4)) {
	            content += '\nStack Trace\n' + e.stack;
	        }
	        less.logger.error(content);
	    }

	    return {
	        add: error,
	        remove: removeError
	    };
	};

	},{"./browser":3,"./utils":10}],6:[function(require,module,exports){
	/*global window, XMLHttpRequest */

	module.exports = function(options, logger) {

	    var AbstractFileManager = require("../less/environment/abstract-file-manager.js");

	    var fileCache = {};

	    //TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load

	    function getXMLHttpRequest() {
	        if (window.XMLHttpRequest && (window.location.protocol !== "file:" || !("ActiveXObject" in window))) {
	            return new XMLHttpRequest();
	        } else {
	            try {
	                /*global ActiveXObject */
	                return new ActiveXObject("Microsoft.XMLHTTP");
	            } catch (e) {
	                logger.error("browser doesn't support AJAX.");
	                return null;
	            }
	        }
	    }

	    var FileManager = function() {
	    };

	    FileManager.prototype = new AbstractFileManager();

	    FileManager.prototype.alwaysMakePathsAbsolute = function alwaysMakePathsAbsolute() {
	        return true;
	    };
	    FileManager.prototype.join = function join(basePath, laterPath) {
	        if (!basePath) {
	            return laterPath;
	        }
	        return this.extractUrlParts(laterPath, basePath).path;
	    };
	    FileManager.prototype.doXHR = function doXHR(url, type, callback, errback) {

	        var xhr = getXMLHttpRequest();
	        var async = options.isFileProtocol ? options.fileAsync : true;

	        if (typeof xhr.overrideMimeType === 'function') {
	            xhr.overrideMimeType('text/css');
	        }
	        logger.debug("XHR: Getting '" + url + "'");
	        xhr.open('GET', url, async);
	        xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');
	        xhr.send(null);

	        function handleResponse(xhr, callback, errback) {
	            if (xhr.status >= 200 && xhr.status < 300) {
	                callback(xhr.responseText,
	                    xhr.getResponseHeader("Last-Modified"));
	            } else if (typeof errback === 'function') {
	                errback(xhr.status, url);
	            }
	        }

	        if (options.isFileProtocol && !options.fileAsync) {
	            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
	                callback(xhr.responseText);
	            } else {
	                errback(xhr.status, url);
	            }
	        } else if (async) {
	            xhr.onreadystatechange = function () {
	                if (xhr.readyState == 4) {
	                    handleResponse(xhr, callback, errback);
	                }
	            };
	        } else {
	            handleResponse(xhr, callback, errback);
	        }
	    };
	    FileManager.prototype.supports = function(filename, currentDirectory, options, environment) {
	        return true;
	    };

	    FileManager.prototype.clearFileCache = function() {
	        fileCache = {};
	    };

	    FileManager.prototype.loadFile = function loadFile(filename, currentDirectory, options, environment, callback) {
	        if (currentDirectory && !this.isPathAbsolute(filename)) {
	            filename = currentDirectory + filename;
	        }

	        options = options || {};

	        // sheet may be set to the stylesheet for the initial load or a collection of properties including
	        // some context variables for imports
	        var hrefParts = this.extractUrlParts(filename, window.location.href);
	        var href      = hrefParts.url;

	        if (options.useFileCache && fileCache[href]) {
	            try {
	                var lessText = fileCache[href];
	                callback(null, { contents: lessText, filename: href, webInfo: { lastModified: new Date() }});
	            } catch (e) {
	                callback({filename: href, message: "Error loading file " + href + " error was " + e.message});
	            }
	            return;
	        }

	        this.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {
	            // per file cache
	            fileCache[href] = data;

	            // Use remote copy (re-parse)
	            callback(null, { contents: data, filename: href, webInfo: { lastModified: lastModified }});
	        }, function doXHRError(status, url) {
	            callback({ type: 'File', message: "'" + url + "' wasn't found (" + status + ")", href: href });
	        });
	    };

	    return FileManager;
	};

	},{"../less/environment/abstract-file-manager.js":15}],7:[function(require,module,exports){
	module.exports = function() {

	    var functionRegistry = require("./../less/functions/function-registry");

	    function imageSize() {
	        throw {
	            type: "Runtime",
	            message: "Image size functions are not supported in browser version of less"
	        };
	    }

	    var imageFunctions = {
	        "image-size": function(filePathNode) {
	            imageSize(this, filePathNode);
	            return -1;
	        },
	        "image-width": function(filePathNode) {
	            imageSize(this, filePathNode);
	            return -1;
	        },
	        "image-height": function(filePathNode) {
	            imageSize(this, filePathNode);
	            return -1;
	        }
	    };

	    functionRegistry.addMultiple(imageFunctions);
	};

	},{"./../less/functions/function-registry":22}],8:[function(require,module,exports){
	//
	// index.js
	// Should expose the additional browser functions on to the less object
	//
	var addDataAttr = require("./utils").addDataAttr,
	    browser = require("./browser");

	module.exports = function(window, options) {
	    var document = window.document;
	    var less = require('../less')();

	    //module.exports = less;
	    less.options = options;
	    var environment = less.environment,
	        FileManager = require("./file-manager")(options, less.logger),
	        fileManager = new FileManager();
	    environment.addFileManager(fileManager);
	    less.FileManager = FileManager;

	    require("./log-listener")(less, options);
	    var errors = require("./error-reporting")(window, less, options);
	    var cache = less.cache = options.cache || require("./cache")(window, options, less.logger);
	    require('./image-size')(less.environment);

	    //Setup user functions
	    if (options.functions) {
	        less.functions.functionRegistry.addMultiple(options.functions);
	    }

	    var typePattern = /^text\/(x-)?less$/;

	    function postProcessCSS(styles) { // deprecated, use a plugin for postprocesstasks
	        if (options.postProcessor && typeof options.postProcessor === 'function') {
	            styles = options.postProcessor.call(styles, styles) || styles;
	        }
	        return styles;
	    }

	    function clone(obj) {
	        var cloned = {};
	        for (var prop in obj) {
	            if (obj.hasOwnProperty(prop)) {
	                cloned[prop] = obj[prop];
	            }
	        }
	        return cloned;
	    }

	    // only really needed for phantom
	    function bind(func, thisArg) {
	        var curryArgs = Array.prototype.slice.call(arguments, 2);
	        return function() {
	            var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));
	            return func.apply(thisArg, args);
	        };
	    }

	    function loadStyles(modifyVars) {
	        var styles = document.getElementsByTagName('style'),
	            style;

	        for (var i = 0; i < styles.length; i++) {
	            style = styles[i];
	            if (style.type.match(typePattern)) {
	                var instanceOptions = clone(options);
	                instanceOptions.modifyVars = modifyVars;
	                var lessText = style.innerHTML || '';
	                instanceOptions.filename = document.location.href.replace(/#.*$/, '');

	                /*jshint loopfunc:true */
	                // use closure to store current style
	                less.render(lessText, instanceOptions,
	                        bind(function(style, e, result) {
	                            if (e) {
	                                errors.add(e, "inline");
	                            } else {
	                                style.type = 'text/css';
	                                if (style.styleSheet) {
	                                    style.styleSheet.cssText = result.css;
	                                } else {
	                                    style.innerHTML = result.css;
	                                }
	                            }
	                        }, null, style));
	            }
	        }
	    }

	    function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {

	        var instanceOptions = clone(options);
	        addDataAttr(instanceOptions, sheet);
	        instanceOptions.mime = sheet.type;

	        if (modifyVars) {
	            instanceOptions.modifyVars = modifyVars;
	        }

	        function loadInitialFileCallback(loadedFile) {

	            var data = loadedFile.contents,
	                path = loadedFile.filename,
	                webInfo = loadedFile.webInfo;

	            var newFileInfo = {
	                currentDirectory: fileManager.getPath(path),
	                filename: path,
	                rootFilename: path,
	                relativeUrls: instanceOptions.relativeUrls};

	            newFileInfo.entryPath = newFileInfo.currentDirectory;
	            newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;

	            if (webInfo) {
	                webInfo.remaining = remaining;

	                var css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);
	                if (!reload && css) {
	                    webInfo.local = true;
	                    callback(null, css, data, sheet, webInfo, path);
	                    return;
	                }

	            }

	            //TODO add tests around how this behaves when reloading
	            errors.remove(path);

	            instanceOptions.rootFileInfo = newFileInfo;
	            less.render(data, instanceOptions, function(e, result) {
	                if (e) {
	                    e.href = path;
	                    callback(e);
	                } else {
	                    result.css = postProcessCSS(result.css);
	                    cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);
	                    callback(null, result.css, data, sheet, webInfo, path);
	                }
	            });
	        }

	        fileManager.loadFile(sheet.href, null, instanceOptions, environment, function(e, loadedFile) {
	            if (e) {
	                callback(e);
	                return;
	            }
	            loadInitialFileCallback(loadedFile);
	        });
	    }

	    function loadStyleSheets(callback, reload, modifyVars) {
	        for (var i = 0; i < less.sheets.length; i++) {
	            loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);
	        }
	    }

	    function initRunningMode() {
	        if (less.env === 'development') {
	            less.watchTimer = setInterval(function () {
	                if (less.watchMode) {
	                    fileManager.clearFileCache();
	                    loadStyleSheets(function (e, css, _, sheet, webInfo) {
	                        if (e) {
	                            errors.add(e, e.href || sheet.href);
	                        } else if (css) {
	                            browser.createCSS(window.document, css, sheet);
	                        }
	                    });
	                }
	            }, options.poll);
	        }
	    }

	    //
	    // Watch mode
	    //
	    less.watch   = function () {
	        if (!less.watchMode ) {
	            less.env = 'development';
	            initRunningMode();
	        }
	        this.watchMode = true;
	        return true;
	    };

	    less.unwatch = function () {clearInterval(less.watchTimer); this.watchMode = false; return false; };

	    //
	    // Synchronously get all <link> tags with the 'rel' attribute set to
	    // "stylesheet/less".
	    //
	    less.registerStylesheetsImmediately = function() {
	        var links = document.getElementsByTagName('link');
	        less.sheets = [];

	        for (var i = 0; i < links.length; i++) {
	            if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&
	                (links[i].type.match(typePattern)))) {
	                less.sheets.push(links[i]);
	            }
	        }
	    };

	    //
	    // Asynchronously get all <link> tags with the 'rel' attribute set to
	    // "stylesheet/less", returning a Promise.
	    //
	    less.registerStylesheets = function() {
	        return new Promise(function(resolve, reject) {
	            less.registerStylesheetsImmediately();
	            resolve();
	        });
	    };

	    //
	    // With this function, it's possible to alter variables and re-render
	    // CSS without reloading less-files
	    //
	    less.modifyVars = function(record) {
	        return less.refresh(true, record, false);
	    };

	    less.refresh = function (reload, modifyVars, clearFileCache) {
	        if ((reload || clearFileCache) && clearFileCache !== false) {
	            fileManager.clearFileCache();
	        }
	        return new Promise(function (resolve, reject) {
	            var startTime, endTime, totalMilliseconds;
	            startTime = endTime = new Date();

	            loadStyleSheets(function (e, css, _, sheet, webInfo) {
	                if (e) {
	                    errors.add(e, e.href || sheet.href);
	                    reject(e);
	                    return;
	                }
	                if (webInfo.local) {
	                    less.logger.info("loading " + sheet.href + " from cache.");
	                } else {
	                    less.logger.info("rendered " + sheet.href + " successfully.");
	                }
	                browser.createCSS(window.document, css, sheet);
	                less.logger.info("css for " + sheet.href + " generated in " + (new Date() - endTime) + 'ms');
	                if (webInfo.remaining === 0) {
	                    totalMilliseconds = new Date() - startTime;
	                    less.logger.info("less has finished. css generated in " + totalMilliseconds + 'ms');
	                    resolve({
	                        startTime: startTime,
	                        endTime: endTime,
	                        totalMilliseconds: totalMilliseconds,
	                        sheets: less.sheets.length
	                    });
	                }
	                endTime = new Date();
	            }, reload, modifyVars);

	            loadStyles(modifyVars);
	        });
	    };

	    less.refreshStyles = loadStyles;
	    return less;
	};

	},{"../less":31,"./browser":3,"./cache":4,"./error-reporting":5,"./file-manager":6,"./image-size":7,"./log-listener":9,"./utils":10}],9:[function(require,module,exports){
	module.exports = function(less, options) {

	    var logLevel_debug = 4,
	        logLevel_info = 3,
	        logLevel_warn = 2,
	        logLevel_error = 1;

	    // The amount of logging in the javascript console.
	    // 3 - Debug, information and errors
	    // 2 - Information and errors
	    // 1 - Errors
	    // 0 - None
	    // Defaults to 2
	    options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ?  logLevel_info : logLevel_error);

	    if (!options.loggers) {
	        options.loggers = [{
	            debug: function(msg) {
	                if (options.logLevel >= logLevel_debug) {
	                    console.log(msg);
	                }
	            },
	            info: function(msg) {
	                if (options.logLevel >= logLevel_info) {
	                    console.log(msg);
	                }
	            },
	            warn: function(msg) {
	                if (options.logLevel >= logLevel_warn) {
	                    console.warn(msg);
	                }
	            },
	            error: function(msg) {
	                if (options.logLevel >= logLevel_error) {
	                    console.error(msg);
	                }
	            }
	        }];
	    }
	    for (var i = 0; i < options.loggers.length; i++) {
	        less.logger.addListener(options.loggers[i]);
	    }
	};

	},{}],10:[function(require,module,exports){
	module.exports = {
	    extractId: function(href) {
	        return href.replace(/^[a-z-]+:\/+?[^\/]+/, '')  // Remove protocol & domain
	            .replace(/[\?\&]livereload=\w+/, '')        // Remove LiveReload cachebuster
	            .replace(/^\//, '')                         // Remove root /
	            .replace(/\.[a-zA-Z]+$/, '')                // Remove simple extension
	            .replace(/[^\.\w-]+/g, '-')                 // Replace illegal characters
	            .replace(/\./g, ':');                       // Replace dots with colons(for valid id)
	    },
	    addDataAttr: function(options, tag) {
	        for (var opt in tag.dataset) {
	            if (tag.dataset.hasOwnProperty(opt)) {
	                if (opt === "env" || opt === "dumpLineNumbers" || opt === "rootpath" || opt === "errorReporting") {
	                    options[opt] = tag.dataset[opt];
	                } else {
	                    try {
	                        options[opt] = JSON.parse(tag.dataset[opt]);
	                    }
	                    catch(_) {}
	                }
	            }
	        }
	    }
	};

	},{}],11:[function(require,module,exports){
	var contexts = {};
	module.exports = contexts;

	var copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {
	    if (!original) { return; }

	    for (var i = 0; i < propertiesToCopy.length; i++) {
	        if (original.hasOwnProperty(propertiesToCopy[i])) {
	            destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];
	        }
	    }
	};

	/*
	 parse is used whilst parsing
	 */
	var parseCopyProperties = [
	    // options
	    'paths',            // option - unmodified - paths to search for imports on
	    'relativeUrls',     // option - whether to adjust URL's to be relative
	    'rootpath',         // option - rootpath to append to URL's
	    'strictImports',    // option -
	    'insecure',         // option - whether to allow imports from insecure ssl hosts
	    'dumpLineNumbers',  // option - whether to dump line numbers
	    'compress',         // option - whether to compress
	    'syncImport',       // option - whether to import synchronously
	    'chunkInput',       // option - whether to chunk input. more performant but causes parse issues.
	    'mime',             // browser only - mime type for sheet import
	    'useFileCache',     // browser only - whether to use the per file session cache
	    // context
	    'processImports',   // option & context - whether to process imports. if false then imports will not be imported.
	                        // Used by the import manager to stop multiple import visitors being created.
	    'pluginManager'     // Used as the plugin manager for the session
	];

	contexts.Parse = function(options) {
	    copyFromOriginal(options, this, parseCopyProperties);

	    if (typeof this.paths === "string") { this.paths = [this.paths]; }
	};

	var evalCopyProperties = [
	    'paths',          // additional include paths
	    'compress',       // whether to compress
	    'ieCompat',       // whether to enforce IE compatibility (IE8 data-uri)
	    'strictMath',     // whether math has to be within parenthesis
	    'strictUnits',    // whether units need to evaluate correctly
	    'sourceMap',      // whether to output a source map
	    'importMultiple', // whether we are currently importing multiple copies
	    'urlArgs',        // whether to add args into url tokens
	    'javascriptEnabled',// option - whether JavaScript is enabled. if undefined, defaults to true
	    'pluginManager',  // Used as the plugin manager for the session
	    'importantScope'  // used to bubble up !important statements
	    ];

	contexts.Eval = function(options, frames) {
	    copyFromOriginal(options, this, evalCopyProperties);

	    if (typeof this.paths === "string") { this.paths = [this.paths]; }

	    this.frames = frames || [];
	    this.importantScope = this.importantScope || [];
	};

	contexts.Eval.prototype.inParenthesis = function () {
	    if (!this.parensStack) {
	        this.parensStack = [];
	    }
	    this.parensStack.push(true);
	};

	contexts.Eval.prototype.outOfParenthesis = function () {
	    this.parensStack.pop();
	};

	contexts.Eval.prototype.isMathOn = function () {
	    return this.strictMath ? (this.parensStack && this.parensStack.length) : true;
	};

	contexts.Eval.prototype.isPathRelative = function (path) {
	    return !/^(?:[a-z-]+:|\/|#)/i.test(path);
	};

	contexts.Eval.prototype.normalizePath = function( path ) {
	    var
	      segments = path.split("/").reverse(),
	      segment;

	    path = [];
	    while (segments.length !== 0 ) {
	        segment = segments.pop();
	        switch( segment ) {
	            case ".":
	                break;
	            case "..":
	                if ((path.length === 0) || (path[path.length - 1] === "..")) {
	                    path.push( segment );
	                } else {
	                    path.pop();
	                }
	                break;
	            default:
	                path.push( segment );
	                break;
	        }
	    }

	    return path.join("/");
	};

	//todo - do the same for the toCSS ?

	},{}],12:[function(require,module,exports){
	module.exports = {
	    'aliceblue':'#f0f8ff',
	    'antiquewhite':'#faebd7',
	    'aqua':'#00ffff',
	    'aquamarine':'#7fffd4',
	    'azure':'#f0ffff',
	    'beige':'#f5f5dc',
	    'bisque':'#ffe4c4',
	    'black':'#000000',
	    'blanchedalmond':'#ffebcd',
	    'blue':'#0000ff',
	    'blueviolet':'#8a2be2',
	    'brown':'#a52a2a',
	    'burlywood':'#deb887',
	    'cadetblue':'#5f9ea0',
	    'chartreuse':'#7fff00',
	    'chocolate':'#d2691e',
	    'coral':'#ff7f50',
	    'cornflowerblue':'#6495ed',
	    'cornsilk':'#fff8dc',
	    'crimson':'#dc143c',
	    'cyan':'#00ffff',
	    'darkblue':'#00008b',
	    'darkcyan':'#008b8b',
	    'darkgoldenrod':'#b8860b',
	    'darkgray':'#a9a9a9',
	    'darkgrey':'#a9a9a9',
	    'darkgreen':'#006400',
	    'darkkhaki':'#bdb76b',
	    'darkmagenta':'#8b008b',
	    'darkolivegreen':'#556b2f',
	    'darkorange':'#ff8c00',
	    'darkorchid':'#9932cc',
	    'darkred':'#8b0000',
	    'darksalmon':'#e9967a',
	    'darkseagreen':'#8fbc8f',
	    'darkslateblue':'#483d8b',
	    'darkslategray':'#2f4f4f',
	    'darkslategrey':'#2f4f4f',
	    'darkturquoise':'#00ced1',
	    'darkviolet':'#9400d3',
	    'deeppink':'#ff1493',
	    'deepskyblue':'#00bfff',
	    'dimgray':'#696969',
	    'dimgrey':'#696969',
	    'dodgerblue':'#1e90ff',
	    'firebrick':'#b22222',
	    'floralwhite':'#fffaf0',
	    'forestgreen':'#228b22',
	    'fuchsia':'#ff00ff',
	    'gainsboro':'#dcdcdc',
	    'ghostwhite':'#f8f8ff',
	    'gold':'#ffd700',
	    'goldenrod':'#daa520',
	    'gray':'#808080',
	    'grey':'#808080',
	    'green':'#008000',
	    'greenyellow':'#adff2f',
	    'honeydew':'#f0fff0',
	    'hotpink':'#ff69b4',
	    'indianred':'#cd5c5c',
	    'indigo':'#4b0082',
	    'ivory':'#fffff0',
	    'khaki':'#f0e68c',
	    'lavender':'#e6e6fa',
	    'lavenderblush':'#fff0f5',
	    'lawngreen':'#7cfc00',
	    'lemonchiffon':'#fffacd',
	    'lightblue':'#add8e6',
	    'lightcoral':'#f08080',
	    'lightcyan':'#e0ffff',
	    'lightgoldenrodyellow':'#fafad2',
	    'lightgray':'#d3d3d3',
	    'lightgrey':'#d3d3d3',
	    'lightgreen':'#90ee90',
	    'lightpink':'#ffb6c1',
	    'lightsalmon':'#ffa07a',
	    'lightseagreen':'#20b2aa',
	    'lightskyblue':'#87cefa',
	    'lightslategray':'#778899',
	    'lightslategrey':'#778899',
	    'lightsteelblue':'#b0c4de',
	    'lightyellow':'#ffffe0',
	    'lime':'#00ff00',
	    'limegreen':'#32cd32',
	    'linen':'#faf0e6',
	    'magenta':'#ff00ff',
	    'maroon':'#800000',
	    'mediumaquamarine':'#66cdaa',
	    'mediumblue':'#0000cd',
	    'mediumorchid':'#ba55d3',
	    'mediumpurple':'#9370d8',
	    'mediumseagreen':'#3cb371',
	    'mediumslateblue':'#7b68ee',
	    'mediumspringgreen':'#00fa9a',
	    'mediumturquoise':'#48d1cc',
	    'mediumvioletred':'#c71585',
	    'midnightblue':'#191970',
	    'mintcream':'#f5fffa',
	    'mistyrose':'#ffe4e1',
	    'moccasin':'#ffe4b5',
	    'navajowhite':'#ffdead',
	    'navy':'#000080',
	    'oldlace':'#fdf5e6',
	    'olive':'#808000',
	    'olivedrab':'#6b8e23',
	    'orange':'#ffa500',
	    'orangered':'#ff4500',
	    'orchid':'#da70d6',
	    'palegoldenrod':'#eee8aa',
	    'palegreen':'#98fb98',
	    'paleturquoise':'#afeeee',
	    'palevioletred':'#d87093',
	    'papayawhip':'#ffefd5',
	    'peachpuff':'#ffdab9',
	    'peru':'#cd853f',
	    'pink':'#ffc0cb',
	    'plum':'#dda0dd',
	    'powderblue':'#b0e0e6',
	    'purple':'#800080',
	    'rebeccapurple':'#663399',
	    'red':'#ff0000',
	    'rosybrown':'#bc8f8f',
	    'royalblue':'#4169e1',
	    'saddlebrown':'#8b4513',
	    'salmon':'#fa8072',
	    'sandybrown':'#f4a460',
	    'seagreen':'#2e8b57',
	    'seashell':'#fff5ee',
	    'sienna':'#a0522d',
	    'silver':'#c0c0c0',
	    'skyblue':'#87ceeb',
	    'slateblue':'#6a5acd',
	    'slategray':'#708090',
	    'slategrey':'#708090',
	    'snow':'#fffafa',
	    'springgreen':'#00ff7f',
	    'steelblue':'#4682b4',
	    'tan':'#d2b48c',
	    'teal':'#008080',
	    'thistle':'#d8bfd8',
	    'tomato':'#ff6347',
	    'turquoise':'#40e0d0',
	    'violet':'#ee82ee',
	    'wheat':'#f5deb3',
	    'white':'#ffffff',
	    'whitesmoke':'#f5f5f5',
	    'yellow':'#ffff00',
	    'yellowgreen':'#9acd32'
	};
	},{}],13:[function(require,module,exports){
	module.exports = {
	    colors: require("./colors"),
	    unitConversions: require("./unit-conversions")
	};

	},{"./colors":12,"./unit-conversions":14}],14:[function(require,module,exports){
	module.exports = {
	    length: {
	        'm': 1,
	        'cm': 0.01,
	        'mm': 0.001,
	        'in': 0.0254,
	        'px': 0.0254 / 96,
	        'pt': 0.0254 / 72,
	        'pc': 0.0254 / 72 * 12
	    },
	    duration: {
	        's': 1,
	        'ms': 0.001
	    },
	    angle: {
	        'rad': 1 / (2 * Math.PI),
	        'deg': 1 / 360,
	        'grad': 1 / 400,
	        'turn': 1
	    }
	};
	},{}],15:[function(require,module,exports){
	var abstractFileManager = function() {
	};

	abstractFileManager.prototype.getPath = function (filename) {
	    var j = filename.lastIndexOf('?');
	    if (j > 0) {
	        filename = filename.slice(0, j);
	    }
	    j = filename.lastIndexOf('/');
	    if (j < 0) {
	        j = filename.lastIndexOf('\\');
	    }
	    if (j < 0) {
	        return "";
	    }
	    return filename.slice(0, j + 1);
	};

	abstractFileManager.prototype.tryAppendExtension = function(path, ext) {
	    return /(\.[a-z]*$)|([\?;].*)$/.test(path) ? path : path + ext;
	};

	abstractFileManager.prototype.tryAppendLessExtension = function(path) {
	    return this.tryAppendExtension(path, '.less');
	};

	abstractFileManager.prototype.supportsSync = function() {
	    return false;
	};

	abstractFileManager.prototype.alwaysMakePathsAbsolute = function() {
	    return false;
	};

	abstractFileManager.prototype.isPathAbsolute = function(filename) {
	    return (/^(?:[a-z-]+:|\/|\\|#)/i).test(filename);
	};

	abstractFileManager.prototype.join = function(basePath, laterPath) {
	    if (!basePath) {
	        return laterPath;
	    }
	    return basePath + laterPath;
	};
	abstractFileManager.prototype.pathDiff = function pathDiff(url, baseUrl) {
	    // diff between two paths to create a relative path

	    var urlParts = this.extractUrlParts(url),
	        baseUrlParts = this.extractUrlParts(baseUrl),
	        i, max, urlDirectories, baseUrlDirectories, diff = "";
	    if (urlParts.hostPart !== baseUrlParts.hostPart) {
	        return "";
	    }
	    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
	    for (i = 0; i < max; i++) {
	        if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }
	    }
	    baseUrlDirectories = baseUrlParts.directories.slice(i);
	    urlDirectories = urlParts.directories.slice(i);
	    for (i = 0; i < baseUrlDirectories.length - 1; i++) {
	        diff += "../";
	    }
	    for (i = 0; i < urlDirectories.length - 1; i++) {
	        diff += urlDirectories[i] + "/";
	    }
	    return diff;
	};
	// helper function, not part of API
	abstractFileManager.prototype.extractUrlParts = function extractUrlParts(url, baseUrl) {
	    // urlParts[1] = protocol&hostname || /
	    // urlParts[2] = / if path relative to host base
	    // urlParts[3] = directories
	    // urlParts[4] = filename
	    // urlParts[5] = parameters

	    var urlPartsRegex = /^((?:[a-z-]+:)?\/+?(?:[^\/\?#]*\/)|([\/\\]))?((?:[^\/\\\?#]*[\/\\])*)([^\/\\\?#]*)([#\?].*)?$/i,
	        urlParts = url.match(urlPartsRegex),
	        returner = {}, directories = [], i, baseUrlParts;

	    if (!urlParts) {
	        throw new Error("Could not parse sheet href - '" + url + "'");
	    }

	    // Stylesheets in IE don't always return the full path
	    if (baseUrl && (!urlParts[1] || urlParts[2])) {
	        baseUrlParts = baseUrl.match(urlPartsRegex);
	        if (!baseUrlParts) {
	            throw new Error("Could not parse page url - '" + baseUrl + "'");
	        }
	        urlParts[1] = urlParts[1] || baseUrlParts[1] || "";
	        if (!urlParts[2]) {
	            urlParts[3] = baseUrlParts[3] + urlParts[3];
	        }
	    }

	    if (urlParts[3]) {
	        directories = urlParts[3].replace(/\\/g, "/").split("/");

	        // extract out . before .. so .. doesn't absorb a non-directory
	        for (i = 0; i < directories.length; i++) {
	            if (directories[i] === ".") {
	                directories.splice(i, 1);
	                i -= 1;
	            }
	        }

	        for (i = 0; i < directories.length; i++) {
	            if (directories[i] === ".." && i > 0) {
	                directories.splice(i - 1, 2);
	                i -= 2;
	            }
	        }
	    }

	    returner.hostPart = urlParts[1];
	    returner.directories = directories;
	    returner.path = (urlParts[1] || "") + directories.join("/");
	    returner.fileUrl = returner.path + (urlParts[4] || "");
	    returner.url = returner.fileUrl + (urlParts[5] || "");
	    return returner;
	};

	module.exports = abstractFileManager;

	},{}],16:[function(require,module,exports){
	var logger = require("../logger");
	var environment = function(externalEnvironment, fileManagers) {
	    this.fileManagers = fileManagers || [];
	    externalEnvironment = externalEnvironment || {};

	    var optionalFunctions = ["encodeBase64", "mimeLookup", "charsetLookup", "getSourceMapGenerator"],
	        requiredFunctions = [],
	        functions = requiredFunctions.concat(optionalFunctions);

	    for (var i = 0; i < functions.length; i++) {
	        var propName = functions[i],
	            environmentFunc = externalEnvironment[propName];
	        if (environmentFunc) {
	            this[propName] = environmentFunc.bind(externalEnvironment);
	        } else if (i < requiredFunctions.length) {
	            this.warn("missing required function in environment - " + propName);
	        }
	    }
	};

	environment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {

	    if (!filename) {
	        logger.warn("getFileManager called with no filename.. Please report this issue. continuing.");
	    }
	    if (currentDirectory == null) {
	        logger.warn("getFileManager called with null directory.. Please report this issue. continuing.");
	    }

	    var fileManagers = this.fileManagers;
	    if (options.pluginManager) {
	        fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());
	    }
	    for (var i = fileManagers.length - 1; i >= 0 ; i--) {
	        var fileManager = fileManagers[i];
	        if (fileManager[isSync ? "supportsSync" : "supports"](filename, currentDirectory, options, environment)) {
	            return fileManager;
	        }
	    }
	    return null;
	};

	environment.prototype.addFileManager = function (fileManager) {
	    this.fileManagers.push(fileManager);
	};

	environment.prototype.clearFileManagers = function () {
	    this.fileManagers = [];
	};

	module.exports = environment;

	},{"../logger":33}],17:[function(require,module,exports){
	var Color = require("../tree/color"),
	    functionRegistry = require("./function-registry");

	// Color Blending
	// ref: http://www.w3.org/TR/compositing-1

	function colorBlend(mode, color1, color2) {
	    var ab = color1.alpha, cb, // backdrop
	        as = color2.alpha, cs, // source
	        ar, cr, r = [];        // result

	    ar = as + ab * (1 - as);
	    for (var i = 0; i < 3; i++) {
	        cb = color1.rgb[i] / 255;
	        cs = color2.rgb[i] / 255;
	        cr = mode(cb, cs);
	        if (ar) {
	            cr = (as * cs + ab * (cb -
	                  as * (cb + cs - cr))) / ar;
	        }
	        r[i] = cr * 255;
	    }

	    return new Color(r, ar);
	}

	var colorBlendModeFunctions = {
	    multiply: function(cb, cs) {
	        return cb * cs;
	    },
	    screen: function(cb, cs) {
	        return cb + cs - cb * cs;
	    },
	    overlay: function(cb, cs) {
	        cb *= 2;
	        return (cb <= 1) ?
	            colorBlendModeFunctions.multiply(cb, cs) :
	            colorBlendModeFunctions.screen(cb - 1, cs);
	    },
	    softlight: function(cb, cs) {
	        var d = 1, e = cb;
	        if (cs > 0.5) {
	            e = 1;
	            d = (cb > 0.25) ? Math.sqrt(cb)
	                : ((16 * cb - 12) * cb + 4) * cb;
	        }
	        return cb - (1 - 2 * cs) * e * (d - cb);
	    },
	    hardlight: function(cb, cs) {
	        return colorBlendModeFunctions.overlay(cs, cb);
	    },
	    difference: function(cb, cs) {
	        return Math.abs(cb - cs);
	    },
	    exclusion: function(cb, cs) {
	        return cb + cs - 2 * cb * cs;
	    },

	    // non-w3c functions:
	    average: function(cb, cs) {
	        return (cb + cs) / 2;
	    },
	    negation: function(cb, cs) {
	        return 1 - Math.abs(cb + cs - 1);
	    }
	};

	for (var f in colorBlendModeFunctions) {
	    if (colorBlendModeFunctions.hasOwnProperty(f)) {
	        colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);
	    }
	}

	functionRegistry.addMultiple(colorBlend);

	},{"../tree/color":50,"./function-registry":22}],18:[function(require,module,exports){
	var Dimension = require("../tree/dimension"),
	    Color = require("../tree/color"),
	    Quoted = require("../tree/quoted"),
	    Anonymous = require("../tree/anonymous"),
	    functionRegistry = require("./function-registry"),
	    colorFunctions;

	function clamp(val) {
	    return Math.min(1, Math.max(0, val));
	}
	function hsla(color) {
	    return colorFunctions.hsla(color.h, color.s, color.l, color.a);
	}
	function number(n) {
	    if (n instanceof Dimension) {
	        return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);
	    } else if (typeof n === 'number') {
	        return n;
	    } else {
	        throw {
	            type: "Argument",
	            message: "color functions take numbers as parameters"
	        };
	    }
	}
	function scaled(n, size) {
	    if (n instanceof Dimension && n.unit.is('%')) {
	        return parseFloat(n.value * size / 100);
	    } else {
	        return number(n);
	    }
	}
	colorFunctions = {
	    rgb: function (r, g, b) {
	        return colorFunctions.rgba(r, g, b, 1.0);
	    },
	    rgba: function (r, g, b, a) {
	        var rgb = [r, g, b].map(function (c) { return scaled(c, 255); });
	        a = number(a);
	        return new Color(rgb, a);
	    },
	    hsl: function (h, s, l) {
	        return colorFunctions.hsla(h, s, l, 1.0);
	    },
	    hsla: function (h, s, l, a) {
	        function hue(h) {
	            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
	            if (h * 6 < 1) {
	                return m1 + (m2 - m1) * h * 6;
	            }
	            else if (h * 2 < 1) {
	                return m2;
	            }
	            else if (h * 3 < 2) {
	                return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	            }
	            else {
	                return m1;
	            }
	        }

	        h = (number(h) % 360) / 360;
	        s = clamp(number(s)); l = clamp(number(l)); a = clamp(number(a));

	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;

	        return colorFunctions.rgba(hue(h + 1 / 3) * 255,
	            hue(h)       * 255,
	            hue(h - 1 / 3) * 255,
	            a);
	    },

	    hsv: function(h, s, v) {
	        return colorFunctions.hsva(h, s, v, 1.0);
	    },

	    hsva: function(h, s, v, a) {
	        h = ((number(h) % 360) / 360) * 360;
	        s = number(s); v = number(v); a = number(a);

	        var i, f;
	        i = Math.floor((h / 60) % 6);
	        f = (h / 60) - i;

	        var vs = [v,
	            v * (1 - s),
	            v * (1 - f * s),
	            v * (1 - (1 - f) * s)];
	        var perm = [[0, 3, 1],
	            [2, 0, 1],
	            [1, 0, 3],
	            [1, 2, 0],
	            [3, 1, 0],
	            [0, 1, 2]];

	        return colorFunctions.rgba(vs[perm[i][0]] * 255,
	            vs[perm[i][1]] * 255,
	            vs[perm[i][2]] * 255,
	            a);
	    },

	    hue: function (color) {
	        return new Dimension(color.toHSL().h);
	    },
	    saturation: function (color) {
	        return new Dimension(color.toHSL().s * 100, '%');
	    },
	    lightness: function (color) {
	        return new Dimension(color.toHSL().l * 100, '%');
	    },
	    hsvhue: function(color) {
	        return new Dimension(color.toHSV().h);
	    },
	    hsvsaturation: function (color) {
	        return new Dimension(color.toHSV().s * 100, '%');
	    },
	    hsvvalue: function (color) {
	        return new Dimension(color.toHSV().v * 100, '%');
	    },
	    red: function (color) {
	        return new Dimension(color.rgb[0]);
	    },
	    green: function (color) {
	        return new Dimension(color.rgb[1]);
	    },
	    blue: function (color) {
	        return new Dimension(color.rgb[2]);
	    },
	    alpha: function (color) {
	        return new Dimension(color.toHSL().a);
	    },
	    luma: function (color) {
	        return new Dimension(color.luma() * color.alpha * 100, '%');
	    },
	    luminance: function (color) {
	        var luminance =
	            (0.2126 * color.rgb[0] / 255) +
	                (0.7152 * color.rgb[1] / 255) +
	                (0.0722 * color.rgb[2] / 255);

	        return new Dimension(luminance * color.alpha * 100, '%');
	    },
	    saturate: function (color, amount, method) {
	        // filter: saturate(3.2);
	        // should be kept as is, so check for color
	        if (!color.rgb) {
	            return null;
	        }
	        var hsl = color.toHSL();

	        if (typeof method !== "undefined" && method.value === "relative") {
	            hsl.s +=  hsl.s * amount.value / 100;
	        }
	        else {
	            hsl.s += amount.value / 100;
	        }
	        hsl.s = clamp(hsl.s);
	        return hsla(hsl);
	    },
	    desaturate: function (color, amount, method) {
	        var hsl = color.toHSL();

	        if (typeof method !== "undefined" && method.value === "relative") {
	            hsl.s -=  hsl.s * amount.value / 100;
	        }
	        else {
	            hsl.s -= amount.value / 100;
	        }
	        hsl.s = clamp(hsl.s);
	        return hsla(hsl);
	    },
	    lighten: function (color, amount, method) {
	        var hsl = color.toHSL();

	        if (typeof method !== "undefined" && method.value === "relative") {
	            hsl.l +=  hsl.l * amount.value / 100;
	        }
	        else {
	            hsl.l += amount.value / 100;
	        }
	        hsl.l = clamp(hsl.l);
	        return hsla(hsl);
	    },
	    darken: function (color, amount, method) {
	        var hsl = color.toHSL();

	        if (typeof method !== "undefined" && method.value === "relative") {
	            hsl.l -=  hsl.l * amount.value / 100;
	        }
	        else {
	            hsl.l -= amount.value / 100;
	        }
	        hsl.l = clamp(hsl.l);
	        return hsla(hsl);
	    },
	    fadein: function (color, amount, method) {
	        var hsl = color.toHSL();

	        if (typeof method !== "undefined" && method.value === "relative") {
	            hsl.a +=  hsl.a * amount.value / 100;
	        }
	        else {
	            hsl.a += amount.value / 100;
	        }
	        hsl.a = clamp(hsl.a);
	        return hsla(hsl);
	    },
	    fadeout: function (color, amount, method) {
	        var hsl = color.toHSL();

	        if (typeof method !== "undefined" && method.value === "relative") {
	            hsl.a -=  hsl.a * amount.value / 100;
	        }
	        else {
	            hsl.a -= amount.value / 100;
	        }
	        hsl.a = clamp(hsl.a);
	        return hsla(hsl);
	    },
	    fade: function (color, amount) {
	        var hsl = color.toHSL();

	        hsl.a = amount.value / 100;
	        hsl.a = clamp(hsl.a);
	        return hsla(hsl);
	    },
	    spin: function (color, amount) {
	        var hsl = color.toHSL();
	        var hue = (hsl.h + amount.value) % 360;

	        hsl.h = hue < 0 ? 360 + hue : hue;

	        return hsla(hsl);
	    },
	    //
	    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein
	    // http://sass-lang.com
	    //
	    mix: function (color1, color2, weight) {
	        if (!color1.toHSL || !color2.toHSL) {
	            console.log(color2.type);
	            console.dir(color2);
	        }
	        if (!weight) {
	            weight = new Dimension(50);
	        }
	        var p = weight.value / 100.0;
	        var w = p * 2 - 1;
	        var a = color1.toHSL().a - color2.toHSL().a;

	        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
	        var w2 = 1 - w1;

	        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
	            color1.rgb[1] * w1 + color2.rgb[1] * w2,
	            color1.rgb[2] * w1 + color2.rgb[2] * w2];

	        var alpha = color1.alpha * p + color2.alpha * (1 - p);

	        return new Color(rgb, alpha);
	    },
	    greyscale: function (color) {
	        return colorFunctions.desaturate(color, new Dimension(100));
	    },
	    contrast: function (color, dark, light, threshold) {
	        // filter: contrast(3.2);
	        // should be kept as is, so check for color
	        if (!color.rgb) {
	            return null;
	        }
	        if (typeof light === 'undefined') {
	            light = colorFunctions.rgba(255, 255, 255, 1.0);
	        }
	        if (typeof dark === 'undefined') {
	            dark = colorFunctions.rgba(0, 0, 0, 1.0);
	        }
	        //Figure out which is actually light and dark!
	        if (dark.luma() > light.luma()) {
	            var t = light;
	            light = dark;
	            dark = t;
	        }
	        if (typeof threshold === 'undefined') {
	            threshold = 0.43;
	        } else {
	            threshold = number(threshold);
	        }
	        if (color.luma() < threshold) {
	            return light;
	        } else {
	            return dark;
	        }
	    },
	    argb: function (color) {
	        return new Anonymous(color.toARGB());
	    },
	    color: function(c) {
	        if ((c instanceof Quoted) &&
	            (/^#([a-f0-9]{6}|[a-f0-9]{3})$/i.test(c.value))) {
	            return new Color(c.value.slice(1));
	        }
	        if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {
	            c.value = undefined;
	            return c;
	        }
	        throw {
	            type:    "Argument",
	            message: "argument must be a color keyword or 3/6 digit hex e.g. #FFF"
	        };
	    },
	    tint: function(color, amount) {
	        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);
	    },
	    shade: function(color, amount) {
	        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);
	    }
	};
	functionRegistry.addMultiple(colorFunctions);

	},{"../tree/anonymous":46,"../tree/color":50,"../tree/dimension":56,"../tree/quoted":73,"./function-registry":22}],19:[function(require,module,exports){
	module.exports = function(environment) {
	    var Quoted = require("../tree/quoted"),
	        URL = require("../tree/url"),
	        functionRegistry = require("./function-registry"),
	        fallback = function(functionThis, node) {
	            return new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);
	        },
	        logger = require('../logger');

	    functionRegistry.add("data-uri", function(mimetypeNode, filePathNode) {

	        if (!filePathNode) {
	            filePathNode = mimetypeNode;
	            mimetypeNode = null;
	        }

	        var mimetype = mimetypeNode && mimetypeNode.value;
	        var filePath = filePathNode.value;
	        var currentFileInfo = this.currentFileInfo;
	        var currentDirectory = currentFileInfo.relativeUrls ?
	            currentFileInfo.currentDirectory : currentFileInfo.entryPath;

	        var fragmentStart = filePath.indexOf('#');
	        var fragment = '';
	        if (fragmentStart !== -1) {
	            fragment = filePath.slice(fragmentStart);
	            filePath = filePath.slice(0, fragmentStart);
	        }

	        var fileManager = environment.getFileManager(filePath, currentDirectory, this.context, environment, true);

	        if (!fileManager) {
	            return fallback(this, filePathNode);
	        }

	        var useBase64 = false;

	        // detect the mimetype if not given
	        if (!mimetypeNode) {

	            mimetype = environment.mimeLookup(filePath);

	            if (mimetype === "image/svg+xml") {
	                useBase64 = false;
	            } else {
	                // use base 64 unless it's an ASCII or UTF-8 format
	                var charset = environment.charsetLookup(mimetype);
	                useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;
	            }
	            if (useBase64) { mimetype += ';base64'; }
	        }
	        else {
	            useBase64 = /;base64$/.test(mimetype);
	        }

	        var fileSync = fileManager.loadFileSync(filePath, currentDirectory, this.context, environment);
	        if (!fileSync.contents) {
	            logger.warn("Skipped data-uri embedding of " + filePath + " because file not found");
	            return fallback(this, filePathNode || mimetypeNode);
	        }
	        var buf = fileSync.contents;
	        if (useBase64 && !environment.encodeBase64) {
	            return fallback(this, filePathNode);
	        }

	        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);

	        var uri = "data:" + mimetype + ',' + buf + fragment;

	        // IE8 cannot handle a data-uri larger than 32,768 characters. If this is exceeded
	        // and the --ieCompat flag is enabled, return a normal url() instead.
	        var DATA_URI_MAX = 32768;
	        if (uri.length >= DATA_URI_MAX) {

	            if (this.context.ieCompat !== false) {
	                logger.warn("Skipped data-uri embedding of " + filePath + " because its size (" + uri.length +
	                    " characters) exceeds IE8-safe " + DATA_URI_MAX + " characters!");

	                return fallback(this, filePathNode || mimetypeNode);
	            }
	        }

	        return new URL(new Quoted('"' + uri + '"', uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
	    });
	};

	},{"../logger":33,"../tree/quoted":73,"../tree/url":80,"./function-registry":22}],20:[function(require,module,exports){
	var Keyword = require("../tree/keyword"),
	    functionRegistry = require("./function-registry");

	var defaultFunc = {
	    eval: function () {
	        var v = this.value_, e = this.error_;
	        if (e) {
	            throw e;
	        }
	        if (v != null) {
	            return v ? Keyword.True : Keyword.False;
	        }
	    },
	    value: function (v) {
	        this.value_ = v;
	    },
	    error: function (e) {
	        this.error_ = e;
	    },
	    reset: function () {
	        this.value_ = this.error_ = null;
	    }
	};

	functionRegistry.add("default", defaultFunc.eval.bind(defaultFunc));

	module.exports = defaultFunc;

	},{"../tree/keyword":65,"./function-registry":22}],21:[function(require,module,exports){
	var Expression = require("../tree/expression");

	var functionCaller = function(name, context, index, currentFileInfo) {
	    this.name = name.toLowerCase();
	    this.index = index;
	    this.context = context;
	    this.currentFileInfo = currentFileInfo;

	    this.func = context.frames[0].functionRegistry.get(this.name);
	};
	functionCaller.prototype.isValid = function() {
	    return Boolean(this.func);
	};
	functionCaller.prototype.call = function(args) {

	    // This code is terrible and should be replaced as per this issue...
	    // https://github.com/less/less.js/issues/2477
	    if (Array.isArray(args)) {
	        args = args.filter(function (item) {
	            if (item.type === "Comment") {
	                return false;
	            }
	            return true;
	        })
	        .map(function(item) {
	            if (item.type === "Expression") {
	                var subNodes = item.value.filter(function (item) {
	                    if (item.type === "Comment") {
	                        return false;
	                    }
	                    return true;
	                });
	                if (subNodes.length === 1) {
	                    return subNodes[0];
	                } else {
	                    return new Expression(subNodes);
	                }
	            }
	            return item;
	        });
	    }

	    return this.func.apply(this, args);
	};

	module.exports = functionCaller;

	},{"../tree/expression":59}],22:[function(require,module,exports){
	function makeRegistry( base ) {
	    return {
	        _data: {},
	        add: function(name, func) {
	            // precautionary case conversion, as later querying of
	            // the registry by function-caller uses lower case as well.
	            name = name.toLowerCase();

	            if (this._data.hasOwnProperty(name)) {
	                //TODO warn
	            }
	            this._data[name] = func;
	        },
	        addMultiple: function(functions) {
	            Object.keys(functions).forEach(
	                function(name) {
	                    this.add(name, functions[name]);
	                }.bind(this));
	        },
	        get: function(name) {
	            return this._data[name] || ( base && base.get( name ));
	        },
	        inherit : function() {
	            return makeRegistry( this );
	        }
	    };
	}

	module.exports = makeRegistry( null );
	},{}],23:[function(require,module,exports){
	module.exports = function(environment) {
	    var functions = {
	        functionRegistry: require("./function-registry"),
	        functionCaller: require("./function-caller")
	    };

	    //register functions
	    require("./default");
	    require("./color");
	    require("./color-blending");
	    require("./data-uri")(environment);
	    require("./math");
	    require("./number");
	    require("./string");
	    require("./svg")(environment);
	    require("./types");

	    return functions;
	};

	},{"./color":18,"./color-blending":17,"./data-uri":19,"./default":20,"./function-caller":21,"./function-registry":22,"./math":25,"./number":26,"./string":27,"./svg":28,"./types":29}],24:[function(require,module,exports){
	var Dimension = require("../tree/dimension");

	var MathHelper = function() {
	};
	MathHelper._math = function (fn, unit, n) {
	    if (!(n instanceof Dimension)) {
	        throw { type: "Argument", message: "argument must be a number" };
	    }
	    if (unit == null) {
	        unit = n.unit;
	    } else {
	        n = n.unify();
	    }
	    return new Dimension(fn(parseFloat(n.value)), unit);
	};
	module.exports = MathHelper;
	},{"../tree/dimension":56}],25:[function(require,module,exports){
	var functionRegistry = require("./function-registry"),
	    mathHelper = require("./math-helper.js");

	var mathFunctions = {
	    // name,  unit
	    ceil:  null,
	    floor: null,
	    sqrt:  null,
	    abs:   null,
	    tan:   "",
	    sin:   "",
	    cos:   "",
	    atan:  "rad",
	    asin:  "rad",
	    acos:  "rad"
	};

	for (var f in mathFunctions) {
	    if (mathFunctions.hasOwnProperty(f)) {
	        mathFunctions[f] = mathHelper._math.bind(null, Math[f], mathFunctions[f]);
	    }
	}

	mathFunctions.round = function (n, f) {
	    var fraction = typeof f === "undefined" ? 0 : f.value;
	    return mathHelper._math(function(num) { return num.toFixed(fraction); }, null, n);
	};

	functionRegistry.addMultiple(mathFunctions);

	},{"./function-registry":22,"./math-helper.js":24}],26:[function(require,module,exports){
	var Dimension = require("../tree/dimension"),
	    Anonymous = require("../tree/anonymous"),
	    functionRegistry = require("./function-registry"),
	    mathHelper = require("./math-helper.js");

	var minMax = function (isMin, args) {
	    args = Array.prototype.slice.call(args);
	    switch(args.length) {
	        case 0: throw { type: "Argument", message: "one or more arguments required" };
	    }
	    var i, j, current, currentUnified, referenceUnified, unit, unitStatic, unitClone,
	        order  = [], // elems only contains original argument values.
	        values = {}; // key is the unit.toString() for unified Dimension values,
	    // value is the index into the order array.
	    for (i = 0; i < args.length; i++) {
	        current = args[i];
	        if (!(current instanceof Dimension)) {
	            if (Array.isArray(args[i].value)) {
	                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));
	            }
	            continue;
	        }
	        currentUnified = current.unit.toString() === "" && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();
	        unit = currentUnified.unit.toString() === "" && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();
	        unitStatic = unit !== "" && unitStatic === undefined || unit !== "" && order[0].unify().unit.toString() === "" ? unit : unitStatic;
	        unitClone = unit !== "" && unitClone === undefined ? current.unit.toString() : unitClone;
	        j = values[""] !== undefined && unit !== "" && unit === unitStatic ? values[""] : values[unit];
	        if (j === undefined) {
	            if (unitStatic !== undefined && unit !== unitStatic) {
	                throw{ type: "Argument", message: "incompatible types" };
	            }
	            values[unit] = order.length;
	            order.push(current);
	            continue;
	        }
	        referenceUnified = order[j].unit.toString() === "" && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();
	        if ( isMin && currentUnified.value < referenceUnified.value ||
	            !isMin && currentUnified.value > referenceUnified.value) {
	            order[j] = current;
	        }
	    }
	    if (order.length == 1) {
	        return order[0];
	    }
	    args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? "," : ", ");
	    return new Anonymous((isMin ? "min" : "max") + "(" + args + ")");
	};
	functionRegistry.addMultiple({
	    min: function () {
	        return minMax(true, arguments);
	    },
	    max: function () {
	        return minMax(false, arguments);
	    },
	    convert: function (val, unit) {
	        return val.convertTo(unit.value);
	    },
	    pi: function () {
	        return new Dimension(Math.PI);
	    },
	    mod: function(a, b) {
	        return new Dimension(a.value % b.value, a.unit);
	    },
	    pow: function(x, y) {
	        if (typeof x === "number" && typeof y === "number") {
	            x = new Dimension(x);
	            y = new Dimension(y);
	        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {
	            throw { type: "Argument", message: "arguments must be numbers" };
	        }

	        return new Dimension(Math.pow(x.value, y.value), x.unit);
	    },
	    percentage: function (n) {
	        var result = mathHelper._math(function(num) {
	            return num * 100;
	        }, '%', n);

	        return result;
	    }
	});

	},{"../tree/anonymous":46,"../tree/dimension":56,"./function-registry":22,"./math-helper.js":24}],27:[function(require,module,exports){
	var Quoted = require("../tree/quoted"),
	    Anonymous = require("../tree/anonymous"),
	    JavaScript = require("../tree/javascript"),
	    functionRegistry = require("./function-registry");

	functionRegistry.addMultiple({
	    e: function (str) {
	        return new Anonymous(str instanceof JavaScript ? str.evaluated : str.value);
	    },
	    escape: function (str) {
	        return new Anonymous(
	            encodeURI(str.value).replace(/=/g, "%3D").replace(/:/g, "%3A").replace(/#/g, "%23").replace(/;/g, "%3B")
	                .replace(/\(/g, "%28").replace(/\)/g, "%29"));
	    },
	    replace: function (string, pattern, replacement, flags) {
	        var result = string.value;
	        replacement = (replacement.type === "Quoted") ?
	            replacement.value : replacement.toCSS();
	        result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);
	        return new Quoted(string.quote || '', result, string.escaped);
	    },
	    '%': function (string /* arg, arg, ...*/) {
	        var args = Array.prototype.slice.call(arguments, 1),
	            result = string.value;

	        for (var i = 0; i < args.length; i++) {
	            /*jshint loopfunc:true */
	            result = result.replace(/%[sda]/i, function(token) {
	                var value = ((args[i].type === "Quoted") &&
	                    token.match(/s/i)) ? args[i].value : args[i].toCSS();
	                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;
	            });
	        }
	        result = result.replace(/%%/g, '%');
	        return new Quoted(string.quote || '', result, string.escaped);
	    }
	});

	},{"../tree/anonymous":46,"../tree/javascript":63,"../tree/quoted":73,"./function-registry":22}],28:[function(require,module,exports){
	module.exports = function(environment) {
	    var Dimension = require("../tree/dimension"),
	        Color = require("../tree/color"),
	        Expression = require("../tree/expression"),
	        Quoted = require("../tree/quoted"),
	        URL = require("../tree/url"),
	        functionRegistry = require("./function-registry");

	    functionRegistry.add("svg-gradient", function(direction) {

	        var stops,
	            gradientDirectionSvg,
	            gradientType = "linear",
	            rectangleDimension = 'x="0" y="0" width="1" height="1"',
	            renderEnv = {compress: false},
	            returner,
	            directionValue = direction.toCSS(renderEnv),
				i, color, position, positionValue, alpha;

	        function throwArgumentDescriptor() {
	            throw { type: "Argument",
						message: "svg-gradient expects direction, start_color [start_position], [color position,]...," +
								" end_color [end_position] or direction, color list" };
	        }

	        if (arguments.length == 2) {
	            if (arguments[1].value.length < 2) {
	                throwArgumentDescriptor();
	            }
	            stops = arguments[1].value;
	        } else if (arguments.length < 3) {
	            throwArgumentDescriptor();
	        } else {
	            stops = Array.prototype.slice.call(arguments, 1);
	        }

	        switch (directionValue) {
	            case "to bottom":
	                gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"';
	                break;
	            case "to right":
	                gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"';
	                break;
	            case "to bottom right":
	                gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"';
	                break;
	            case "to top right":
	                gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"';
	                break;
	            case "ellipse":
	            case "ellipse at center":
	                gradientType = "radial";
	                gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"';
	                rectangleDimension = 'x="-50" y="-50" width="101" height="101"';
	                break;
	            default:
	                throw { type: "Argument", message: "svg-gradient direction must be 'to bottom', 'to right'," +
	                    " 'to bottom right', 'to top right' or 'ellipse at center'" };
	        }
	        returner = '<?xml version="1.0" ?>' +
	            '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" viewBox="0 0 1 1" preserveAspectRatio="none">' +
	            '<' + gradientType + 'Gradient id="gradient" gradientUnits="userSpaceOnUse" ' + gradientDirectionSvg + '>';

	        for (i = 0; i < stops.length; i+= 1) {
	            if (stops[i] instanceof Expression) {
	                color = stops[i].value[0];
	                position = stops[i].value[1];
	            } else {
	                color = stops[i];
	                position = undefined;
	            }

	            if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {
	                throwArgumentDescriptor();
	            }
	            positionValue = position ? position.toCSS(renderEnv) : i === 0 ? "0%" : "100%";
	            alpha = color.alpha;
	            returner += '<stop offset="' + positionValue + '" stop-color="' + color.toRGB() + '"' + (alpha < 1 ? ' stop-opacity="' + alpha + '"' : '') + '/>';
	        }
	        returner += '</' + gradientType + 'Gradient>' +
	            '<rect ' + rectangleDimension + ' fill="url(#gradient)" /></svg>';

	        returner = encodeURIComponent(returner);

	        returner = "data:image/svg+xml," + returner;
	        return new URL(new Quoted("'" + returner + "'", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
	    });
	};

	},{"../tree/color":50,"../tree/dimension":56,"../tree/expression":59,"../tree/quoted":73,"../tree/url":80,"./function-registry":22}],29:[function(require,module,exports){
	var Keyword = require("../tree/keyword"),
	    DetachedRuleset = require("../tree/detached-ruleset"),
	    Dimension = require("../tree/dimension"),
	    Color = require("../tree/color"),
	    Quoted = require("../tree/quoted"),
	    Anonymous = require("../tree/anonymous"),
	    URL = require("../tree/url"),
	    Operation = require("../tree/operation"),
	    functionRegistry = require("./function-registry");

	var isa = function (n, Type) {
	        return (n instanceof Type) ? Keyword.True : Keyword.False;
	    },
	    isunit = function (n, unit) {
	        if (unit === undefined) {
	            throw { type: "Argument", message: "missing the required second argument to isunit." };
	        }
	        unit = typeof unit.value === "string" ? unit.value : unit;
	        if (typeof unit !== "string") {
	            throw { type: "Argument", message: "Second argument to isunit should be a unit or a string." };
	        }
	        return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;
	    },
	    getItemsFromNode = function(node) {
	        // handle non-array values as an array of length 1
	        // return 'undefined' if index is invalid
	        var items = Array.isArray(node.value) ?
	            node.value : Array(node);

	        return items;
	    };
	functionRegistry.addMultiple({
	    isruleset: function (n) {
	        return isa(n, DetachedRuleset);
	    },
	    iscolor: function (n) {
	        return isa(n, Color);
	    },
	    isnumber: function (n) {
	        return isa(n, Dimension);
	    },
	    isstring: function (n) {
	        return isa(n, Quoted);
	    },
	    iskeyword: function (n) {
	        return isa(n, Keyword);
	    },
	    isurl: function (n) {
	        return isa(n, URL);
	    },
	    ispixel: function (n) {
	        return isunit(n, 'px');
	    },
	    ispercentage: function (n) {
	        return isunit(n, '%');
	    },
	    isem: function (n) {
	        return isunit(n, 'em');
	    },
	    isunit: isunit,
	    unit: function (val, unit) {
	        if (!(val instanceof Dimension)) {
	            throw { type: "Argument",
	                message: "the first argument to unit must be a number" +
	                    (val instanceof Operation ? ". Have you forgotten parenthesis?" : "") };
	        }
	        if (unit) {
	            if (unit instanceof Keyword) {
	                unit = unit.value;
	            } else {
	                unit = unit.toCSS();
	            }
	        } else {
	            unit = "";
	        }
	        return new Dimension(val.value, unit);
	    },
	    "get-unit": function (n) {
	        return new Anonymous(n.unit);
	    },
	    extract: function(values, index) {
	        index = index.value - 1; // (1-based index)

	        return getItemsFromNode(values)[index];
	    },
	    length: function(values) {
	        return new Dimension(getItemsFromNode(values).length);
	    }
	});

	},{"../tree/anonymous":46,"../tree/color":50,"../tree/detached-ruleset":55,"../tree/dimension":56,"../tree/keyword":65,"../tree/operation":71,"../tree/quoted":73,"../tree/url":80,"./function-registry":22}],30:[function(require,module,exports){
	var contexts = require("./contexts"),
	    Parser = require('./parser/parser'),
	    FunctionImporter = require('./plugins/function-importer');

	module.exports = function(environment) {

	    // FileInfo = {
	    //  'relativeUrls' - option - whether to adjust URL's to be relative
	    //  'filename' - full resolved filename of current file
	    //  'rootpath' - path to append to normal URLs for this node
	    //  'currentDirectory' - path to the current file, absolute
	    //  'rootFilename' - filename of the base file
	    //  'entryPath' - absolute path to the entry file
	    //  'reference' - whether the file should not be output and only output parts that are referenced

	    var ImportManager = function(context, rootFileInfo) {
	        this.rootFilename = rootFileInfo.filename;
	        this.paths = context.paths || [];  // Search paths, when importing
	        this.contents = {};             // map - filename to contents of all the files
	        this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore
	        this.mime = context.mime;
	        this.error = null;
	        this.context = context;
	        // Deprecated? Unused outside of here, could be useful.
	        this.queue = [];        // Files which haven't been imported yet
	        this.files = {};        // Holds the imported parse trees.
	    };
	    /**
	     * Add an import to be imported
	     * @param path - the raw path
	     * @param tryAppendLessExtension - whether to try appending the less extension (if the path has no extension)
	     * @param currentFileInfo - the current file info (used for instance to work out relative paths)
	     * @param importOptions - import options
	     * @param callback - callback for when it is imported
	     */
	    ImportManager.prototype.push = function (path, tryAppendLessExtension, currentFileInfo, importOptions, callback) {
	        var importManager = this;
	        this.queue.push(path);

	        var fileParsedFunc = function (e, root, fullPath) {
	            importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue

	            var importedEqualsRoot = fullPath === importManager.rootFilename;
	            if (importOptions.optional && e) {
	                callback(null, {rules:[]}, false, null);
	            }
	            else {
	                importManager.files[fullPath] = root;
	                if (e && !importManager.error) { importManager.error = e; }
	                callback(e, root, importedEqualsRoot, fullPath);
	            }
	        };

	        var newFileInfo = {
	            relativeUrls: this.context.relativeUrls,
	            entryPath: currentFileInfo.entryPath,
	            rootpath: currentFileInfo.rootpath,
	            rootFilename: currentFileInfo.rootFilename
	        };

	        var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);

	        if (!fileManager) {
	            fileParsedFunc({ message: "Could not find a file-manager for " + path });
	            return;
	        }

	        if (tryAppendLessExtension) {
	            path = fileManager.tryAppendExtension(path, importOptions.plugin ? ".js" : ".less");
	        }

	        var loadFileCallback = function(loadedFile) {
	            var resolvedFilename = loadedFile.filename,
	                contents = loadedFile.contents.replace(/^\uFEFF/, '');

	            // Pass on an updated rootpath if path of imported file is relative and file
	            // is in a (sub|sup) directory
	            //
	            // Examples:
	            // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',
	            //   then rootpath should become 'less/module/nav/'
	            // - If path of imported file is '../mixins.less' and rootpath is 'less/',
	            //   then rootpath should become 'less/../'
	            newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);
	            if (newFileInfo.relativeUrls) {
	                newFileInfo.rootpath = fileManager.join(
	                    (importManager.context.rootpath || ""),
	                    fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));

	                if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {
	                    newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);
	                }
	            }
	            newFileInfo.filename = resolvedFilename;

	            var newEnv = new contexts.Parse(importManager.context);

	            newEnv.processImports = false;
	            importManager.contents[resolvedFilename] = contents;

	            if (currentFileInfo.reference || importOptions.reference) {
	                newFileInfo.reference = true;
	            }

	            if (importOptions.plugin) {
	                new FunctionImporter(newEnv, newFileInfo).eval(contents, function (e, root) {
	                    fileParsedFunc(e, root, resolvedFilename);
	                });
	            } else if (importOptions.inline) {
	                fileParsedFunc(null, contents, resolvedFilename);
	            } else {
	                new Parser(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {
	                    fileParsedFunc(e, root, resolvedFilename);
	                });
	            }
	        };

	        var promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, this.context, environment,
	            function(err, loadedFile) {
	            if (err) {
	                fileParsedFunc(err);
	            } else {
	                loadFileCallback(loadedFile);
	            }
	        });
	        if (promise) {
	            promise.then(loadFileCallback, fileParsedFunc);
	        }
	    };
	    return ImportManager;
	};

	},{"./contexts":11,"./parser/parser":38,"./plugins/function-importer":40}],31:[function(require,module,exports){
	module.exports = function(environment, fileManagers) {
	    var SourceMapOutput, SourceMapBuilder, ParseTree, ImportManager, Environment;

	    var less = {
	        version: [2, 6, 0],
	        data: require('./data'),
	        tree: require('./tree'),
	        Environment: (Environment = require("./environment/environment")),
	        AbstractFileManager: require("./environment/abstract-file-manager"),
	        environment: (environment = new Environment(environment, fileManagers)),
	        visitors: require('./visitors'),
	        Parser: require('./parser/parser'),
	        functions: require('./functions')(environment),
	        contexts: require("./contexts"),
	        SourceMapOutput: (SourceMapOutput = require('./source-map-output')(environment)),
	        SourceMapBuilder: (SourceMapBuilder = require('./source-map-builder')(SourceMapOutput, environment)),
	        ParseTree: (ParseTree = require('./parse-tree')(SourceMapBuilder)),
	        ImportManager: (ImportManager = require('./import-manager')(environment)),
	        render: require("./render")(environment, ParseTree, ImportManager),
	        parse: require("./parse")(environment, ParseTree, ImportManager),
	        LessError: require('./less-error'),
	        transformTree: require('./transform-tree'),
	        utils: require('./utils'),
	        PluginManager: require('./plugin-manager'),
	        logger: require('./logger')
	    };

	    return less;
	};

	},{"./contexts":11,"./data":13,"./environment/abstract-file-manager":15,"./environment/environment":16,"./functions":23,"./import-manager":30,"./less-error":32,"./logger":33,"./parse":35,"./parse-tree":34,"./parser/parser":38,"./plugin-manager":39,"./render":41,"./source-map-builder":42,"./source-map-output":43,"./transform-tree":44,"./tree":62,"./utils":83,"./visitors":87}],32:[function(require,module,exports){
	var utils = require("./utils");

	var LessError = module.exports = function LessError(e, importManager, currentFilename) {

	    Error.call(this);

	    var filename = e.filename || currentFilename;

	    if (importManager && filename) {
	        var input = importManager.contents[filename],
	            loc = utils.getLocation(e.index, input),
	            line = loc.line,
	            col  = loc.column,
	            callLine = e.call && utils.getLocation(e.call, input).line,
	            lines = input.split('\n');

	        this.type = e.type || 'Syntax';
	        this.filename = filename;
	        this.index = e.index;
	        this.line = typeof line === 'number' ? line + 1 : null;
	        this.callLine = callLine + 1;
	        this.callExtract = lines[callLine];
	        this.column = col;
	        this.extract = [
	            lines[line - 1],
	            lines[line],
	            lines[line + 1]
	        ];
	    }
	    this.message = e.message;
	    this.stack = e.stack;
	};

	if (typeof Object.create === 'undefined') {
	    var F = function () {};
	    F.prototype = Error.prototype;
	    LessError.prototype = new F();
	} else {
	    LessError.prototype = Object.create(Error.prototype);
	}

	LessError.prototype.constructor = LessError;

	},{"./utils":83}],33:[function(require,module,exports){
	module.exports = {
	    error: function(msg) {
	        this._fireEvent("error", msg);
	    },
	    warn: function(msg) {
	        this._fireEvent("warn", msg);
	    },
	    info: function(msg) {
	        this._fireEvent("info", msg);
	    },
	    debug: function(msg) {
	        this._fireEvent("debug", msg);
	    },
	    addListener: function(listener) {
	        this._listeners.push(listener);
	    },
	    removeListener: function(listener) {
	        for (var i = 0; i < this._listeners.length; i++) {
	            if (this._listeners[i] === listener) {
	                this._listeners.splice(i, 1);
	                return;
	            }
	        }
	    },
	    _fireEvent: function(type, msg) {
	        for (var i = 0; i < this._listeners.length; i++) {
	            var logFunction = this._listeners[i][type];
	            if (logFunction) {
	                logFunction(msg);
	            }
	        }
	    },
	    _listeners: []
	};

	},{}],34:[function(require,module,exports){
	var LessError = require('./less-error'),
	    transformTree = require("./transform-tree"),
	    logger = require("./logger");

	module.exports = function(SourceMapBuilder) {
	    var ParseTree = function(root, imports) {
	        this.root = root;
	        this.imports = imports;
	    };

	    ParseTree.prototype.toCSS = function(options) {
	        var evaldRoot, result = {}, sourceMapBuilder;
	        try {
	            evaldRoot = transformTree(this.root, options);
	        } catch (e) {
	            throw new LessError(e, this.imports);
	        }

	        try {
	            var compress = Boolean(options.compress);
	            if (compress) {
	                logger.warn("The compress option has been deprecated. We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.");
	            }

	            var toCSSOptions = {
	                compress: compress,
	                dumpLineNumbers: options.dumpLineNumbers,
	                strictUnits: Boolean(options.strictUnits),
	                numPrecision: 8};

	            if (options.sourceMap) {
	                sourceMapBuilder = new SourceMapBuilder(options.sourceMap);
	                result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);
	            } else {
	                result.css = evaldRoot.toCSS(toCSSOptions);
	            }
	        } catch (e) {
	            throw new LessError(e, this.imports);
	        }

	        if (options.pluginManager) {
	            var postProcessors = options.pluginManager.getPostProcessors();
	            for (var i = 0; i < postProcessors.length; i++) {
	                result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options: options, imports: this.imports });
	            }
	        }
	        if (options.sourceMap) {
	            result.map = sourceMapBuilder.getExternalSourceMap();
	        }

	        result.imports = [];
	        for (var file in this.imports.files) {
	            if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {
	                result.imports.push(file);
	            }
	        }
	        return result;
	    };
	    return ParseTree;
	};

	},{"./less-error":32,"./logger":33,"./transform-tree":44}],35:[function(require,module,exports){
	var PromiseConstructor,
	    contexts = require("./contexts"),
	    Parser = require('./parser/parser'),
	    PluginManager = require('./plugin-manager');

	module.exports = function(environment, ParseTree, ImportManager) {
	    var parse = function (input, options, callback) {
	        options = options || {};

	        if (typeof options === 'function') {
	            callback = options;
	            options = {};
	        }

	        if (!callback) {
	            if (!PromiseConstructor) {
	                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;
	            }
	            var self = this;
	            return new PromiseConstructor(function (resolve, reject) {
	                parse.call(self, input, options, function(err, output) {
	                    if (err) {
	                        reject(err);
	                    } else {
	                        resolve(output);
	                    }
	                });
	            });
	        } else {
	            var context,
	                rootFileInfo,
	                pluginManager = new PluginManager(this);

	            pluginManager.addPlugins(options.plugins);
	            options.pluginManager = pluginManager;

	            context = new contexts.Parse(options);

	            if (options.rootFileInfo) {
	                rootFileInfo = options.rootFileInfo;
	            } else {
	                var filename = options.filename || "input";
	                var entryPath = filename.replace(/[^\/\\]*$/, "");
	                rootFileInfo = {
	                    filename: filename,
	                    relativeUrls: context.relativeUrls,
	                    rootpath: context.rootpath || "",
	                    currentDirectory: entryPath,
	                    entryPath: entryPath,
	                    rootFilename: filename
	                };
	                // add in a missing trailing slash
	                if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== "/") {
	                    rootFileInfo.rootpath += "/";
	                }
	            }

	            var imports = new ImportManager(context, rootFileInfo);

	            new Parser(context, imports, rootFileInfo)
	                .parse(input, function (e, root) {
	                if (e) { return callback(e); }
	                callback(null, root, imports, options);
	            }, options);
	        }
	    };
	    return parse;
	};

	},{"./contexts":11,"./parser/parser":38,"./plugin-manager":39,"promise":undefined}],36:[function(require,module,exports){
	// Split the input into chunks.
	module.exports = function (input, fail) {
	    var len = input.length, level = 0, parenLevel = 0,
	        lastOpening, lastOpeningParen, lastMultiComment, lastMultiCommentEndBrace,
	        chunks = [], emitFrom = 0,
	        chunkerCurrentIndex, currentChunkStartIndex, cc, cc2, matched;

	    function emitChunk(force) {
	        var len = chunkerCurrentIndex - emitFrom;
	        if (((len < 512) && !force) || !len) {
	            return;
	        }
	        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));
	        emitFrom = chunkerCurrentIndex + 1;
	    }

	    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
	        cc = input.charCodeAt(chunkerCurrentIndex);
	        if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {
	            // a-z or whitespace
	            continue;
	        }

	        switch (cc) {
	            case 40:                        // (
	                parenLevel++;
	                lastOpeningParen = chunkerCurrentIndex;
	                continue;
	            case 41:                        // )
	                if (--parenLevel < 0) {
	                    return fail("missing opening `(`", chunkerCurrentIndex);
	                }
	                continue;
	            case 59:                        // ;
	                if (!parenLevel) { emitChunk(); }
	                continue;
	            case 123:                       // {
	                level++;
	                lastOpening = chunkerCurrentIndex;
	                continue;
	            case 125:                       // }
	                if (--level < 0) {
	                    return fail("missing opening `{`", chunkerCurrentIndex);
	                }
	                if (!level && !parenLevel) { emitChunk(); }
	                continue;
	            case 92:                        // \
	                if (chunkerCurrentIndex < len - 1) { chunkerCurrentIndex++; continue; }
	                return fail("unescaped `\\`", chunkerCurrentIndex);
	            case 34:
	            case 39:
	            case 96:                        // ", ' and `
	                matched = 0;
	                currentChunkStartIndex = chunkerCurrentIndex;
	                for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
	                    cc2 = input.charCodeAt(chunkerCurrentIndex);
	                    if (cc2 > 96) { continue; }
	                    if (cc2 == cc) { matched = 1; break; }
	                    if (cc2 == 92) {        // \
	                        if (chunkerCurrentIndex == len - 1) {
	                            return fail("unescaped `\\`", chunkerCurrentIndex);
	                        }
	                        chunkerCurrentIndex++;
	                    }
	                }
	                if (matched) { continue; }
	                return fail("unmatched `" + String.fromCharCode(cc) + "`", currentChunkStartIndex);
	            case 47:                        // /, check for comment
	                if (parenLevel || (chunkerCurrentIndex == len - 1)) { continue; }
	                cc2 = input.charCodeAt(chunkerCurrentIndex + 1);
	                if (cc2 == 47) {
	                    // //, find lnfeed
	                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
	                        cc2 = input.charCodeAt(chunkerCurrentIndex);
	                        if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) { break; }
	                    }
	                } else if (cc2 == 42) {
	                    // /*, find */
	                    lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;
	                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {
	                        cc2 = input.charCodeAt(chunkerCurrentIndex);
	                        if (cc2 == 125) { lastMultiCommentEndBrace = chunkerCurrentIndex; }
	                        if (cc2 != 42) { continue; }
	                        if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) { break; }
	                    }
	                    if (chunkerCurrentIndex == len - 1) {
	                        return fail("missing closing `*/`", currentChunkStartIndex);
	                    }
	                    chunkerCurrentIndex++;
	                }
	                continue;
	            case 42:                       // *, check for unmatched */
	                if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {
	                    return fail("unmatched `/*`", chunkerCurrentIndex);
	                }
	                continue;
	        }
	    }

	    if (level !== 0) {
	        if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {
	            return fail("missing closing `}` or `*/`", lastOpening);
	        } else {
	            return fail("missing closing `}`", lastOpening);
	        }
	    } else if (parenLevel !== 0) {
	        return fail("missing closing `)`", lastOpeningParen);
	    }

	    emitChunk(true);
	    return chunks;
	};

	},{}],37:[function(require,module,exports){
	var chunker = require('./chunker');

	module.exports = function() {
	    var input,       // LeSS input string
	        j,           // current chunk
	        saveStack = [],   // holds state for backtracking
	        furthest,    // furthest index the parser has gone to
	        furthestPossibleErrorMessage,// if this is furthest we got to, this is the probably cause
	        chunks,      // chunkified input
	        current,     // current chunk
	        currentPos,  // index of current chunk, in `input`
	        parserInput = {};

	    parserInput.save = function() {
	        currentPos = parserInput.i;
	        saveStack.push( { current: current, i: parserInput.i, j: j });
	    };
	    parserInput.restore = function(possibleErrorMessage) {

	        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {
	            furthest = parserInput.i;
	            furthestPossibleErrorMessage = possibleErrorMessage;
	        }
	        var state = saveStack.pop();
	        current = state.current;
	        currentPos = parserInput.i = state.i;
	        j = state.j;
	    };
	    parserInput.forget = function() {
	        saveStack.pop();
	    };
	    parserInput.isWhitespace = function (offset) {
	        var pos = parserInput.i + (offset || 0),
	            code = input.charCodeAt(pos);
	        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);
	    };

	    // Specialization of $(tok)
	    parserInput.$re = function(tok) {
	        if (parserInput.i > currentPos) {
	            current = current.slice(parserInput.i - currentPos);
	            currentPos = parserInput.i;
	        }

	        var m = tok.exec(current);
	        if (!m) {
	            return null;
	        }

	        skipWhitespace(m[0].length);
	        if (typeof m === "string") {
	            return m;
	        }

	        return m.length === 1 ? m[0] : m;
	    };

	    parserInput.$char = function(tok) {
	        if (input.charAt(parserInput.i) !== tok) {
	            return null;
	        }
	        skipWhitespace(1);
	        return tok;
	    };

	    parserInput.$str = function(tok) {
	        var tokLength = tok.length;

	        // https://jsperf.com/string-startswith/21
	        for (var i = 0; i < tokLength; i++) {
	            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
	                return null;
	            }
	        }

	        skipWhitespace(tokLength);
	        return tok;
	    };

	    parserInput.$quoted = function() {

	        var startChar = input.charAt(parserInput.i);
	        if (startChar !== "'" && startChar !== '"') {
	            return;
	        }
	        var length = input.length,
	            currentPosition = parserInput.i;

	        for (var i = 1; i + currentPosition < length; i++) {
	            var nextChar = input.charAt(i + currentPosition);
	            switch(nextChar) {
	                case "\\":
	                    i++;
	                    continue;
	                case "\r":
	                case "\n":
	                    break;
	                case startChar:
	                    var str = input.substr(currentPosition, i + 1);
	                    skipWhitespace(i + 1);
	                    return str;
	                default:
	            }
	        }
	        return null;
	    };

	    var CHARCODE_SPACE = 32,
	        CHARCODE_TAB = 9,
	        CHARCODE_LF = 10,
	        CHARCODE_CR = 13,
	        CHARCODE_PLUS = 43,
	        CHARCODE_COMMA = 44,
	        CHARCODE_FORWARD_SLASH = 47,
	        CHARCODE_9 = 57;

	    parserInput.autoCommentAbsorb = true;
	    parserInput.commentStore = [];
	    parserInput.finished = false;

	    var skipWhitespace = function(length) {
	        var oldi = parserInput.i, oldj = j,
	            curr = parserInput.i - currentPos,
	            endIndex = parserInput.i + current.length - curr,
	            mem = (parserInput.i += length),
	            inp = input,
	            c, nextChar, comment;

	        for (; parserInput.i < endIndex; parserInput.i++) {
	            c = inp.charCodeAt(parserInput.i);

	            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {
	                nextChar = inp.charAt(parserInput.i + 1);
	                if (nextChar === '/') {
	                    comment = {index: parserInput.i, isLineComment: true};
	                    var nextNewLine = inp.indexOf("\n", parserInput.i + 2);
	                    if (nextNewLine < 0) {
	                        nextNewLine = endIndex;
	                    }
	                    parserInput.i = nextNewLine;
	                    comment.text = inp.substr(comment.i, parserInput.i - comment.i);
	                    parserInput.commentStore.push(comment);
	                    continue;
	                } else if (nextChar === '*') {
	                    var nextStarSlash = inp.indexOf("*/", parserInput.i + 2);
	                    if (nextStarSlash >= 0) {
	                        comment = {
	                            index: parserInput.i,
	                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),
	                            isLineComment: false
	                        };
	                        parserInput.i += comment.text.length - 1;
	                        parserInput.commentStore.push(comment);
	                        continue;
	                    }
	                }
	                break;
	            }

	            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {
	                break;
	            }
	        }

	        current = current.slice(length + parserInput.i - mem + curr);
	        currentPos = parserInput.i;

	        if (!current.length) {
	            if (j < chunks.length - 1) {
	                current = chunks[++j];
	                skipWhitespace(0); // skip space at the beginning of a chunk
	                return true; // things changed
	            }
	            parserInput.finished = true;
	        }

	        return oldi !== parserInput.i || oldj !== j;
	    };

	    // Same as $(), but don't change the state of the parser,
	    // just return the match.
	    parserInput.peek = function(tok) {
	        if (typeof tok === 'string') {
	            // https://jsperf.com/string-startswith/21
	            for (var i = 0; i < tok.length; i++) {
	                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
	                    return false;
	                }
	            }
	            return true;
	        } else {
	            return tok.test(current);
	        }
	    };

	    // Specialization of peek()
	    // TODO remove or change some currentChar calls to peekChar
	    parserInput.peekChar = function(tok) {
	        return input.charAt(parserInput.i) === tok;
	    };

	    parserInput.currentChar = function() {
	        return input.charAt(parserInput.i);
	    };

	    parserInput.getInput = function() {
	        return input;
	    };

	    parserInput.peekNotNumeric = function() {
	        var c = input.charCodeAt(parserInput.i);
	        //Is the first char of the dimension 0-9, '.', '+' or '-'
	        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;
	    };

	    parserInput.start = function(str, chunkInput, failFunction) {
	        input = str;
	        parserInput.i = j = currentPos = furthest = 0;

	        // chunking apparantly makes things quicker (but my tests indicate
	        // it might actually make things slower in node at least)
	        // and it is a non-perfect parse - it can't recognise
	        // unquoted urls, meaning it can't distinguish comments
	        // meaning comments with quotes or {}() in them get 'counted'
	        // and then lead to parse errors.
	        // In addition if the chunking chunks in the wrong place we might
	        // not be able to parse a parser statement in one go
	        // this is officially deprecated but can be switched on via an option
	        // in the case it causes too much performance issues.
	        if (chunkInput) {
	            chunks = chunker(str, failFunction);
	        } else {
	            chunks = [str];
	        }

	        current = chunks[0];

	        skipWhitespace(0);
	    };

	    parserInput.end = function() {
	        var message,
	            isFinished = parserInput.i >= input.length;

	        if (parserInput.i < furthest) {
	            message = furthestPossibleErrorMessage;
	            parserInput.i = furthest;
	        }
	        return {
	            isFinished: isFinished,
	            furthest: parserInput.i,
	            furthestPossibleErrorMessage: message,
	            furthestReachedEnd: parserInput.i >= input.length - 1,
	            furthestChar: input[parserInput.i]
	        };
	    };

	    return parserInput;
	};

	},{"./chunker":36}],38:[function(require,module,exports){
	var LessError = require('../less-error'),
	    tree = require("../tree"),
	    visitors = require("../visitors"),
	    getParserInput = require("./parser-input"),
	    utils = require("../utils");

	//
	// less.js - parser
	//
	//    A relatively straight-forward predictive parser.
	//    There is no tokenization/lexing stage, the input is parsed
	//    in one sweep.
	//
	//    To make the parser fast enough to run in the browser, several
	//    optimization had to be made:
	//
	//    - Matching and slicing on a huge input is often cause of slowdowns.
	//      The solution is to chunkify the input into smaller strings.
	//      The chunks are stored in the `chunks` var,
	//      `j` holds the current chunk index, and `currentPos` holds
	//      the index of the current chunk in relation to `input`.
	//      This gives us an almost 4x speed-up.
	//
	//    - In many cases, we don't need to match individual tokens;
	//      for example, if a value doesn't hold any variables, operations
	//      or dynamic references, the parser can effectively 'skip' it,
	//      treating it as a literal.
	//      An example would be '1px solid #000' - which evaluates to itself,
	//      we don't need to know what the individual components are.
	//      The drawback, of course is that you don't get the benefits of
	//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,
	//      and a smaller speed-up in the code-gen.
	//
	//
	//    Token matching is done with the `$` function, which either takes
	//    a terminal string or regexp, or a non-terminal function to call.
	//    It also takes care of moving all the indices forwards.
	//`
	//
	var Parser = function Parser(context, imports, fileInfo) {
	    var parsers,
	        parserInput = getParserInput();

	    function expect(arg, msg, index) {
	        // some older browsers return typeof 'function' for RegExp
	        var result = (Object.prototype.toString.call(arg) === '[object Function]') ? arg.call(parsers) : parserInput.$re(arg);
	        if (result) {
	            return result;
	        }
	        error(msg || (typeof arg === 'string' ? "expected '" + arg + "' got '" + parserInput.currentChar() + "'"
	                                               : "unexpected token"));
	    }

	    // Specialization of expect()
	    function expectChar(arg, msg) {
	        if (parserInput.$char(arg)) {
	            return arg;
	        }
	        error(msg || "expected '" + arg + "' got '" + parserInput.currentChar() + "'");
	    }

	    function error(msg, type) {
	        throw new LessError(
	            {
	                index: parserInput.i,
	                filename: fileInfo.filename,
	                type: type || 'Syntax',
	                message: msg
	            },
	            imports
	        );
	    }

	    function getDebugInfo(index) {
	        var filename = fileInfo.filename;

	        return {
	            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,
	            fileName: filename
	        };
	    }

	    //
	    // The Parser
	    //
	    return {

	        //
	        // Parse an input string into an abstract syntax tree,
	        // @param str A string containing 'less' markup
	        // @param callback call `callback` when done.
	        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply
	        //
	        parse: function (str, callback, additionalData) {
	            var root, error = null, globalVars, modifyVars, ignored, preText = "";

	            globalVars = (additionalData && additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + '\n' : '';
	            modifyVars = (additionalData && additionalData.modifyVars) ? '\n' + Parser.serializeVars(additionalData.modifyVars) : '';

	            if (context.pluginManager) {
	                var preProcessors = context.pluginManager.getPreProcessors();
	                for (var i = 0; i < preProcessors.length; i++) {
	                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });
	                }
	            }

	            if (globalVars || (additionalData && additionalData.banner)) {
	                preText = ((additionalData && additionalData.banner) ? additionalData.banner : "") + globalVars;
	                ignored = imports.contentsIgnoredChars;
	                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
	                ignored[fileInfo.filename] += preText.length;
	            }

	            str = str.replace(/\r\n?/g, '\n');
	            // Remove potential UTF Byte Order Mark
	            str = preText + str.replace(/^\uFEFF/, '') + modifyVars;
	            imports.contents[fileInfo.filename] = str;

	            // Start with the primary rule.
	            // The whole syntax tree is held under a Ruleset node,
	            // with the `root` property set to true, so no `{}` are
	            // output. The callback is called when the input is parsed.
	            try {
	                parserInput.start(str, context.chunkInput, function fail(msg, index) {
	                    throw new LessError({
	                        index: index,
	                        type: 'Parse',
	                        message: msg,
	                        filename: fileInfo.filename
	                    }, imports);
	                });

	                root = new(tree.Ruleset)(null, this.parsers.primary());
	                root.root = true;
	                root.firstRoot = true;
	            } catch (e) {
	                return callback(new LessError(e, imports, fileInfo.filename));
	            }

	            // If `i` is smaller than the `input.length - 1`,
	            // it means the parser wasn't able to parse the whole
	            // string, so we've got a parsing error.
	            //
	            // We try to extract a \n delimited string,
	            // showing the line where the parse error occurred.
	            // We split it up into two parts (the part which parsed,
	            // and the part which didn't), so we can color them differently.
	            var endInfo = parserInput.end();
	            if (!endInfo.isFinished) {

	                var message = endInfo.furthestPossibleErrorMessage;

	                if (!message) {
	                    message = "Unrecognised input";
	                    if (endInfo.furthestChar === '}') {
	                        message += ". Possibly missing opening '{'";
	                    } else if (endInfo.furthestChar === ')') {
	                        message += ". Possibly missing opening '('";
	                    } else if (endInfo.furthestReachedEnd) {
	                        message += ". Possibly missing something";
	                    }
	                }

	                error = new LessError({
	                    type: "Parse",
	                    message: message,
	                    index: endInfo.furthest,
	                    filename: fileInfo.filename
	                }, imports);
	            }

	            var finish = function (e) {
	                e = error || e || imports.error;

	                if (e) {
	                    if (!(e instanceof LessError)) {
	                        e = new LessError(e, imports, fileInfo.filename);
	                    }

	                    return callback(e);
	                }
	                else {
	                    return callback(null, root);
	                }
	            };

	            if (context.processImports !== false) {
	                new visitors.ImportVisitor(imports, finish)
	                    .run(root);
	            } else {
	                return finish();
	            }
	        },

	        //
	        // Here in, the parsing rules/functions
	        //
	        // The basic structure of the syntax tree generated is as follows:
	        //
	        //   Ruleset ->  Rule -> Value -> Expression -> Entity
	        //
	        // Here's some Less code:
	        //
	        //    .class {
	        //      color: #fff;
	        //      border: 1px solid #000;
	        //      width: @w + 4px;
	        //      > .child {...}
	        //    }
	        //
	        // And here's what the parse tree might look like:
	        //
	        //     Ruleset (Selector '.class', [
	        //         Rule ("color",  Value ([Expression [Color #fff]]))
	        //         Rule ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))
	        //         Rule ("width",  Value ([Expression [Operation " + " [Variable "@w"][Dimension 4px]]]))
	        //         Ruleset (Selector [Element '>', '.child'], [...])
	        //     ])
	        //
	        //  In general, most rules will try to parse a token with the `$re()` function, and if the return
	        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
	        //  first, before parsing, that's when we use `peek()`.
	        //
	        parsers: parsers = {
	            //
	            // The `primary` rule is the *entry* and *exit* point of the parser.
	            // The rules here can appear at any level of the parse tree.
	            //
	            // The recursive nature of the grammar is an interplay between the `block`
	            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
	            // as represented by this simplified grammar:
	            //
	            //     primary    (ruleset | rule)+
	            //     ruleset    selector+ block
	            //     block      '{' primary '}'
	            //
	            // Only at one point is the primary rule not called from the
	            // block rule: at the root level.
	            //
	            primary: function () {
	                var mixin = this.mixin, root = [], node;

	                while (true) {
	                    while (true) {
	                        node = this.comment();
	                        if (!node) { break; }
	                        root.push(node);
	                    }
	                    // always process comments before deciding if finished
	                    if (parserInput.finished) {
	                        break;
	                    }
	                    if (parserInput.peek('}')) {
	                        break;
	                    }

	                    node = this.extendRule();
	                    if (node) {
	                        root = root.concat(node);
	                        continue;
	                    }

	                    node = mixin.definition() || this.rule() || this.ruleset() ||
	                        mixin.call() || this.rulesetCall() || this.directive();
	                    if (node) {
	                        root.push(node);
	                    } else {
	                        var foundSemiColon = false;
	                        while (parserInput.$char(";")) {
	                            foundSemiColon = true;
	                        }
	                        if (!foundSemiColon) {
	                            break;
	                        }
	                    }
	                }

	                return root;
	            },

	            // comments are collected by the main parsing mechanism and then assigned to nodes
	            // where the current structure allows it
	            comment: function () {
	                if (parserInput.commentStore.length) {
	                    var comment = parserInput.commentStore.shift();
	                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);
	                }
	            },

	            //
	            // Entities are tokens which can be found inside an Expression
	            //
	            entities: {
	                //
	                // A string, which supports escaping " and '
	                //
	                //     "milky way" 'he\'s the one!'
	                //
	                quoted: function () {
	                    var str, index = parserInput.i, isEscaped = false;

	                    parserInput.save();
	                    if (parserInput.$char("~")) {
	                        isEscaped = true;
	                    }
	                    str = parserInput.$quoted();
	                    if (!str) {
	                        parserInput.restore();
	                        return;
	                    }
	                    parserInput.forget();

	                    return new(tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);
	                },

	                //
	                // A catch-all word, such as:
	                //
	                //     black border-collapse
	                //
	                keyword: function () {
	                    var k = parserInput.$char("%") || parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]*/);
	                    if (k) {
	                        return tree.Color.fromKeyword(k) || new(tree.Keyword)(k);
	                    }
	                },

	                namedColor: function () {
	                    parserInput.save();
	                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;
	                    parserInput.autoCommentAbsorb = false;
	                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]*/);
	                    parserInput.autoCommentAbsorb = autoCommentAbsorb;
	                    if (!k) {
	                        parserInput.forget();
	                        return ;
	                    }
	                    var result = tree.Color.fromKeyword(k);
	                    if (!result) {
	                        parserInput.restore();
	                    } else {
	                        parserInput.forget();
	                        return result;
	                    }

	                },

	                //
	                // A function call
	                //
	                //     rgb(255, 0, 255)
	                //
	                // We also try to catch IE's `alpha()`, but let the `alpha` parser
	                // deal with the details.
	                //
	                // The arguments are parsed with the `entities.arguments` parser.
	                //
	                call: function () {
	                    var name, nameLC, args, alpha, index = parserInput.i;

	                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
	                    if (parserInput.peek(/^url\(/i)) {
	                        return;
	                    }

	                    parserInput.save();

	                    name = parserInput.$re(/^([\w-]+|%|progid:[\w\.]+)\(/);
	                    if (!name) { parserInput.forget(); return; }

	                    name = name[1];
	                    nameLC = name.toLowerCase();

	                    if (nameLC === 'alpha') {
	                        alpha = parsers.alpha();
	                        if (alpha) {
	                            parserInput.forget();
	                            return alpha;
	                        }
	                    }

	                    args = this.arguments();

	                    if (! parserInput.$char(')')) {
	                        parserInput.restore("Could not parse call arguments or missing ')'");
	                        return;
	                    }

	                    parserInput.forget();
	                    return new(tree.Call)(name, args, index, fileInfo);
	                },
	                arguments: function () {
	                    var args = [], arg;

	                    while (true) {
	                        arg = this.assignment() || parsers.expression();
	                        if (!arg) {
	                            break;
	                        }
	                        args.push(arg);
	                        if (! parserInput.$char(',')) {
	                            break;
	                        }
	                    }
	                    return args;
	                },
	                literal: function () {
	                    return this.dimension() ||
	                           this.color() ||
	                           this.quoted() ||
	                           this.unicodeDescriptor();
	                },

	                // Assignments are argument entities for calls.
	                // They are present in ie filter properties as shown below.
	                //
	                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )
	                //

	                assignment: function () {
	                    var key, value;
	                    parserInput.save();
	                    key = parserInput.$re(/^\w+(?=\s?=)/i);
	                    if (!key) {
	                        parserInput.restore();
	                        return;
	                    }
	                    if (!parserInput.$char('=')) {
	                        parserInput.restore();
	                        return;
	                    }
	                    value = parsers.entity();
	                    if (value) {
	                        parserInput.forget();
	                        return new(tree.Assignment)(key, value);
	                    } else {
	                        parserInput.restore();
	                    }
	                },

	                //
	                // Parse url() tokens
	                //
	                // We use a specific rule for urls, because they don't really behave like
	                // standard function calls. The difference is that the argument doesn't have
	                // to be enclosed within a string, so it can't be parsed as an Expression.
	                //
	                url: function () {
	                    var value, index = parserInput.i;

	                    parserInput.autoCommentAbsorb = false;

	                    if (!parserInput.$str("url(")) {
	                        parserInput.autoCommentAbsorb = true;
	                        return;
	                    }

	                    value = this.quoted() || this.variable() ||
	                            parserInput.$re(/^(?:(?:\\[\(\)'"])|[^\(\)'"])+/) || "";

	                    parserInput.autoCommentAbsorb = true;

	                    expectChar(')');

	                    return new(tree.URL)((value.value != null || value instanceof tree.Variable) ?
	                                        value : new(tree.Anonymous)(value), index, fileInfo);
	                },

	                //
	                // A Variable entity, such as `@fink`, in
	                //
	                //     width: @fink + 2px
	                //
	                // We use a different parser for variable definitions,
	                // see `parsers.variable`.
	                //
	                variable: function () {
	                    var name, index = parserInput.i;

	                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\w-]+/))) {
	                        return new(tree.Variable)(name, index, fileInfo);
	                    }
	                },

	                // A variable entity useing the protective {} e.g. @{var}
	                variableCurly: function () {
	                    var curly, index = parserInput.i;

	                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
	                        return new(tree.Variable)("@" + curly[1], index, fileInfo);
	                    }
	                },

	                //
	                // A Hexadecimal color
	                //
	                //     #4F3C2F
	                //
	                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.
	                //
	                color: function () {
	                    var rgb;

	                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/))) {
	                        // strip colons, brackets, whitespaces and other characters that should not
	                        // definitely be part of color string
	                        var colorCandidateString = rgb.input.match(/^#([\w]+).*/);
	                        colorCandidateString = colorCandidateString[1];
	                        if (!colorCandidateString.match(/^[A-Fa-f0-9]+$/)) { // verify if candidate consists only of allowed HEX characters
	                            error("Invalid HEX color code");
	                        }
	                        return new(tree.Color)(rgb[1], undefined, '#' + colorCandidateString);
	                    }

	                    return this.namedColor();
	                },

	                //
	                // A Dimension, that is, a number and a unit
	                //
	                //     0.5em 95%
	                //
	                dimension: function () {
	                    if (parserInput.peekNotNumeric()) {
	                        return;
	                    }

	                    var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
	                    if (value) {
	                        return new(tree.Dimension)(value[1], value[2]);
	                    }
	                },

	                //
	                // A unicode descriptor, as is used in unicode-range
	                //
	                // U+0??  or U+00A1-00A9
	                //
	                unicodeDescriptor: function () {
	                    var ud;

	                    ud = parserInput.$re(/^U\+[0-9a-fA-F?]+(\-[0-9a-fA-F?]+)?/);
	                    if (ud) {
	                        return new(tree.UnicodeDescriptor)(ud[0]);
	                    }
	                },

	                //
	                // JavaScript code to be evaluated
	                //
	                //     `window.location.href`
	                //
	                javascript: function () {
	                    var js, index = parserInput.i;

	                    parserInput.save();

	                    var escape = parserInput.$char("~");
	                    var jsQuote = parserInput.$char("`");

	                    if (!jsQuote) {
	                        parserInput.restore();
	                        return;
	                    }

	                    js = parserInput.$re(/^[^`]*`/);
	                    if (js) {
	                        parserInput.forget();
	                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);
	                    }
	                    parserInput.restore("invalid javascript definition");
	                }
	            },

	            //
	            // The variable part of a variable definition. Used in the `rule` parser
	            //
	            //     @fink:
	            //
	            variable: function () {
	                var name;

	                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\s*:/))) { return name[1]; }
	            },

	            //
	            // The variable part of a variable definition. Used in the `rule` parser
	            //
	            //     @fink();
	            //
	            rulesetCall: function () {
	                var name;

	                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\s*\(\s*\)\s*;/))) {
	                    return new tree.RulesetCall(name[1]);
	                }
	            },

	            //
	            // extend syntax - used to extend selectors
	            //
	            extend: function(isRule) {
	                var elements, e, index = parserInput.i, option, extendList, extend;

	                if (!parserInput.$str(isRule ? "&:extend(" : ":extend(")) {
	                    return;
	                }

	                do {
	                    option = null;
	                    elements = null;
	                    while (! (option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
	                        e = this.element();
	                        if (!e) {
	                            break;
	                        }
	                        if (elements) {
	                            elements.push(e);
	                        } else {
	                            elements = [ e ];
	                        }
	                    }

	                    option = option && option[1];
	                    if (!elements) {
	                        error("Missing target selector for :extend().");
	                    }
	                    extend = new(tree.Extend)(new(tree.Selector)(elements), option, index, fileInfo);
	                    if (extendList) {
	                        extendList.push(extend);
	                    } else {
	                        extendList = [ extend ];
	                    }
	                } while (parserInput.$char(","));

	                expect(/^\)/);

	                if (isRule) {
	                    expect(/^;/);
	                }

	                return extendList;
	            },

	            //
	            // extendRule - used in a rule to extend all the parent selectors
	            //
	            extendRule: function() {
	                return this.extend(true);
	            },

	            //
	            // Mixins
	            //
	            mixin: {
	                //
	                // A Mixin call, with an optional argument list
	                //
	                //     #mixins > .square(#fff);
	                //     .rounded(4px, black);
	                //     .button;
	                //
	                // The `while` loop is there because mixins can be
	                // namespaced, but we only support the child and descendant
	                // selector for now.
	                //
	                call: function () {
	                    var s = parserInput.currentChar(), important = false, index = parserInput.i, elemIndex,
	                        elements, elem, e, c, args;

	                    if (s !== '.' && s !== '#') { return; }

	                    parserInput.save(); // stop us absorbing part of an invalid selector

	                    while (true) {
	                        elemIndex = parserInput.i;
	                        e = parserInput.$re(/^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/);
	                        if (!e) {
	                            break;
	                        }
	                        elem = new(tree.Element)(c, e, elemIndex, fileInfo);
	                        if (elements) {
	                            elements.push(elem);
	                        } else {
	                            elements = [ elem ];
	                        }
	                        c = parserInput.$char('>');
	                    }

	                    if (elements) {
	                        if (parserInput.$char('(')) {
	                            args = this.args(true).args;
	                            expectChar(')');
	                        }

	                        if (parsers.important()) {
	                            important = true;
	                        }

	                        if (parsers.end()) {
	                            parserInput.forget();
	                            return new(tree.mixin.Call)(elements, args, index, fileInfo, important);
	                        }
	                    }

	                    parserInput.restore();
	                },
	                args: function (isCall) {
	                    var entities = parsers.entities,
	                        returner = { args:null, variadic: false },
	                        expressions = [], argsSemiColon = [], argsComma = [],
	                        isSemiColonSeparated, expressionContainsNamed, name, nameLoop,
	                        value, arg, expand;

	                    parserInput.save();

	                    while (true) {
	                        if (isCall) {
	                            arg = parsers.detachedRuleset() || parsers.expression();
	                        } else {
	                            parserInput.commentStore.length = 0;
	                            if (parserInput.$str("...")) {
	                                returner.variadic = true;
	                                if (parserInput.$char(";") && !isSemiColonSeparated) {
	                                    isSemiColonSeparated = true;
	                                }
	                                (isSemiColonSeparated ? argsSemiColon : argsComma)
	                                    .push({ variadic: true });
	                                break;
	                            }
	                            arg = entities.variable() || entities.literal() || entities.keyword();
	                        }

	                        if (!arg) {
	                            break;
	                        }

	                        nameLoop = null;
	                        if (arg.throwAwayComments) {
	                            arg.throwAwayComments();
	                        }
	                        value = arg;
	                        var val = null;

	                        if (isCall) {
	                            // Variable
	                            if (arg.value && arg.value.length == 1) {
	                                val = arg.value[0];
	                            }
	                        } else {
	                            val = arg;
	                        }

	                        if (val && val instanceof tree.Variable) {
	                            if (parserInput.$char(':')) {
	                                if (expressions.length > 0) {
	                                    if (isSemiColonSeparated) {
	                                        error("Cannot mix ; and , as delimiter types");
	                                    }
	                                    expressionContainsNamed = true;
	                                }

	                                value = parsers.detachedRuleset() || parsers.expression();

	                                if (!value) {
	                                    if (isCall) {
	                                        error("could not understand value for named argument");
	                                    } else {
	                                        parserInput.restore();
	                                        returner.args = [];
	                                        return returner;
	                                    }
	                                }
	                                nameLoop = (name = val.name);
	                            } else if (parserInput.$str("...")) {
	                                if (!isCall) {
	                                    returner.variadic = true;
	                                    if (parserInput.$char(";") && !isSemiColonSeparated) {
	                                        isSemiColonSeparated = true;
	                                    }
	                                    (isSemiColonSeparated ? argsSemiColon : argsComma)
	                                        .push({ name: arg.name, variadic: true });
	                                    break;
	                                } else {
	                                    expand = true;
	                                }
	                            } else if (!isCall) {
	                                name = nameLoop = val.name;
	                                value = null;
	                            }
	                        }

	                        if (value) {
	                            expressions.push(value);
	                        }

	                        argsComma.push({ name:nameLoop, value:value, expand:expand });

	                        if (parserInput.$char(',')) {
	                            continue;
	                        }

	                        if (parserInput.$char(';') || isSemiColonSeparated) {

	                            if (expressionContainsNamed) {
	                                error("Cannot mix ; and , as delimiter types");
	                            }

	                            isSemiColonSeparated = true;

	                            if (expressions.length > 1) {
	                                value = new(tree.Value)(expressions);
	                            }
	                            argsSemiColon.push({ name:name, value:value, expand:expand });

	                            name = null;
	                            expressions = [];
	                            expressionContainsNamed = false;
	                        }
	                    }

	                    parserInput.forget();
	                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
	                    return returner;
	                },
	                //
	                // A Mixin definition, with a list of parameters
	                //
	                //     .rounded (@radius: 2px, @color) {
	                //        ...
	                //     }
	                //
	                // Until we have a finer grained state-machine, we have to
	                // do a look-ahead, to make sure we don't have a mixin call.
	                // See the `rule` function for more information.
	                //
	                // We start by matching `.rounded (`, and then proceed on to
	                // the argument list, which has optional default values.
	                // We store the parameters in `params`, with a `value` key,
	                // if there is a value, such as in the case of `@radius`.
	                //
	                // Once we've got our params list, and a closing `)`, we parse
	                // the `{...}` block.
	                //
	                definition: function () {
	                    var name, params = [], match, ruleset, cond, variadic = false;
	                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||
	                        parserInput.peek(/^[^{]*\}/)) {
	                        return;
	                    }

	                    parserInput.save();

	                    match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
	                    if (match) {
	                        name = match[1];

	                        var argInfo = this.args(false);
	                        params = argInfo.args;
	                        variadic = argInfo.variadic;

	                        // .mixincall("@{a}");
	                        // looks a bit like a mixin definition..
	                        // also
	                        // .mixincall(@a: {rule: set;});
	                        // so we have to be nice and restore
	                        if (!parserInput.$char(')')) {
	                            parserInput.restore("Missing closing ')'");
	                            return;
	                        }

	                        parserInput.commentStore.length = 0;

	                        if (parserInput.$str("when")) { // Guard
	                            cond = expect(parsers.conditions, 'expected condition');
	                        }

	                        ruleset = parsers.block();

	                        if (ruleset) {
	                            parserInput.forget();
	                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);
	                        } else {
	                            parserInput.restore();
	                        }
	                    } else {
	                        parserInput.forget();
	                    }
	                }
	            },

	            //
	            // Entities are the smallest recognized token,
	            // and can be found inside a rule's value.
	            //
	            entity: function () {
	                var entities = this.entities;

	                return this.comment() || entities.literal() || entities.variable() || entities.url() ||
	                       entities.call()    || entities.keyword()  || entities.javascript();
	            },

	            //
	            // A Rule terminator. Note that we use `peek()` to check for '}',
	            // because the `block` rule will be expecting it, but we still need to make sure
	            // it's there, if ';' was ommitted.
	            //
	            end: function () {
	                return parserInput.$char(';') || parserInput.peek('}');
	            },

	            //
	            // IE's alpha function
	            //
	            //     alpha(opacity=88)
	            //
	            alpha: function () {
	                var value;

	                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
	                if (! parserInput.$re(/^opacity=/i)) { return; }
	                value = parserInput.$re(/^\d+/);
	                if (!value) {
	                    value = expect(this.entities.variable, "Could not parse alpha");
	                }
	                expectChar(')');
	                return new(tree.Alpha)(value);
	            },

	            //
	            // A Selector Element
	            //
	            //     div
	            //     + h1
	            //     #socks
	            //     input[type="text"]
	            //
	            // Elements are the building blocks for Selectors,
	            // they are made out of a `Combinator` (see combinator rule),
	            // and an element name, such as a tag a class, or `*`.
	            //
	            element: function () {
	                var e, c, v, index = parserInput.i;

	                c = this.combinator();

	                e = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) ||
	                    parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||
	                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||
	                    parserInput.$re(/^\([^&()@]+\)/) ||  parserInput.$re(/^[\.#:](?=@)/) ||
	                    this.entities.variableCurly();

	                if (! e) {
	                    parserInput.save();
	                    if (parserInput.$char('(')) {
	                        if ((v = this.selector()) && parserInput.$char(')')) {
	                            e = new(tree.Paren)(v);
	                            parserInput.forget();
	                        } else {
	                            parserInput.restore("Missing closing ')'");
	                        }
	                    } else {
	                        parserInput.forget();
	                    }
	                }

	                if (e) { return new(tree.Element)(c, e, index, fileInfo); }
	            },

	            //
	            // Combinators combine elements together, in a Selector.
	            //
	            // Because our parser isn't white-space sensitive, special care
	            // has to be taken, when parsing the descendant combinator, ` `,
	            // as it's an empty space. We have to check the previous character
	            // in the input, to see if it's a ` ` character. More info on how
	            // we deal with this in *combinator.js*.
	            //
	            combinator: function () {
	                var c = parserInput.currentChar();

	                if (c === '/') {
	                    parserInput.save();
	                    var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
	                    if (slashedCombinator) {
	                        parserInput.forget();
	                        return new(tree.Combinator)(slashedCombinator);
	                    }
	                    parserInput.restore();
	                }

	                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {
	                    parserInput.i++;
	                    if (c === '^' && parserInput.currentChar() === '^') {
	                        c = '^^';
	                        parserInput.i++;
	                    }
	                    while (parserInput.isWhitespace()) { parserInput.i++; }
	                    return new(tree.Combinator)(c);
	                } else if (parserInput.isWhitespace(-1)) {
	                    return new(tree.Combinator)(" ");
	                } else {
	                    return new(tree.Combinator)(null);
	                }
	            },
	            //
	            // A CSS selector (see selector below)
	            // with less extensions e.g. the ability to extend and guard
	            //
	            lessSelector: function () {
	                return this.selector(true);
	            },
	            //
	            // A CSS Selector
	            //
	            //     .class > div + h1
	            //     li a:hover
	            //
	            // Selectors are made out of one or more Elements, see above.
	            //
	            selector: function (isLess) {
	                var index = parserInput.i, elements, extendList, c, e, allExtends, when, condition;

	                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str("when"))) || (e = this.element())) {
	                    if (when) {
	                        condition = expect(this.conditions, 'expected condition');
	                    } else if (condition) {
	                        error("CSS guard can only be used at the end of selector");
	                    } else if (extendList) {
	                        if (allExtends) {
	                            allExtends = allExtends.concat(extendList);
	                        } else {
	                            allExtends = extendList;
	                        }
	                    } else {
	                        if (allExtends) { error("Extend can only be used at the end of selector"); }
	                        c = parserInput.currentChar();
	                        if (elements) {
	                            elements.push(e);
	                        } else {
	                            elements = [ e ];
	                        }
	                        e = null;
	                    }
	                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {
	                        break;
	                    }
	                }

	                if (elements) { return new(tree.Selector)(elements, allExtends, condition, index, fileInfo); }
	                if (allExtends) { error("Extend must be used to extend a selector, it cannot be used on its own"); }
	            },
	            attribute: function () {
	                if (! parserInput.$char('[')) { return; }

	                var entities = this.entities,
	                    key, val, op;

	                if (!(key = entities.variableCurly())) {
	                    key = expect(/^(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
	                }

	                op = parserInput.$re(/^[|~*$^]?=/);
	                if (op) {
	                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
	                }

	                expectChar(']');

	                return new(tree.Attribute)(key, op, val);
	            },

	            //
	            // The `block` rule is used by `ruleset` and `mixin.definition`.
	            // It's a wrapper around the `primary` rule, with added `{}`.
	            //
	            block: function () {
	                var content;
	                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {
	                    return content;
	                }
	            },

	            blockRuleset: function() {
	                var block = this.block();

	                if (block) {
	                    block = new tree.Ruleset(null, block);
	                }
	                return block;
	            },

	            detachedRuleset: function() {
	                var blockRuleset = this.blockRuleset();
	                if (blockRuleset) {
	                    return new tree.DetachedRuleset(blockRuleset);
	                }
	            },

	            //
	            // div, .class, body > p {...}
	            //
	            ruleset: function () {
	                var selectors, s, rules, debugInfo;

	                parserInput.save();

	                if (context.dumpLineNumbers) {
	                    debugInfo = getDebugInfo(parserInput.i);
	                }

	                while (true) {
	                    s = this.lessSelector();
	                    if (!s) {
	                        break;
	                    }
	                    if (selectors) {
	                        selectors.push(s);
	                    } else {
	                        selectors = [ s ];
	                    }
	                    parserInput.commentStore.length = 0;
	                    if (s.condition && selectors.length > 1) {
	                        error("Guards are only currently allowed on a single selector.");
	                    }
	                    if (! parserInput.$char(',')) { break; }
	                    if (s.condition) {
	                        error("Guards are only currently allowed on a single selector.");
	                    }
	                    parserInput.commentStore.length = 0;
	                }

	                if (selectors && (rules = this.block())) {
	                    parserInput.forget();
	                    var ruleset = new(tree.Ruleset)(selectors, rules, context.strictImports);
	                    if (context.dumpLineNumbers) {
	                        ruleset.debugInfo = debugInfo;
	                    }
	                    return ruleset;
	                } else {
	                    parserInput.restore();
	                }
	            },
	            rule: function (tryAnonymous) {
	                var name, value, startOfRule = parserInput.i, c = parserInput.currentChar(), important, merge, isVariable;

	                if (c === '.' || c === '#' || c === '&' || c === ':') { return; }

	                parserInput.save();

	                name = this.variable() || this.ruleProperty();
	                if (name) {
	                    isVariable = typeof name === "string";

	                    if (isVariable) {
	                        value = this.detachedRuleset();
	                    }

	                    parserInput.commentStore.length = 0;
	                    if (!value) {
	                        // a name returned by this.ruleProperty() is always an array of the form:
	                        // [string-1, ..., string-n, ""] or [string-1, ..., string-n, "+"]
	                        // where each item is a tree.Keyword or tree.Variable
	                        merge = !isVariable && name.length > 1 && name.pop().value;

	                        // prefer to try to parse first if its a variable or we are compressing
	                        // but always fallback on the other one
	                        var tryValueFirst = !tryAnonymous && (context.compress || isVariable);

	                        if (tryValueFirst) {
	                            value = this.value();
	                        }
	                        if (!value) {
	                            value = this.anonymousValue();
	                            if (value) {
	                                parserInput.forget();
	                                // anonymous values absorb the end ';' which is required for them to work
	                                return new (tree.Rule)(name, value, false, merge, startOfRule, fileInfo);
	                            }
	                        }
	                        if (!tryValueFirst && !value) {
	                            value = this.value();
	                        }

	                        important = this.important();
	                    }

	                    if (value && this.end()) {
	                        parserInput.forget();
	                        return new (tree.Rule)(name, value, important, merge, startOfRule, fileInfo);
	                    } else {
	                        parserInput.restore();
	                        if (value && !tryAnonymous) {
	                            return this.rule(true);
	                        }
	                    }
	                } else {
	                    parserInput.forget();
	                }
	            },
	            anonymousValue: function () {
	                var match = parserInput.$re(/^([^@+\/'"*`(;{}-]*);/);
	                if (match) {
	                    return new(tree.Anonymous)(match[1]);
	                }
	            },

	            //
	            // An @import directive
	            //
	            //     @import "lib";
	            //
	            // Depending on our environment, importing is done differently:
	            // In the browser, it's an XHR request, in Node, it would be a
	            // file-system operation. The function used for importing is
	            // stored in `import`, which we pass to the Import constructor.
	            //
	            "import": function () {
	                var path, features, index = parserInput.i;

	                var dir = parserInput.$re(/^@import?\s+/);

	                if (dir) {
	                    var options = (dir ? this.importOptions() : null) || {};

	                    if ((path = this.entities.quoted() || this.entities.url())) {
	                        features = this.mediaFeatures();

	                        if (!parserInput.$char(';')) {
	                            parserInput.i = index;
	                            error("missing semi-colon or unrecognised media features on import");
	                        }
	                        features = features && new(tree.Value)(features);
	                        return new(tree.Import)(path, features, options, index, fileInfo);
	                    }
	                    else {
	                        parserInput.i = index;
	                        error("malformed import statement");
	                    }
	                }
	            },

	            importOptions: function() {
	                var o, options = {}, optionName, value;

	                // list of options, surrounded by parens
	                if (! parserInput.$char('(')) { return null; }
	                do {
	                    o = this.importOption();
	                    if (o) {
	                        optionName = o;
	                        value = true;
	                        switch(optionName) {
	                            case "css":
	                                optionName = "less";
	                                value = false;
	                                break;
	                            case "once":
	                                optionName = "multiple";
	                                value = false;
	                                break;
	                        }
	                        options[optionName] = value;
	                        if (! parserInput.$char(',')) { break; }
	                    }
	                } while (o);
	                expectChar(')');
	                return options;
	            },

	            importOption: function() {
	                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
	                if (opt) {
	                    return opt[1];
	                }
	            },

	            mediaFeature: function () {
	                var entities = this.entities, nodes = [], e, p;
	                parserInput.save();
	                do {
	                    e = entities.keyword() || entities.variable();
	                    if (e) {
	                        nodes.push(e);
	                    } else if (parserInput.$char('(')) {
	                        p = this.property();
	                        e = this.value();
	                        if (parserInput.$char(')')) {
	                            if (p && e) {
	                                nodes.push(new(tree.Paren)(new(tree.Rule)(p, e, null, null, parserInput.i, fileInfo, true)));
	                            } else if (e) {
	                                nodes.push(new(tree.Paren)(e));
	                            } else {
	                                error("badly formed media feature definition");
	                            }
	                        } else {
	                            error("Missing closing ')'", "Parse");
	                        }
	                    }
	                } while (e);

	                parserInput.forget();
	                if (nodes.length > 0) {
	                    return new(tree.Expression)(nodes);
	                }
	            },

	            mediaFeatures: function () {
	                var entities = this.entities, features = [], e;
	                do {
	                    e = this.mediaFeature();
	                    if (e) {
	                        features.push(e);
	                        if (! parserInput.$char(',')) { break; }
	                    } else {
	                        e = entities.variable();
	                        if (e) {
	                            features.push(e);
	                            if (! parserInput.$char(',')) { break; }
	                        }
	                    }
	                } while (e);

	                return features.length > 0 ? features : null;
	            },

	            media: function () {
	                var features, rules, media, debugInfo;

	                if (context.dumpLineNumbers) {
	                    debugInfo = getDebugInfo(parserInput.i);
	                }

	                parserInput.save();

	                if (parserInput.$str("@media")) {
	                    features = this.mediaFeatures();

	                    rules = this.block();

	                    if (!rules) {
	                        error("media definitions require block statements after any features");
	                    }

	                    parserInput.forget();

	                    media = new(tree.Media)(rules, features, parserInput.i, fileInfo);
	                    if (context.dumpLineNumbers) {
	                        media.debugInfo = debugInfo;
	                    }

	                    return media;
	                }

	                parserInput.restore();
	            },

	            //
	            // A @plugin directive, used to import compiler extensions dynamically.
	            //
	            //     @plugin "lib";
	            //
	            // Depending on our environment, importing is done differently:
	            // In the browser, it's an XHR request, in Node, it would be a
	            // file-system operation. The function used for importing is
	            // stored in `import`, which we pass to the Import constructor.
	            //
	            plugin: function () {
	                var path,
	                    index = parserInput.i,
	                    dir   = parserInput.$re(/^@plugin?\s+/);

	                if (dir) {
	                    var options = { plugin : true };

	                    if ((path = this.entities.quoted() || this.entities.url())) {

	                        if (!parserInput.$char(';')) {
	                            parserInput.i = index;
	                            error("missing semi-colon on plugin");
	                        }

	                        return new(tree.Import)(path, null, options, index, fileInfo);
	                    }
	                    else {
	                        parserInput.i = index;
	                        error("malformed plugin statement");
	                    }
	                }
	            },

	            //
	            // A CSS Directive
	            //
	            //     @charset "utf-8";
	            //
	            directive: function () {
	                var index = parserInput.i, name, value, rules, nonVendorSpecificName,
	                    hasIdentifier, hasExpression, hasUnknown, hasBlock = true, isRooted = true;

	                if (parserInput.currentChar() !== '@') { return; }

	                value = this['import']() || this.plugin() || this.media();
	                if (value) {
	                    return value;
	                }

	                parserInput.save();

	                name = parserInput.$re(/^@[a-z-]+/);

	                if (!name) { return; }

	                nonVendorSpecificName = name;
	                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {
	                    nonVendorSpecificName = "@" + name.slice(name.indexOf('-', 2) + 1);
	                }

	                switch(nonVendorSpecificName) {
	                    case "@charset":
	                        hasIdentifier = true;
	                        hasBlock = false;
	                        break;
	                    case "@namespace":
	                        hasExpression = true;
	                        hasBlock = false;
	                        break;
	                    case "@keyframes":
	                    case "@counter-style":
	                        hasIdentifier = true;
	                        break;
	                    case "@document":
	                    case "@supports":
	                        hasUnknown = true;
	                        isRooted = false;
	                        break;
	                    default:
	                        hasUnknown = true;
	                        break;
	                }

	                parserInput.commentStore.length = 0;

	                if (hasIdentifier) {
	                    value = this.entity();
	                    if (!value) {
	                        error("expected " + name + " identifier");
	                    }
	                } else if (hasExpression) {
	                    value = this.expression();
	                    if (!value) {
	                        error("expected " + name + " expression");
	                    }
	                } else if (hasUnknown) {
	                    value = (parserInput.$re(/^[^{;]+/) || '').trim();
	                    hasBlock = (parserInput.currentChar() == '{');
	                    if (value) {
	                        value = new(tree.Anonymous)(value);
	                    }
	                }

	                if (hasBlock) {
	                    rules = this.blockRuleset();
	                }

	                if (rules || (!hasBlock && value && parserInput.$char(';'))) {
	                    parserInput.forget();
	                    return new (tree.Directive)(name, value, rules, index, fileInfo,
	                        context.dumpLineNumbers ? getDebugInfo(index) : null,
	                        isRooted
	                    );
	                }

	                parserInput.restore("directive options not recognised");
	            },

	            //
	            // A Value is a comma-delimited list of Expressions
	            //
	            //     font-family: Baskerville, Georgia, serif;
	            //
	            // In a Rule, a Value represents everything after the `:`,
	            // and before the `;`.
	            //
	            value: function () {
	                var e, expressions = [];

	                do {
	                    e = this.expression();
	                    if (e) {
	                        expressions.push(e);
	                        if (! parserInput.$char(',')) { break; }
	                    }
	                } while (e);

	                if (expressions.length > 0) {
	                    return new(tree.Value)(expressions);
	                }
	            },
	            important: function () {
	                if (parserInput.currentChar() === '!') {
	                    return parserInput.$re(/^! *important/);
	                }
	            },
	            sub: function () {
	                var a, e;

	                parserInput.save();
	                if (parserInput.$char('(')) {
	                    a = this.addition();
	                    if (a && parserInput.$char(')')) {
	                        parserInput.forget();
	                        e = new(tree.Expression)([a]);
	                        e.parens = true;
	                        return e;
	                    }
	                    parserInput.restore("Expected ')'");
	                    return;
	                }
	                parserInput.restore();
	            },
	            multiplication: function () {
	                var m, a, op, operation, isSpaced;
	                m = this.operand();
	                if (m) {
	                    isSpaced = parserInput.isWhitespace(-1);
	                    while (true) {
	                        if (parserInput.peek(/^\/[*\/]/)) {
	                            break;
	                        }

	                        parserInput.save();

	                        op = parserInput.$char('/') || parserInput.$char('*');

	                        if (!op) { parserInput.forget(); break; }

	                        a = this.operand();

	                        if (!a) { parserInput.restore(); break; }
	                        parserInput.forget();

	                        m.parensInOp = true;
	                        a.parensInOp = true;
	                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);
	                        isSpaced = parserInput.isWhitespace(-1);
	                    }
	                    return operation || m;
	                }
	            },
	            addition: function () {
	                var m, a, op, operation, isSpaced;
	                m = this.multiplication();
	                if (m) {
	                    isSpaced = parserInput.isWhitespace(-1);
	                    while (true) {
	                        op = parserInput.$re(/^[-+]\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));
	                        if (!op) {
	                            break;
	                        }
	                        a = this.multiplication();
	                        if (!a) {
	                            break;
	                        }

	                        m.parensInOp = true;
	                        a.parensInOp = true;
	                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);
	                        isSpaced = parserInput.isWhitespace(-1);
	                    }
	                    return operation || m;
	                }
	            },
	            conditions: function () {
	                var a, b, index = parserInput.i, condition;

	                a = this.condition();
	                if (a) {
	                    while (true) {
	                        if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(',')) {
	                            break;
	                        }
	                        b = this.condition();
	                        if (!b) {
	                            break;
	                        }
	                        condition = new(tree.Condition)('or', condition || a, b, index);
	                    }
	                    return condition || a;
	                }
	            },
	            condition: function () {
	                var result, logical, next;
	                function or() {
	                    return parserInput.$str("or");
	                }

	                result = this.conditionAnd(this);
	                if (!result) {
	                    return ;
	                }
	                logical = or();
	                if (logical) {
	                    next = this.condition();
	                    if (next) {
	                        result = new(tree.Condition)(logical, result, next);
	                    } else {
	                        return ;
	                    }
	                }
	                return result;
	            },
	            conditionAnd: function () {
	                var result, logical, next;
	                function insideCondition(me) {
	                    return me.negatedCondition() || me.parenthesisCondition();
	                }
	                function and() {
	                    return parserInput.$str("and");
	                }

	                result = insideCondition(this);
	                if (!result) {
	                    return ;
	                }
	                logical = and();
	                if (logical) {
	                    next = this.conditionAnd();
	                    if (next) {
	                        result = new(tree.Condition)(logical, result, next);
	                    } else {
	                        return ;
	                    }
	                }
	                return result;
	            },
	            negatedCondition: function () {
	                if (parserInput.$str("not")) {
	                    var result = this.parenthesisCondition();
	                    if (result) {
	                        result.negate = !result.negate;
	                    }
	                    return result;
	                }
	            },
	            parenthesisCondition: function () {
	                var body;
	                if (!parserInput.$str("(")) {
	                    return ;
	                }
	                body = this.condition() || this.atomicCondition();
	                expectChar(')');
	                return body;
	            },
	            atomicCondition: function () {
	                var entities = this.entities, index = parserInput.i, a, b, c, op;

	                a = this.addition() || entities.keyword() || entities.quoted();
	                if (a) {
	                    if (parserInput.$char('>')) {
	                        if (parserInput.$char('=')) {
	                            op = ">=";
	                        } else {
	                            op = '>';
	                        }
	                    } else
	                    if (parserInput.$char('<')) {
	                        if (parserInput.$char('=')) {
	                            op = "<=";
	                        } else {
	                            op = '<';
	                        }
	                    } else
	                    if (parserInput.$char('=')) {
	                        if (parserInput.$char('>')) {
	                            op = "=>";
	                        } else if (parserInput.$char('<')) {
	                            op = '=<';
	                        } else {
	                            op = '=';
	                        }
	                    }
	                    if (op) {
	                        b = this.addition() || entities.keyword() || entities.quoted();
	                        if (b) {
	                            c = new(tree.Condition)(op, a, b, index, false);
	                        } else {
	                            error('expected expression');
	                        }
	                    } else {
	                        c = new(tree.Condition)('=', a, new(tree.Keyword)('true'), index, false);
	                    }
	                    return c;
	                }
	            },

	            //
	            // An operand is anything that can be part of an operation,
	            // such as a Color, or a Variable
	            //
	            operand: function () {
	                var entities = this.entities, negate;

	                if (parserInput.peek(/^-[@\(]/)) {
	                    negate = parserInput.$char('-');
	                }

	                var o = this.sub() || entities.dimension() ||
	                        entities.variable() ||
	                        entities.call() || entities.color();

	                if (negate) {
	                    o.parensInOp = true;
	                    o = new(tree.Negative)(o);
	                }

	                return o;
	            },

	            //
	            // Expressions either represent mathematical operations,
	            // or white-space delimited Entities.
	            //
	            //     1px solid black
	            //     @var * 2
	            //
	            expression: function () {
	                var entities = [], e, delim;

	                do {
	                    e = this.comment();
	                    if (e) {
	                        entities.push(e);
	                        continue;
	                    }
	                    e = this.addition() || this.entity();
	                    if (e) {
	                        entities.push(e);
	                        // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here
	                        if (!parserInput.peek(/^\/[\/*]/)) {
	                            delim = parserInput.$char('/');
	                            if (delim) {
	                                entities.push(new(tree.Anonymous)(delim));
	                            }
	                        }
	                    }
	                } while (e);
	                if (entities.length > 0) {
	                    return new(tree.Expression)(entities);
	                }
	            },
	            property: function () {
	                var name = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
	                if (name) {
	                    return name[1];
	                }
	            },
	            ruleProperty: function () {
	                var name = [], index = [], s, k;

	                parserInput.save();

	                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
	                if (simpleProperty) {
	                    name = [new(tree.Keyword)(simpleProperty[1])];
	                    parserInput.forget();
	                    return name;
	                }

	                function match(re) {
	                    var i = parserInput.i,
	                        chunk = parserInput.$re(re);
	                    if (chunk) {
	                        index.push(i);
	                        return name.push(chunk[1]);
	                    }
	                }

	                match(/^(\*?)/);
	                while (true) {
	                    if (!match(/^((?:[\w-]+)|(?:@\{[\w-]+\}))/)) {
	                        break;
	                    }
	                }

	                if ((name.length > 1) && match(/^((?:\+_|\+)?)\s*:/)) {
	                    parserInput.forget();

	                    // at last, we have the complete match now. move forward,
	                    // convert name particles to tree objects and return:
	                    if (name[0] === '') {
	                        name.shift();
	                        index.shift();
	                    }
	                    for (k = 0; k < name.length; k++) {
	                        s = name[k];
	                        name[k] = (s.charAt(0) !== '@') ?
	                            new(tree.Keyword)(s) :
	                            new(tree.Variable)('@' + s.slice(2, -1),
	                                index[k], fileInfo);
	                    }
	                    return name;
	                }
	                parserInput.restore();
	            }
	        }
	    };
	};
	Parser.serializeVars = function(vars) {
	    var s = '';

	    for (var name in vars) {
	        if (Object.hasOwnProperty.call(vars, name)) {
	            var value = vars[name];
	            s += ((name[0] === '@') ? '' : '@') + name + ': ' + value +
	                ((String(value).slice(-1) === ';') ? '' : ';');
	        }
	    }

	    return s;
	};

	module.exports = Parser;

	},{"../less-error":32,"../tree":62,"../utils":83,"../visitors":87,"./parser-input":37}],39:[function(require,module,exports){
	/**
	 * Plugin Manager
	 */
	var PluginManager = function(less) {
	    this.less = less;
	    this.visitors = [];
	    this.preProcessors = [];
	    this.postProcessors = [];
	    this.installedPlugins = [];
	    this.fileManagers = [];
	};
	/**
	 * Adds all the plugins in the array
	 * @param {Array} plugins
	 */
	PluginManager.prototype.addPlugins = function(plugins) {
	    if (plugins) {
	        for (var i = 0; i < plugins.length; i++) {
	            this.addPlugin(plugins[i]);
	        }
	    }
	};
	/**
	 *
	 * @param plugin
	 */
	PluginManager.prototype.addPlugin = function(plugin) {
	    this.installedPlugins.push(plugin);
	    plugin.install(this.less, this);
	};
	/**
	 * Adds a visitor. The visitor object has options on itself to determine
	 * when it should run.
	 * @param visitor
	 */
	PluginManager.prototype.addVisitor = function(visitor) {
	    this.visitors.push(visitor);
	};
	/**
	 * Adds a pre processor object
	 * @param {object} preProcessor
	 * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import
	 */
	PluginManager.prototype.addPreProcessor = function(preProcessor, priority) {
	    var indexToInsertAt;
	    for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {
	        if (this.preProcessors[indexToInsertAt].priority >= priority) {
	            break;
	        }
	    }
	    this.preProcessors.splice(indexToInsertAt, 0, {preProcessor: preProcessor, priority: priority});
	};
	/**
	 * Adds a post processor object
	 * @param {object} postProcessor
	 * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression
	 */
	PluginManager.prototype.addPostProcessor = function(postProcessor, priority) {
	    var indexToInsertAt;
	    for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {
	        if (this.postProcessors[indexToInsertAt].priority >= priority) {
	            break;
	        }
	    }
	    this.postProcessors.splice(indexToInsertAt, 0, {postProcessor: postProcessor, priority: priority});
	};
	/**
	 *
	 * @param manager
	 */
	PluginManager.prototype.addFileManager = function(manager) {
	    this.fileManagers.push(manager);
	};
	/**
	 *
	 * @returns {Array}
	 * @private
	 */
	PluginManager.prototype.getPreProcessors = function() {
	    var preProcessors = [];
	    for (var i = 0; i < this.preProcessors.length; i++) {
	        preProcessors.push(this.preProcessors[i].preProcessor);
	    }
	    return preProcessors;
	};
	/**
	 *
	 * @returns {Array}
	 * @private
	 */
	PluginManager.prototype.getPostProcessors = function() {
	    var postProcessors = [];
	    for (var i = 0; i < this.postProcessors.length; i++) {
	        postProcessors.push(this.postProcessors[i].postProcessor);
	    }
	    return postProcessors;
	};
	/**
	 *
	 * @returns {Array}
	 * @private
	 */
	PluginManager.prototype.getVisitors = function() {
	    return this.visitors;
	};
	/**
	 *
	 * @returns {Array}
	 * @private
	 */
	PluginManager.prototype.getFileManagers = function() {
	    return this.fileManagers;
	};
	module.exports = PluginManager;

	},{}],40:[function(require,module,exports){
	var LessError = require('../less-error'),
	    tree = require("../tree");

	var FunctionImporter = module.exports = function FunctionImporter(context, fileInfo) {
	    this.fileInfo = fileInfo;
	};

	FunctionImporter.prototype.eval = function(contents, callback) {
	    var loaded = {},
	        loader,
	        registry;

	    registry = {
	        add: function(name, func) {
	            loaded[name] = func;
	        },
	        addMultiple: function(functions) {
	            Object.keys(functions).forEach(function(name) {
	                loaded[name] = functions[name];
	            });
	        }
	    };

	    try {
	        loader = new Function("functions", "tree", "fileInfo", contents);
	        loader(registry, tree, this.fileInfo);
	    } catch(e) {
	        callback(new LessError({
	            message: "Plugin evaluation error: '" + e.name + ': ' + e.message.replace(/["]/g, "'") + "'" ,
	            filename: this.fileInfo.filename
	        }), null );
	    }

	    callback(null, { functions: loaded });
	};

	},{"../less-error":32,"../tree":62}],41:[function(require,module,exports){
	var PromiseConstructor;

	module.exports = function(environment, ParseTree, ImportManager) {
	    var render = function (input, options, callback) {
	        if (typeof options === 'function') {
	            callback = options;
	            options = {};
	        }

	        if (!callback) {
	            if (!PromiseConstructor) {
	                PromiseConstructor = typeof Promise === 'undefined' ? require('promise') : Promise;
	            }
	            var self = this;
	            return new PromiseConstructor(function (resolve, reject) {
	                render.call(self, input, options, function(err, output) {
	                    if (err) {
	                        reject(err);
	                    } else {
	                        resolve(output);
	                    }
	                });
	            });
	        } else {
	            this.parse(input, options, function(err, root, imports, options) {
	                if (err) { return callback(err); }

	                var result;
	                try {
	                    var parseTree = new ParseTree(root, imports);
	                    result = parseTree.toCSS(options);
	                }
	                catch (err) { return callback(err); }

	                callback(null, result);
	            });
	        }
	    };

	    return render;
	};

	},{"promise":undefined}],42:[function(require,module,exports){
	module.exports = function (SourceMapOutput, environment) {

	    var SourceMapBuilder = function (options) {
	        this.options = options;
	    };

	    SourceMapBuilder.prototype.toCSS = function(rootNode, options, imports) {
	        var sourceMapOutput = new SourceMapOutput(
	            {
	                contentsIgnoredCharsMap: imports.contentsIgnoredChars,
	                rootNode: rootNode,
	                contentsMap: imports.contents,
	                sourceMapFilename: this.options.sourceMapFilename,
	                sourceMapURL: this.options.sourceMapURL,
	                outputFilename: this.options.sourceMapOutputFilename,
	                sourceMapBasepath: this.options.sourceMapBasepath,
	                sourceMapRootpath: this.options.sourceMapRootpath,
	                outputSourceFiles: this.options.outputSourceFiles,
	                sourceMapGenerator: this.options.sourceMapGenerator,
	                sourceMapFileInline: this.options.sourceMapFileInline
	            });

	        var css = sourceMapOutput.toCSS(options);
	        this.sourceMap = sourceMapOutput.sourceMap;
	        this.sourceMapURL = sourceMapOutput.sourceMapURL;
	        if (this.options.sourceMapInputFilename) {
	            this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);
	        }
	        return css + this.getCSSAppendage();
	    };

	    SourceMapBuilder.prototype.getCSSAppendage = function() {

	        var sourceMapURL = this.sourceMapURL;
	        if (this.options.sourceMapFileInline) {
	            if (this.sourceMap === undefined) {
	                return "";
	            }
	            sourceMapURL = "data:application/json;base64," + environment.encodeBase64(this.sourceMap);
	        }

	        if (sourceMapURL) {
	            return "/*# sourceMappingURL=" + sourceMapURL + " */";
	        }
	        return "";
	    };

	    SourceMapBuilder.prototype.getExternalSourceMap = function() {
	        return this.sourceMap;
	    };
	    SourceMapBuilder.prototype.setExternalSourceMap = function(sourceMap) {
	        this.sourceMap = sourceMap;
	    };

	    SourceMapBuilder.prototype.isInline = function() {
	        return this.options.sourceMapFileInline;
	    };
	    SourceMapBuilder.prototype.getSourceMapURL = function() {
	        return this.sourceMapURL;
	    };
	    SourceMapBuilder.prototype.getOutputFilename = function() {
	        return this.options.sourceMapOutputFilename;
	    };
	    SourceMapBuilder.prototype.getInputFilename = function() {
	        return this.sourceMapInputFilename;
	    };

	    return SourceMapBuilder;
	};

	},{}],43:[function(require,module,exports){
	module.exports = function (environment) {

	    var SourceMapOutput = function (options) {
	        this._css = [];
	        this._rootNode = options.rootNode;
	        this._contentsMap = options.contentsMap;
	        this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;
	        if (options.sourceMapFilename) {
	            this._sourceMapFilename = options.sourceMapFilename.replace(/\\/g, '/');
	        }
	        this._outputFilename = options.outputFilename;
	        this.sourceMapURL = options.sourceMapURL;
	        if (options.sourceMapBasepath) {
	            this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\/g, '/');
	        }
	        if (options.sourceMapRootpath) {
	            this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\/g, '/');
	            if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {
	                this._sourceMapRootpath += '/';
	            }
	        } else {
	            this._sourceMapRootpath = "";
	        }
	        this._outputSourceFiles = options.outputSourceFiles;
	        this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();

	        this._lineNumber = 0;
	        this._column = 0;
	    };

	    SourceMapOutput.prototype.normalizeFilename = function(filename) {
	        filename = filename.replace(/\\/g, '/');

	        if (this._sourceMapBasepath && filename.indexOf(this._sourceMapBasepath) === 0) {
	            filename = filename.substring(this._sourceMapBasepath.length);
	            if (filename.charAt(0) === '\\' || filename.charAt(0) === '/') {
	                filename = filename.substring(1);
	            }
	        }
	        return (this._sourceMapRootpath || "") + filename;
	    };

	    SourceMapOutput.prototype.add = function(chunk, fileInfo, index, mapLines) {

	        //ignore adding empty strings
	        if (!chunk) {
	            return;
	        }

	        var lines,
	            sourceLines,
	            columns,
	            sourceColumns,
	            i;

	        if (fileInfo) {
	            var inputSource = this._contentsMap[fileInfo.filename];

	            // remove vars/banner added to the top of the file
	            if (this._contentsIgnoredCharsMap[fileInfo.filename]) {
	                // adjust the index
	                index -= this._contentsIgnoredCharsMap[fileInfo.filename];
	                if (index < 0) { index = 0; }
	                // adjust the source
	                inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);
	            }
	            inputSource = inputSource.substring(0, index);
	            sourceLines = inputSource.split("\n");
	            sourceColumns = sourceLines[sourceLines.length - 1];
	        }

	        lines = chunk.split("\n");
	        columns = lines[lines.length - 1];

	        if (fileInfo) {
	            if (!mapLines) {
	                this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column},
	                    original: { line: sourceLines.length, column: sourceColumns.length},
	                    source: this.normalizeFilename(fileInfo.filename)});
	            } else {
	                for (i = 0; i < lines.length; i++) {
	                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0},
	                        original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0},
	                        source: this.normalizeFilename(fileInfo.filename)});
	                }
	            }
	        }

	        if (lines.length === 1) {
	            this._column += columns.length;
	        } else {
	            this._lineNumber += lines.length - 1;
	            this._column = columns.length;
	        }

	        this._css.push(chunk);
	    };

	    SourceMapOutput.prototype.isEmpty = function() {
	        return this._css.length === 0;
	    };

	    SourceMapOutput.prototype.toCSS = function(context) {
	        this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });

	        if (this._outputSourceFiles) {
	            for (var filename in this._contentsMap) {
	                if (this._contentsMap.hasOwnProperty(filename)) {
	                    var source = this._contentsMap[filename];
	                    if (this._contentsIgnoredCharsMap[filename]) {
	                        source = source.slice(this._contentsIgnoredCharsMap[filename]);
	                    }
	                    this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);
	                }
	            }
	        }

	        this._rootNode.genCSS(context, this);

	        if (this._css.length > 0) {
	            var sourceMapURL,
	                sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());

	            if (this.sourceMapURL) {
	                sourceMapURL = this.sourceMapURL;
	            } else if (this._sourceMapFilename) {
	                sourceMapURL = this._sourceMapFilename;
	            }
	            this.sourceMapURL = sourceMapURL;

	            this.sourceMap = sourceMapContent;
	        }

	        return this._css.join('');
	    };

	    return SourceMapOutput;
	};

	},{}],44:[function(require,module,exports){
	var contexts = require("./contexts"),
	    visitor = require("./visitors"),
	    tree = require("./tree");

	module.exports = function(root, options) {
	    options = options || {};
	    var evaldRoot,
	        variables = options.variables,
	        evalEnv = new contexts.Eval(options);

	    //
	    // Allows setting variables with a hash, so:
	    //
	    //   `{ color: new tree.Color('#f01') }` will become:
	    //
	    //   new tree.Rule('@color',
	    //     new tree.Value([
	    //       new tree.Expression([
	    //         new tree.Color('#f01')
	    //       ])
	    //     ])
	    //   )
	    //
	    if (typeof variables === 'object' && !Array.isArray(variables)) {
	        variables = Object.keys(variables).map(function (k) {
	            var value = variables[k];

	            if (! (value instanceof tree.Value)) {
	                if (! (value instanceof tree.Expression)) {
	                    value = new tree.Expression([value]);
	                }
	                value = new tree.Value([value]);
	            }
	            return new tree.Rule('@' + k, value, false, null, 0);
	        });
	        evalEnv.frames = [new tree.Ruleset(null, variables)];
	    }

	    var preEvalVisitors = [],
	        visitors = [
	            new visitor.JoinSelectorVisitor(),
	            new visitor.MarkVisibleSelectorsVisitor(true),
	            new visitor.ExtendVisitor(),
	            new visitor.ToCSSVisitor({compress: Boolean(options.compress)})
	        ], i;

	    if (options.pluginManager) {
	        var pluginVisitors = options.pluginManager.getVisitors();
	        for (i = 0; i < pluginVisitors.length; i++) {
	            var pluginVisitor = pluginVisitors[i];
	            if (pluginVisitor.isPreEvalVisitor) {
	                preEvalVisitors.push(pluginVisitor);
	            } else {
	                if (pluginVisitor.isPreVisitor) {
	                    visitors.splice(0, 0, pluginVisitor);
	                } else {
	                    visitors.push(pluginVisitor);
	                }
	            }
	        }
	    }

	    for (i = 0; i < preEvalVisitors.length; i++) {
	        preEvalVisitors[i].run(root);
	    }

	    evaldRoot = root.eval(evalEnv);

	    for (i = 0; i < visitors.length; i++) {
	        visitors[i].run(evaldRoot);
	    }

	    return evaldRoot;
	};

	},{"./contexts":11,"./tree":62,"./visitors":87}],45:[function(require,module,exports){
	var Node = require("./node");

	var Alpha = function (val) {
	    this.value = val;
	};
	Alpha.prototype = new Node();
	Alpha.prototype.type = "Alpha";

	Alpha.prototype.accept = function (visitor) {
	    this.value = visitor.visit(this.value);
	};
	Alpha.prototype.eval = function (context) {
	    if (this.value.eval) { return new Alpha(this.value.eval(context)); }
	    return this;
	};
	Alpha.prototype.genCSS = function (context, output) {
	    output.add("alpha(opacity=");

	    if (this.value.genCSS) {
	        this.value.genCSS(context, output);
	    } else {
	        output.add(this.value);
	    }

	    output.add(")");
	};

	module.exports = Alpha;

	},{"./node":70}],46:[function(require,module,exports){
	var Node = require("./node");

	var Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {
	    this.value = value;
	    this.index = index;
	    this.mapLines = mapLines;
	    this.currentFileInfo = currentFileInfo;
	    this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;

	    this.copyVisibilityInfo(visibilityInfo);
	};
	Anonymous.prototype = new Node();
	Anonymous.prototype.type = "Anonymous";
	Anonymous.prototype.eval = function () {
	    return new Anonymous(this.value, this.index, this.currentFileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());
	};
	Anonymous.prototype.compare = function (other) {
	    return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
	};
	Anonymous.prototype.isRulesetLike = function() {
	    return this.rulesetLike;
	};
	Anonymous.prototype.genCSS = function (context, output) {
	    output.add(this.value, this.currentFileInfo, this.index, this.mapLines);
	};
	module.exports = Anonymous;

	},{"./node":70}],47:[function(require,module,exports){
	var Node = require("./node");

	var Assignment = function (key, val) {
	    this.key = key;
	    this.value = val;
	};

	Assignment.prototype = new Node();
	Assignment.prototype.type = "Assignment";
	Assignment.prototype.accept = function (visitor) {
	    this.value = visitor.visit(this.value);
	};
	Assignment.prototype.eval = function (context) {
	    if (this.value.eval) {
	        return new Assignment(this.key, this.value.eval(context));
	    }
	    return this;
	};
	Assignment.prototype.genCSS = function (context, output) {
	    output.add(this.key + '=');
	    if (this.value.genCSS) {
	        this.value.genCSS(context, output);
	    } else {
	        output.add(this.value);
	    }
	};
	module.exports = Assignment;

	},{"./node":70}],48:[function(require,module,exports){
	var Node = require("./node");

	var Attribute = function (key, op, value) {
	    this.key = key;
	    this.op = op;
	    this.value = value;
	};
	Attribute.prototype = new Node();
	Attribute.prototype.type = "Attribute";
	Attribute.prototype.eval = function (context) {
	    return new Attribute(this.key.eval ? this.key.eval(context) : this.key,
	        this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);
	};
	Attribute.prototype.genCSS = function (context, output) {
	    output.add(this.toCSS(context));
	};
	Attribute.prototype.toCSS = function (context) {
	    var value = this.key.toCSS ? this.key.toCSS(context) : this.key;

	    if (this.op) {
	        value += this.op;
	        value += (this.value.toCSS ? this.value.toCSS(context) : this.value);
	    }

	    return '[' + value + ']';
	};
	module.exports = Attribute;

	},{"./node":70}],49:[function(require,module,exports){
	var Node = require("./node"),
	    FunctionCaller = require("../functions/function-caller");
	//
	// A function call node.
	//
	var Call = function (name, args, index, currentFileInfo) {
	    this.name = name;
	    this.args = args;
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;
	};
	Call.prototype = new Node();
	Call.prototype.type = "Call";
	Call.prototype.accept = function (visitor) {
	    if (this.args) {
	        this.args = visitor.visitArray(this.args);
	    }
	};
	//
	// When evaluating a function call,
	// we either find the function in the functionRegistry,
	// in which case we call it, passing the  evaluated arguments,
	// if this returns null or we cannot find the function, we
	// simply print it out as it appeared originally [2].
	//
	// The reason why we evaluate the arguments, is in the case where
	// we try to pass a variable to a function, like: `saturate(@color)`.
	// The function should receive the value, not the variable.
	//
	Call.prototype.eval = function (context) {
	    var args = this.args.map(function (a) { return a.eval(context); }),
	        result, funcCaller = new FunctionCaller(this.name, context, this.index, this.currentFileInfo);

	    if (funcCaller.isValid()) { // 1.
	        try {
	            result = funcCaller.call(args);
	            if (result != null) {
	                return result;
	            }
	        } catch (e) {
	            throw { type: e.type || "Runtime",
	                    message: "error evaluating function `" + this.name + "`" +
	                             (e.message ? ': ' + e.message : ''),
	                    index: this.index, filename: this.currentFileInfo.filename };
	        }
	    }

	    return new Call(this.name, args, this.index, this.currentFileInfo);
	};
	Call.prototype.genCSS = function (context, output) {
	    output.add(this.name + "(", this.currentFileInfo, this.index);

	    for (var i = 0; i < this.args.length; i++) {
	        this.args[i].genCSS(context, output);
	        if (i + 1 < this.args.length) {
	            output.add(", ");
	        }
	    }

	    output.add(")");
	};
	module.exports = Call;

	},{"../functions/function-caller":21,"./node":70}],50:[function(require,module,exports){
	var Node = require("./node"),
	    colors = require("../data/colors");

	//
	// RGB Colors - #ff0014, #eee
	//
	var Color = function (rgb, a, originalForm) {
	    //
	    // The end goal here, is to parse the arguments
	    // into an integer triplet, such as `128, 255, 0`
	    //
	    // This facilitates operations and conversions.
	    //
	    if (Array.isArray(rgb)) {
	        this.rgb = rgb;
	    } else if (rgb.length == 6) {
	        this.rgb = rgb.match(/.{2}/g).map(function (c) {
	            return parseInt(c, 16);
	        });
	    } else {
	        this.rgb = rgb.split('').map(function (c) {
	            return parseInt(c + c, 16);
	        });
	    }
	    this.alpha = typeof a === 'number' ? a : 1;
	    if (typeof originalForm !== 'undefined') {
	        this.value = originalForm;
	    }
	};

	Color.prototype = new Node();
	Color.prototype.type = "Color";

	function clamp(v, max) {
	    return Math.min(Math.max(v, 0), max);
	}

	function toHex(v) {
	    return '#' + v.map(function (c) {
	        c = clamp(Math.round(c), 255);
	        return (c < 16 ? '0' : '') + c.toString(16);
	    }).join('');
	}

	Color.prototype.luma = function () {
	    var r = this.rgb[0] / 255,
	        g = this.rgb[1] / 255,
	        b = this.rgb[2] / 255;

	    r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);
	    g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);
	    b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);

	    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
	};
	Color.prototype.genCSS = function (context, output) {
	    output.add(this.toCSS(context));
	};
	Color.prototype.toCSS = function (context, doNotCompress) {
	    var compress = context && context.compress && !doNotCompress, color, alpha;

	    // `value` is set if this color was originally
	    // converted from a named color string so we need
	    // to respect this and try to output named color too.
	    if (this.value) {
	        return this.value;
	    }

	    // If we have some transparency, the only way to represent it
	    // is via `rgba`. Otherwise, we use the hex representation,
	    // which has better compatibility with older browsers.
	    // Values are capped between `0` and `255`, rounded and zero-padded.
	    alpha = this.fround(context, this.alpha);
	    if (alpha < 1) {
	        return "rgba(" + this.rgb.map(function (c) {
	            return clamp(Math.round(c), 255);
	        }).concat(clamp(alpha, 1))
	            .join(',' + (compress ? '' : ' ')) + ")";
	    }

	    color = this.toRGB();

	    if (compress) {
	        var splitcolor = color.split('');

	        // Convert color to short format
	        if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
	            color = '#' + splitcolor[1] + splitcolor[3] + splitcolor[5];
	        }
	    }

	    return color;
	};

	//
	// Operations have to be done per-channel, if not,
	// channels will spill onto each other. Once we have
	// our result, in the form of an integer triplet,
	// we create a new Color node to hold the result.
	//
	Color.prototype.operate = function (context, op, other) {
	    var rgb = [];
	    var alpha = this.alpha * (1 - other.alpha) + other.alpha;
	    for (var c = 0; c < 3; c++) {
	        rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);
	    }
	    return new Color(rgb, alpha);
	};
	Color.prototype.toRGB = function () {
	    return toHex(this.rgb);
	};
	Color.prototype.toHSL = function () {
	    var r = this.rgb[0] / 255,
	        g = this.rgb[1] / 255,
	        b = this.rgb[2] / 255,
	        a = this.alpha;

	    var max = Math.max(r, g, b), min = Math.min(r, g, b);
	    var h, s, l = (max + min) / 2, d = max - min;

	    if (max === min) {
	        h = s = 0;
	    } else {
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

	        switch (max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2;               break;
	            case b: h = (r - g) / d + 4;               break;
	        }
	        h /= 6;
	    }
	    return { h: h * 360, s: s, l: l, a: a };
	};
	//Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
	Color.prototype.toHSV = function () {
	    var r = this.rgb[0] / 255,
	        g = this.rgb[1] / 255,
	        b = this.rgb[2] / 255,
	        a = this.alpha;

	    var max = Math.max(r, g, b), min = Math.min(r, g, b);
	    var h, s, v = max;

	    var d = max - min;
	    if (max === 0) {
	        s = 0;
	    } else {
	        s = d / max;
	    }

	    if (max === min) {
	        h = 0;
	    } else {
	        switch(max) {
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	        h /= 6;
	    }
	    return { h: h * 360, s: s, v: v, a: a };
	};
	Color.prototype.toARGB = function () {
	    return toHex([this.alpha * 255].concat(this.rgb));
	};
	Color.prototype.compare = function (x) {
	    return (x.rgb &&
	        x.rgb[0] === this.rgb[0] &&
	        x.rgb[1] === this.rgb[1] &&
	        x.rgb[2] === this.rgb[2] &&
	        x.alpha  === this.alpha) ? 0 : undefined;
	};

	Color.fromKeyword = function(keyword) {
	    var c, key = keyword.toLowerCase();
	    if (colors.hasOwnProperty(key)) {
	        c = new Color(colors[key].slice(1));
	    }
	    else if (key === "transparent") {
	        c = new Color([0, 0, 0], 0);
	    }

	    if (c) {
	        c.value = keyword;
	        return c;
	    }
	};
	module.exports = Color;

	},{"../data/colors":12,"./node":70}],51:[function(require,module,exports){
	var Node = require("./node");

	var Combinator = function (value) {
	    if (value === ' ') {
	        this.value = ' ';
	        this.emptyOrWhitespace = true;
	    } else {
	        this.value = value ? value.trim() : "";
	        this.emptyOrWhitespace = this.value === "";
	    }
	};
	Combinator.prototype = new Node();
	Combinator.prototype.type = "Combinator";
	var _noSpaceCombinators = {
	    '': true,
	    ' ': true,
	    '|': true
	};
	Combinator.prototype.genCSS = function (context, output) {
	    var spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';
	    output.add(spaceOrEmpty + this.value + spaceOrEmpty);
	};
	module.exports = Combinator;

	},{"./node":70}],52:[function(require,module,exports){
	var Node = require("./node"),
	    getDebugInfo = require("./debug-info");

	var Comment = function (value, isLineComment, index, currentFileInfo) {
	    this.value = value;
	    this.isLineComment = isLineComment;
	    this.currentFileInfo = currentFileInfo;
	};
	Comment.prototype = new Node();
	Comment.prototype.type = "Comment";
	Comment.prototype.genCSS = function (context, output) {
	    if (this.debugInfo) {
	        output.add(getDebugInfo(context, this), this.currentFileInfo, this.index);
	    }
	    output.add(this.value);
	};
	Comment.prototype.isSilent = function(context) {
	    var isCompressed = context.compress && this.value[2] !== "!";
	    return this.isLineComment || isCompressed;
	};
	module.exports = Comment;

	},{"./debug-info":54,"./node":70}],53:[function(require,module,exports){
	var Node = require("./node");

	var Condition = function (op, l, r, i, negate) {
	    this.op = op.trim();
	    this.lvalue = l;
	    this.rvalue = r;
	    this.index = i;
	    this.negate = negate;
	};
	Condition.prototype = new Node();
	Condition.prototype.type = "Condition";
	Condition.prototype.accept = function (visitor) {
	    this.lvalue = visitor.visit(this.lvalue);
	    this.rvalue = visitor.visit(this.rvalue);
	};
	Condition.prototype.eval = function (context) {
	    var result = (function (op, a, b) {
	        switch (op) {
	            case 'and': return a && b;
	            case 'or':  return a || b;
	            default:
	                switch (Node.compare(a, b)) {
	                    case -1:
	                        return op === '<' || op === '=<' || op === '<=';
	                    case 0:
	                        return op === '=' || op === '>=' || op === '=<' || op === '<=';
	                    case 1:
	                        return op === '>' || op === '>=';
	                    default:
	                        return false;
	                }
	        }
	    })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));

	    return this.negate ? !result : result;
	};
	module.exports = Condition;

	},{"./node":70}],54:[function(require,module,exports){
	var debugInfo = function(context, ctx, lineSeparator) {
	    var result = "";
	    if (context.dumpLineNumbers && !context.compress) {
	        switch(context.dumpLineNumbers) {
	            case 'comments':
	                result = debugInfo.asComment(ctx);
	                break;
	            case 'mediaquery':
	                result = debugInfo.asMediaQuery(ctx);
	                break;
	            case 'all':
	                result = debugInfo.asComment(ctx) + (lineSeparator || "") + debugInfo.asMediaQuery(ctx);
	                break;
	        }
	    }
	    return result;
	};

	debugInfo.asComment = function(ctx) {
	    return '/* line ' + ctx.debugInfo.lineNumber + ', ' + ctx.debugInfo.fileName + ' */\n';
	};

	debugInfo.asMediaQuery = function(ctx) {
	    var filenameWithProtocol = ctx.debugInfo.fileName;
	    if (!/^[a-z]+:\/\//i.test(filenameWithProtocol)) {
	        filenameWithProtocol = 'file://' + filenameWithProtocol;
	    }
	    return '@media -sass-debug-info{filename{font-family:' +
	        filenameWithProtocol.replace(/([.:\/\\])/g, function (a) {
	            if (a == '\\') {
	                a = '\/';
	            }
	            return '\\' + a;
	        }) +
	        '}line{font-family:\\00003' + ctx.debugInfo.lineNumber + '}}\n';
	};

	module.exports = debugInfo;

	},{}],55:[function(require,module,exports){
	var Node = require("./node"),
	    contexts = require("../contexts");

	var DetachedRuleset = function (ruleset, frames) {
	    this.ruleset = ruleset;
	    this.frames = frames;
	};
	DetachedRuleset.prototype = new Node();
	DetachedRuleset.prototype.type = "DetachedRuleset";
	DetachedRuleset.prototype.evalFirst = true;
	DetachedRuleset.prototype.accept = function (visitor) {
	    this.ruleset = visitor.visit(this.ruleset);
	};
	DetachedRuleset.prototype.eval = function (context) {
	    var frames = this.frames || context.frames.slice(0);
	    return new DetachedRuleset(this.ruleset, frames);
	};
	DetachedRuleset.prototype.callEval = function (context) {
	    return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);
	};
	module.exports = DetachedRuleset;

	},{"../contexts":11,"./node":70}],56:[function(require,module,exports){
	var Node = require("./node"),
	    unitConversions = require("../data/unit-conversions"),
	    Unit = require("./unit"),
	    Color = require("./color");

	//
	// A number with a unit
	//
	var Dimension = function (value, unit) {
	    this.value = parseFloat(value);
	    this.unit = (unit && unit instanceof Unit) ? unit :
	      new Unit(unit ? [unit] : undefined);
	};

	Dimension.prototype = new Node();
	Dimension.prototype.type = "Dimension";
	Dimension.prototype.accept = function (visitor) {
	    this.unit = visitor.visit(this.unit);
	};
	Dimension.prototype.eval = function (context) {
	    return this;
	};
	Dimension.prototype.toColor = function () {
	    return new Color([this.value, this.value, this.value]);
	};
	Dimension.prototype.genCSS = function (context, output) {
	    if ((context && context.strictUnits) && !this.unit.isSingular()) {
	        throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: " + this.unit.toString());
	    }

	    var value = this.fround(context, this.value),
	        strValue = String(value);

	    if (value !== 0 && value < 0.000001 && value > -0.000001) {
	        // would be output 1e-6 etc.
	        strValue = value.toFixed(20).replace(/0+$/, "");
	    }

	    if (context && context.compress) {
	        // Zero values doesn't need a unit
	        if (value === 0 && this.unit.isLength()) {
	            output.add(strValue);
	            return;
	        }

	        // Float values doesn't need a leading zero
	        if (value > 0 && value < 1) {
	            strValue = (strValue).substr(1);
	        }
	    }

	    output.add(strValue);
	    this.unit.genCSS(context, output);
	};

	// In an operation between two Dimensions,
	// we default to the first Dimension's unit,
	// so `1px + 2` will yield `3px`.
	Dimension.prototype.operate = function (context, op, other) {
	    /*jshint noempty:false */
	    var value = this._operate(context, op, this.value, other.value),
	        unit = this.unit.clone();

	    if (op === '+' || op === '-') {
	        if (unit.numerator.length === 0 && unit.denominator.length === 0) {
	            unit = other.unit.clone();
	            if (this.unit.backupUnit) {
	                unit.backupUnit = this.unit.backupUnit;
	            }
	        } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {
	            // do nothing
	        } else {
	            other = other.convertTo(this.unit.usedUnits());

	            if (context.strictUnits && other.unit.toString() !== unit.toString()) {
	                throw new Error("Incompatible units. Change the units or use the unit function. Bad units: '" + unit.toString() +
	                    "' and '" + other.unit.toString() + "'.");
	            }

	            value = this._operate(context, op, this.value, other.value);
	        }
	    } else if (op === '*') {
	        unit.numerator = unit.numerator.concat(other.unit.numerator).sort();
	        unit.denominator = unit.denominator.concat(other.unit.denominator).sort();
	        unit.cancel();
	    } else if (op === '/') {
	        unit.numerator = unit.numerator.concat(other.unit.denominator).sort();
	        unit.denominator = unit.denominator.concat(other.unit.numerator).sort();
	        unit.cancel();
	    }
	    return new Dimension(value, unit);
	};
	Dimension.prototype.compare = function (other) {
	    var a, b;

	    if (!(other instanceof Dimension)) {
	        return undefined;
	    }

	    if (this.unit.isEmpty() || other.unit.isEmpty()) {
	        a = this;
	        b = other;
	    } else {
	        a = this.unify();
	        b = other.unify();
	        if (a.unit.compare(b.unit) !== 0) {
	            return undefined;
	        }
	    }

	    return Node.numericCompare(a.value, b.value);
	};
	Dimension.prototype.unify = function () {
	    return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });
	};
	Dimension.prototype.convertTo = function (conversions) {
	    var value = this.value, unit = this.unit.clone(),
	        i, groupName, group, targetUnit, derivedConversions = {}, applyUnit;

	    if (typeof conversions === 'string') {
	        for (i in unitConversions) {
	            if (unitConversions[i].hasOwnProperty(conversions)) {
	                derivedConversions = {};
	                derivedConversions[i] = conversions;
	            }
	        }
	        conversions = derivedConversions;
	    }
	    applyUnit = function (atomicUnit, denominator) {
	        /* jshint loopfunc:true */
	        if (group.hasOwnProperty(atomicUnit)) {
	            if (denominator) {
	                value = value / (group[atomicUnit] / group[targetUnit]);
	            } else {
	                value = value * (group[atomicUnit] / group[targetUnit]);
	            }

	            return targetUnit;
	        }

	        return atomicUnit;
	    };

	    for (groupName in conversions) {
	        if (conversions.hasOwnProperty(groupName)) {
	            targetUnit = conversions[groupName];
	            group = unitConversions[groupName];

	            unit.map(applyUnit);
	        }
	    }

	    unit.cancel();

	    return new Dimension(value, unit);
	};
	module.exports = Dimension;

	},{"../data/unit-conversions":14,"./color":50,"./node":70,"./unit":79}],57:[function(require,module,exports){
	var Node = require("./node"),
	    Selector = require("./selector"),
	    Ruleset = require("./ruleset");

	var Directive = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {
	    var i;

	    this.name  = name;
	    this.value = value;
	    if (rules) {
	        if (Array.isArray(rules)) {
	            this.rules = rules;
	        } else {
	            this.rules = [rules];
	            this.rules[0].selectors = (new Selector([], null, null, this.index, currentFileInfo)).createEmptySelectors();
	        }
	        for (i = 0; i < this.rules.length; i++) {
	            this.rules[i].allowImports = true;
	        }
	    }
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;
	    this.debugInfo = debugInfo;
	    this.isRooted = isRooted || false;
	    this.copyVisibilityInfo(visibilityInfo);
	};

	Directive.prototype = new Node();
	Directive.prototype.type = "Directive";
	Directive.prototype.accept = function (visitor) {
	    var value = this.value, rules = this.rules;
	    if (rules) {
	        this.rules = visitor.visitArray(rules);
	    }
	    if (value) {
	        this.value = visitor.visit(value);
	    }
	};
	Directive.prototype.isRulesetLike = function() {
	    return this.rules || !this.isCharset();
	};
	Directive.prototype.isCharset = function() {
	    return "@charset" === this.name;
	};
	Directive.prototype.genCSS = function (context, output) {
	    var value = this.value, rules = this.rules;
	    output.add(this.name, this.currentFileInfo, this.index);
	    if (value) {
	        output.add(' ');
	        value.genCSS(context, output);
	    }
	    if (rules) {
	        this.outputRuleset(context, output, rules);
	    } else {
	        output.add(';');
	    }
	};
	Directive.prototype.eval = function (context) {
	    var mediaPathBackup, mediaBlocksBackup, value = this.value, rules = this.rules;

	    //media stored inside other directive should not bubble over it
	    //backpup media bubbling information
	    mediaPathBackup = context.mediaPath;
	    mediaBlocksBackup = context.mediaBlocks;
	    //deleted media bubbling information
	    context.mediaPath = [];
	    context.mediaBlocks = [];

	    if (value) {
	        value = value.eval(context);
	    }
	    if (rules) {
	        // assuming that there is only one rule at this point - that is how parser constructs the rule
	        rules = [rules[0].eval(context)];
	        rules[0].root = true;
	    }
	    //restore media bubbling information
	    context.mediaPath = mediaPathBackup;
	    context.mediaBlocks = mediaBlocksBackup;

	    return new Directive(this.name, value, rules,
	        this.index, this.currentFileInfo, this.debugInfo, this.isRooted, this.visibilityInfo());
	};
	Directive.prototype.variable = function (name) {
	    if (this.rules) {
	        // assuming that there is only one rule at this point - that is how parser constructs the rule
	        return Ruleset.prototype.variable.call(this.rules[0], name);
	    }
	};
	Directive.prototype.find = function () {
	    if (this.rules) {
	        // assuming that there is only one rule at this point - that is how parser constructs the rule
	        return Ruleset.prototype.find.apply(this.rules[0], arguments);
	    }
	};
	Directive.prototype.rulesets = function () {
	    if (this.rules) {
	        // assuming that there is only one rule at this point - that is how parser constructs the rule
	        return Ruleset.prototype.rulesets.apply(this.rules[0]);
	    }
	};
	Directive.prototype.outputRuleset = function (context, output, rules) {
	    var ruleCnt = rules.length, i;
	    context.tabLevel = (context.tabLevel | 0) + 1;

	    // Compressed
	    if (context.compress) {
	        output.add('{');
	        for (i = 0; i < ruleCnt; i++) {
	            rules[i].genCSS(context, output);
	        }
	        output.add('}');
	        context.tabLevel--;
	        return;
	    }

	    // Non-compressed
	    var tabSetStr = '\n' + Array(context.tabLevel).join("  "), tabRuleStr = tabSetStr + "  ";
	    if (!ruleCnt) {
	        output.add(" {" + tabSetStr + '}');
	    } else {
	        output.add(" {" + tabRuleStr);
	        rules[0].genCSS(context, output);
	        for (i = 1; i < ruleCnt; i++) {
	            output.add(tabRuleStr);
	            rules[i].genCSS(context, output);
	        }
	        output.add(tabSetStr + '}');
	    }

	    context.tabLevel--;
	};
	module.exports = Directive;

	},{"./node":70,"./ruleset":76,"./selector":77}],58:[function(require,module,exports){
	var Node = require("./node"),
	    Paren = require("./paren"),
	    Combinator = require("./combinator");

	var Element = function (combinator, value, index, currentFileInfo, info) {
	    this.combinator = combinator instanceof Combinator ?
	                      combinator : new Combinator(combinator);

	    if (typeof value === 'string') {
	        this.value = value.trim();
	    } else if (value) {
	        this.value = value;
	    } else {
	        this.value = "";
	    }
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;
	    this.copyVisibilityInfo(info);
	};
	Element.prototype = new Node();
	Element.prototype.type = "Element";
	Element.prototype.accept = function (visitor) {
	    var value = this.value;
	    this.combinator = visitor.visit(this.combinator);
	    if (typeof value === "object") {
	        this.value = visitor.visit(value);
	    }
	};
	Element.prototype.eval = function (context) {
	    return new Element(this.combinator,
	                             this.value.eval ? this.value.eval(context) : this.value,
	                             this.index,
	                             this.currentFileInfo, this.visibilityInfo());
	};
	Element.prototype.clone = function () {
	    return new Element(this.combinator,
	        this.value,
	        this.index,
	        this.currentFileInfo, this.visibilityInfo());
	};
	Element.prototype.genCSS = function (context, output) {
	    output.add(this.toCSS(context), this.currentFileInfo, this.index);
	};
	Element.prototype.toCSS = function (context) {
	    context = context || {};
	    var value = this.value, firstSelector = context.firstSelector;
	    if (value instanceof Paren) {
	        // selector in parens should not be affected by outer selector
	        // flags (breaks only interpolated selectors - see #1973)
	        context.firstSelector = true;
	    }
	    value = value.toCSS ? value.toCSS(context) : value;
	    context.firstSelector = firstSelector;
	    if (value === '' && this.combinator.value.charAt(0) === '&') {
	        return '';
	    } else {
	        return this.combinator.toCSS(context) + value;
	    }
	};
	module.exports = Element;

	},{"./combinator":51,"./node":70,"./paren":72}],59:[function(require,module,exports){
	var Node = require("./node"),
	    Paren = require("./paren"),
	    Comment = require("./comment");

	var Expression = function (value) {
	    this.value = value;
	    if (!value) {
	        throw new Error("Expression requires an array parameter");
	    }
	};
	Expression.prototype = new Node();
	Expression.prototype.type = "Expression";
	Expression.prototype.accept = function (visitor) {
	    this.value = visitor.visitArray(this.value);
	};
	Expression.prototype.eval = function (context) {
	    var returnValue,
	        inParenthesis = this.parens && !this.parensInOp,
	        doubleParen = false;
	    if (inParenthesis) {
	        context.inParenthesis();
	    }
	    if (this.value.length > 1) {
	        returnValue = new Expression(this.value.map(function (e) {
	            return e.eval(context);
	        }));
	    } else if (this.value.length === 1) {
	        if (this.value[0].parens && !this.value[0].parensInOp) {
	            doubleParen = true;
	        }
	        returnValue = this.value[0].eval(context);
	    } else {
	        returnValue = this;
	    }
	    if (inParenthesis) {
	        context.outOfParenthesis();
	    }
	    if (this.parens && this.parensInOp && !(context.isMathOn()) && !doubleParen) {
	        returnValue = new Paren(returnValue);
	    }
	    return returnValue;
	};
	Expression.prototype.genCSS = function (context, output) {
	    for (var i = 0; i < this.value.length; i++) {
	        this.value[i].genCSS(context, output);
	        if (i + 1 < this.value.length) {
	            output.add(" ");
	        }
	    }
	};
	Expression.prototype.throwAwayComments = function () {
	    this.value = this.value.filter(function(v) {
	        return !(v instanceof Comment);
	    });
	};
	module.exports = Expression;

	},{"./comment":52,"./node":70,"./paren":72}],60:[function(require,module,exports){
	var Node = require("./node"),
	    Selector = require("./selector");

	var Extend = function Extend(selector, option, index, currentFileInfo, visibilityInfo) {
	    this.selector = selector;
	    this.option = option;
	    this.index = index;
	    this.object_id = Extend.next_id++;
	    this.parent_ids = [this.object_id];
	    this.currentFileInfo = currentFileInfo || {};
	    this.copyVisibilityInfo(visibilityInfo);

	    switch(option) {
	        case "all":
	            this.allowBefore = true;
	            this.allowAfter = true;
	            break;
	        default:
	            this.allowBefore = false;
	            this.allowAfter = false;
	            break;
	    }
	};
	Extend.next_id = 0;

	Extend.prototype = new Node();
	Extend.prototype.type = "Extend";
	Extend.prototype.accept = function (visitor) {
	    this.selector = visitor.visit(this.selector);
	};
	Extend.prototype.eval = function (context) {
	    return new Extend(this.selector.eval(context), this.option, this.index, this.currentFileInfo, this.visibilityInfo());
	};
	Extend.prototype.clone = function (context) {
	    return new Extend(this.selector, this.option, this.index, this.currentFileInfo, this.visibilityInfo());
	};
	//it concatenates (joins) all selectors in selector array
	Extend.prototype.findSelfSelectors = function (selectors) {
	    var selfElements = [],
	        i,
	        selectorElements;

	    for (i = 0; i < selectors.length; i++) {
	        selectorElements = selectors[i].elements;
	        // duplicate the logic in genCSS function inside the selector node.
	        // future TODO - move both logics into the selector joiner visitor
	        if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === "") {
	            selectorElements[0].combinator.value = ' ';
	        }
	        selfElements = selfElements.concat(selectors[i].elements);
	    }

	    this.selfSelectors = [new Selector(selfElements)];
	    this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());
	};
	module.exports = Extend;

	},{"./node":70,"./selector":77}],61:[function(require,module,exports){
	var Node = require("./node"),
	    Media = require("./media"),
	    URL = require("./url"),
	    Quoted = require("./quoted"),
	    Ruleset = require("./ruleset"),
	    Anonymous = require("./anonymous");

	//
	// CSS @import node
	//
	// The general strategy here is that we don't want to wait
	// for the parsing to be completed, before we start importing
	// the file. That's because in the context of a browser,
	// most of the time will be spent waiting for the server to respond.
	//
	// On creation, we push the import path to our import queue, though
	// `import,push`, we also pass it a callback, which it'll call once
	// the file has been fetched, and parsed.
	//
	var Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {
	    this.options = options;
	    this.index = index;
	    this.path = path;
	    this.features = features;
	    this.currentFileInfo = currentFileInfo;

	    if (this.options.less !== undefined || this.options.inline) {
	        this.css = !this.options.less || this.options.inline;
	    } else {
	        var pathValue = this.getPath();
	        if (pathValue && /[#\.\&\?\/]css([\?;].*)?$/.test(pathValue)) {
	            this.css = true;
	        }
	    }
	    this.copyVisibilityInfo(visibilityInfo);
	};

	//
	// The actual import node doesn't return anything, when converted to CSS.
	// The reason is that it's used at the evaluation stage, so that the rules
	// it imports can be treated like any other rules.
	//
	// In `eval`, we make sure all Import nodes get evaluated, recursively, so
	// we end up with a flat structure, which can easily be imported in the parent
	// ruleset.
	//
	Import.prototype = new Node();
	Import.prototype.type = "Import";
	Import.prototype.accept = function (visitor) {
	    if (this.features) {
	        this.features = visitor.visit(this.features);
	    }
	    this.path = visitor.visit(this.path);
	    if (!this.options.plugin && !this.options.inline && this.root) {
	        this.root = visitor.visit(this.root);
	    }
	};
	Import.prototype.genCSS = function (context, output) {
	    if (this.css && this.path.currentFileInfo.reference === undefined) {
	        output.add("@import ", this.currentFileInfo, this.index);
	        this.path.genCSS(context, output);
	        if (this.features) {
	            output.add(" ");
	            this.features.genCSS(context, output);
	        }
	        output.add(';');
	    }
	};
	Import.prototype.getPath = function () {
	    return (this.path instanceof URL) ?
	        this.path.value.value : this.path.value;
	};
	Import.prototype.isVariableImport = function () {
	    var path = this.path;
	    if (path instanceof URL) {
	        path = path.value;
	    }
	    if (path instanceof Quoted) {
	        return path.containsVariables();
	    }

	    return true;
	};
	Import.prototype.evalForImport = function (context) {
	    var path = this.path;

	    if (path instanceof URL) {
	        path = path.value;
	    }

	    return new Import(path.eval(context), this.features, this.options, this.index, this.currentFileInfo, this.visibilityInfo());
	};
	Import.prototype.evalPath = function (context) {
	    var path = this.path.eval(context);
	    var rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;

	    if (!(path instanceof URL)) {
	        if (rootpath) {
	            var pathValue = path.value;
	            // Add the base path if the import is relative
	            if (pathValue && context.isPathRelative(pathValue)) {
	                path.value = rootpath + pathValue;
	            }
	        }
	        path.value = context.normalizePath(path.value);
	    }

	    return path;
	};
	Import.prototype.eval = function (context) {
	    var result = this.doEval(context);
	    if (this.options.reference || this.blocksVisibility()) {
	        if (result.length || result.length === 0) {
	            result.forEach(function (node) {
	                    node.addVisibilityBlock();
	                }
	            );
	        } else {
	            result.addVisibilityBlock();
	        }
	    }
	    return result;
	};
	Import.prototype.doEval = function (context) {
	    var ruleset, registry,
	        features = this.features && this.features.eval(context);

	    if (this.options.plugin) {
	        registry = context.frames[0] && context.frames[0].functionRegistry;
	        if ( registry && this.root && this.root.functions ) {
	            registry.addMultiple( this.root.functions );
	        }
	        return [];
	    }

	    if (this.skip) {
	        if (typeof this.skip === "function") {
	            this.skip = this.skip();
	        }
	        if (this.skip) {
	            return [];
	        }
	    }
	    if (this.options.inline) {
	        var contents = new Anonymous(this.root, 0,
	          {
	              filename: this.importedFilename,
	              reference: this.path.currentFileInfo && this.path.currentFileInfo.reference
	          }, true, true);

	        return this.features ? new Media([contents], this.features.value) : [contents];
	    } else if (this.css) {
	        var newImport = new Import(this.evalPath(context), features, this.options, this.index);
	        if (!newImport.css && this.error) {
	            throw this.error;
	        }
	        return newImport;
	    } else {
	        ruleset = new Ruleset(null, this.root.rules.slice(0));
	        ruleset.evalImports(context);

	        return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;
	    }
	};
	module.exports = Import;

	},{"./anonymous":46,"./media":66,"./node":70,"./quoted":73,"./ruleset":76,"./url":80}],62:[function(require,module,exports){
	var tree = {};

	tree.Node = require('./node');
	tree.Alpha = require('./alpha');
	tree.Color = require('./color');
	tree.Directive = require('./directive');
	tree.DetachedRuleset = require('./detached-ruleset');
	tree.Operation = require('./operation');
	tree.Dimension = require('./dimension');
	tree.Unit = require('./unit');
	tree.Keyword = require('./keyword');
	tree.Variable = require('./variable');
	tree.Ruleset = require('./ruleset');
	tree.Element = require('./element');
	tree.Attribute = require('./attribute');
	tree.Combinator = require('./combinator');
	tree.Selector = require('./selector');
	tree.Quoted = require('./quoted');
	tree.Expression = require('./expression');
	tree.Rule = require('./rule');
	tree.Call = require('./call');
	tree.URL = require('./url');
	tree.Import = require('./import');
	tree.mixin = {
	    Call: require('./mixin-call'),
	    Definition: require('./mixin-definition')
	};
	tree.Comment = require('./comment');
	tree.Anonymous = require('./anonymous');
	tree.Value = require('./value');
	tree.JavaScript = require('./javascript');
	tree.Assignment = require('./assignment');
	tree.Condition = require('./condition');
	tree.Paren = require('./paren');
	tree.Media = require('./media');
	tree.UnicodeDescriptor = require('./unicode-descriptor');
	tree.Negative = require('./negative');
	tree.Extend = require('./extend');
	tree.RulesetCall = require('./ruleset-call');

	module.exports = tree;

	},{"./alpha":45,"./anonymous":46,"./assignment":47,"./attribute":48,"./call":49,"./color":50,"./combinator":51,"./comment":52,"./condition":53,"./detached-ruleset":55,"./dimension":56,"./directive":57,"./element":58,"./expression":59,"./extend":60,"./import":61,"./javascript":63,"./keyword":65,"./media":66,"./mixin-call":67,"./mixin-definition":68,"./negative":69,"./node":70,"./operation":71,"./paren":72,"./quoted":73,"./rule":74,"./ruleset":76,"./ruleset-call":75,"./selector":77,"./unicode-descriptor":78,"./unit":79,"./url":80,"./value":81,"./variable":82}],63:[function(require,module,exports){
	var JsEvalNode = require("./js-eval-node"),
	    Dimension = require("./dimension"),
	    Quoted = require("./quoted"),
	    Anonymous = require("./anonymous");

	var JavaScript = function (string, escaped, index, currentFileInfo) {
	    this.escaped = escaped;
	    this.expression = string;
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;
	};
	JavaScript.prototype = new JsEvalNode();
	JavaScript.prototype.type = "JavaScript";
	JavaScript.prototype.eval = function(context) {
	    var result = this.evaluateJavaScript(this.expression, context);

	    if (typeof result === 'number') {
	        return new Dimension(result);
	    } else if (typeof result === 'string') {
	        return new Quoted('"' + result + '"', result, this.escaped, this.index);
	    } else if (Array.isArray(result)) {
	        return new Anonymous(result.join(', '));
	    } else {
	        return new Anonymous(result);
	    }
	};

	module.exports = JavaScript;

	},{"./anonymous":46,"./dimension":56,"./js-eval-node":64,"./quoted":73}],64:[function(require,module,exports){
	var Node = require("./node"),
	    Variable = require("./variable");

	var JsEvalNode = function() {
	};
	JsEvalNode.prototype = new Node();

	JsEvalNode.prototype.evaluateJavaScript = function (expression, context) {
	    var result,
	        that = this,
	        evalContext = {};

	    if (context.javascriptEnabled !== undefined && !context.javascriptEnabled) {
	        throw { message: "You are using JavaScript, which has been disabled.",
	            filename: this.currentFileInfo.filename,
	            index: this.index };
	    }

	    expression = expression.replace(/@\{([\w-]+)\}/g, function (_, name) {
	        return that.jsify(new Variable('@' + name, that.index, that.currentFileInfo).eval(context));
	    });

	    try {
	        expression = new Function('return (' + expression + ')');
	    } catch (e) {
	        throw { message: "JavaScript evaluation error: " + e.message + " from `" + expression + "`" ,
	            filename: this.currentFileInfo.filename,
	            index: this.index };
	    }

	    var variables = context.frames[0].variables();
	    for (var k in variables) {
	        if (variables.hasOwnProperty(k)) {
	            /*jshint loopfunc:true */
	            evalContext[k.slice(1)] = {
	                value: variables[k].value,
	                toJS: function () {
	                    return this.value.eval(context).toCSS();
	                }
	            };
	        }
	    }

	    try {
	        result = expression.call(evalContext);
	    } catch (e) {
	        throw { message: "JavaScript evaluation error: '" + e.name + ': ' + e.message.replace(/["]/g, "'") + "'" ,
	            filename: this.currentFileInfo.filename,
	            index: this.index };
	    }
	    return result;
	};
	JsEvalNode.prototype.jsify = function (obj) {
	    if (Array.isArray(obj.value) && (obj.value.length > 1)) {
	        return '[' + obj.value.map(function (v) { return v.toCSS(); }).join(', ') + ']';
	    } else {
	        return obj.toCSS();
	    }
	};

	module.exports = JsEvalNode;

	},{"./node":70,"./variable":82}],65:[function(require,module,exports){
	var Node = require("./node");

	var Keyword = function (value) { this.value = value; };
	Keyword.prototype = new Node();
	Keyword.prototype.type = "Keyword";
	Keyword.prototype.genCSS = function (context, output) {
	    if (this.value === '%') { throw { type: "Syntax", message: "Invalid % without number" }; }
	    output.add(this.value);
	};

	Keyword.True = new Keyword('true');
	Keyword.False = new Keyword('false');

	module.exports = Keyword;

	},{"./node":70}],66:[function(require,module,exports){
	var Ruleset = require("./ruleset"),
	    Value = require("./value"),
	    Selector = require("./selector"),
	    Anonymous = require("./anonymous"),
	    Expression = require("./expression"),
	    Directive = require("./directive");

	var Media = function (value, features, index, currentFileInfo, visibilityInfo) {
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;

	    var selectors = (new Selector([], null, null, this.index, this.currentFileInfo)).createEmptySelectors();

	    this.features = new Value(features);
	    this.rules = [new Ruleset(selectors, value)];
	    this.rules[0].allowImports = true;
	    this.copyVisibilityInfo(visibilityInfo);
	};
	Media.prototype = new Directive();
	Media.prototype.type = "Media";
	Media.prototype.isRulesetLike = true;
	Media.prototype.accept = function (visitor) {
	    if (this.features) {
	        this.features = visitor.visit(this.features);
	    }
	    if (this.rules) {
	        this.rules = visitor.visitArray(this.rules);
	    }
	};
	Media.prototype.genCSS = function (context, output) {
	    output.add('@media ', this.currentFileInfo, this.index);
	    this.features.genCSS(context, output);
	    this.outputRuleset(context, output, this.rules);
	};
	Media.prototype.eval = function (context) {
	    if (!context.mediaBlocks) {
	        context.mediaBlocks = [];
	        context.mediaPath = [];
	    }

	    var media = new Media(null, [], this.index, this.currentFileInfo, this.visibilityInfo());
	    if (this.debugInfo) {
	        this.rules[0].debugInfo = this.debugInfo;
	        media.debugInfo = this.debugInfo;
	    }
	    var strictMathBypass = false;
	    if (!context.strictMath) {
	        strictMathBypass = true;
	        context.strictMath = true;
	    }
	    try {
	        media.features = this.features.eval(context);
	    }
	    finally {
	        if (strictMathBypass) {
	            context.strictMath = false;
	        }
	    }

	    context.mediaPath.push(media);
	    context.mediaBlocks.push(media);

	    this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
	    context.frames.unshift(this.rules[0]);
	    media.rules = [this.rules[0].eval(context)];
	    context.frames.shift();

	    context.mediaPath.pop();

	    return context.mediaPath.length === 0 ? media.evalTop(context) :
	                media.evalNested(context);
	};
	Media.prototype.evalTop = function (context) {
	    var result = this;

	    // Render all dependent Media blocks.
	    if (context.mediaBlocks.length > 1) {
	        var selectors = (new Selector([], null, null, this.index, this.currentFileInfo)).createEmptySelectors();
	        result = new Ruleset(selectors, context.mediaBlocks);
	        result.multiMedia = true;
	        result.copyVisibilityInfo(this.visibilityInfo());
	    }

	    delete context.mediaBlocks;
	    delete context.mediaPath;

	    return result;
	};
	Media.prototype.evalNested = function (context) {
	    var i, value,
	        path = context.mediaPath.concat([this]);

	    // Extract the media-query conditions separated with `,` (OR).
	    for (i = 0; i < path.length; i++) {
	        value = path[i].features instanceof Value ?
	                    path[i].features.value : path[i].features;
	        path[i] = Array.isArray(value) ? value : [value];
	    }

	    // Trace all permutations to generate the resulting media-query.
	    //
	    // (a, b and c) with nested (d, e) ->
	    //    a and d
	    //    a and e
	    //    b and c and d
	    //    b and c and e
	    this.features = new Value(this.permute(path).map(function (path) {
	        path = path.map(function (fragment) {
	            return fragment.toCSS ? fragment : new Anonymous(fragment);
	        });

	        for (i = path.length - 1; i > 0; i--) {
	            path.splice(i, 0, new Anonymous("and"));
	        }

	        return new Expression(path);
	    }));

	    // Fake a tree-node that doesn't output anything.
	    return new Ruleset([], []);
	};
	Media.prototype.permute = function (arr) {
	    if (arr.length === 0) {
	        return [];
	    } else if (arr.length === 1) {
	        return arr[0];
	    } else {
	        var result = [];
	        var rest = this.permute(arr.slice(1));
	        for (var i = 0; i < rest.length; i++) {
	            for (var j = 0; j < arr[0].length; j++) {
	                result.push([arr[0][j]].concat(rest[i]));
	            }
	        }
	        return result;
	    }
	};
	Media.prototype.bubbleSelectors = function (selectors) {
	    if (!selectors) {
	        return;
	    }
	    this.rules = [new Ruleset(selectors.slice(0), [this.rules[0]])];
	};
	module.exports = Media;

	},{"./anonymous":46,"./directive":57,"./expression":59,"./ruleset":76,"./selector":77,"./value":81}],67:[function(require,module,exports){
	var Node = require("./node"),
	    Selector = require("./selector"),
	    MixinDefinition = require("./mixin-definition"),
	    defaultFunc = require("../functions/default");

	var MixinCall = function (elements, args, index, currentFileInfo, important) {
	    this.selector = new Selector(elements);
	    this.arguments = args || [];
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;
	    this.important = important;
	};
	MixinCall.prototype = new Node();
	MixinCall.prototype.type = "MixinCall";
	MixinCall.prototype.accept = function (visitor) {
	    if (this.selector) {
	        this.selector = visitor.visit(this.selector);
	    }
	    if (this.arguments.length) {
	        this.arguments = visitor.visitArray(this.arguments);
	    }
	};
	MixinCall.prototype.eval = function (context) {
	    var mixins, mixin, mixinPath, args = [], arg, argValue,
	        rules = [], match = false, i, m, f, isRecursive, isOneFound,
	        candidates = [], candidate, conditionResult = [], defaultResult, defFalseEitherCase = -1,
	        defNone = 0, defTrue = 1, defFalse = 2, count, originalRuleset, noArgumentsFilter;

	    function calcDefGroup(mixin, mixinPath) {
	        var f, p, namespace;

	        for (f = 0; f < 2; f++) {
	            conditionResult[f] = true;
	            defaultFunc.value(f);
	            for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {
	                namespace = mixinPath[p];
	                if (namespace.matchCondition) {
	                    conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);
	                }
	            }
	            if (mixin.matchCondition) {
	                conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);
	            }
	        }
	        if (conditionResult[0] || conditionResult[1]) {
	            if (conditionResult[0] != conditionResult[1]) {
	                return conditionResult[1] ?
	                    defTrue : defFalse;
	            }

	            return defNone;
	        }
	        return defFalseEitherCase;
	    }

	    for (i = 0; i < this.arguments.length; i++) {
	        arg = this.arguments[i];
	        argValue = arg.value.eval(context);
	        if (arg.expand && Array.isArray(argValue.value)) {
	            argValue = argValue.value;
	            for (m = 0; m < argValue.length; m++) {
	                args.push({value: argValue[m]});
	            }
	        } else {
	            args.push({name: arg.name, value: argValue});
	        }
	    }

	    noArgumentsFilter = function(rule) {return rule.matchArgs(null, context);};

	    for (i = 0; i < context.frames.length; i++) {
	        if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {
	            isOneFound = true;

	            // To make `default()` function independent of definition order we have two "subpasses" here.
	            // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),
	            // and build candidate list with corresponding flags. Then, when we know all possible matches,
	            // we make a final decision.

	            for (m = 0; m < mixins.length; m++) {
	                mixin = mixins[m].rule;
	                mixinPath = mixins[m].path;
	                isRecursive = false;
	                for (f = 0; f < context.frames.length; f++) {
	                    if ((!(mixin instanceof MixinDefinition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {
	                        isRecursive = true;
	                        break;
	                    }
	                }
	                if (isRecursive) {
	                    continue;
	                }

	                if (mixin.matchArgs(args, context)) {
	                    candidate = {mixin: mixin, group: calcDefGroup(mixin, mixinPath)};

	                    if (candidate.group !== defFalseEitherCase) {
	                        candidates.push(candidate);
	                    }

	                    match = true;
	                }
	            }

	            defaultFunc.reset();

	            count = [0, 0, 0];
	            for (m = 0; m < candidates.length; m++) {
	                count[candidates[m].group]++;
	            }

	            if (count[defNone] > 0) {
	                defaultResult = defFalse;
	            } else {
	                defaultResult = defTrue;
	                if ((count[defTrue] + count[defFalse]) > 1) {
	                    throw { type: 'Runtime',
	                        message: 'Ambiguous use of `default()` found when matching for `' + this.format(args) + '`',
	                        index: this.index, filename: this.currentFileInfo.filename };
	                }
	            }

	            for (m = 0; m < candidates.length; m++) {
	                candidate = candidates[m].group;
	                if ((candidate === defNone) || (candidate === defaultResult)) {
	                    try {
	                        mixin = candidates[m].mixin;
	                        if (!(mixin instanceof MixinDefinition)) {
	                            originalRuleset = mixin.originalRuleset || mixin;
	                            mixin = new MixinDefinition("", [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());
	                            mixin.originalRuleset = originalRuleset;
	                        }
	                        var newRules = mixin.evalCall(context, args, this.important).rules;
	                        this._setVisibilityToReplacement(newRules);
	                        Array.prototype.push.apply(rules, newRules);
	                    } catch (e) {
	                        throw { message: e.message, index: this.index, filename: this.currentFileInfo.filename, stack: e.stack };
	                    }
	                }
	            }

	            if (match) {
	                return rules;
	            }
	        }
	    }
	    if (isOneFound) {
	        throw { type:    'Runtime',
	            message: 'No matching definition was found for `' + this.format(args) + '`',
	            index:   this.index, filename: this.currentFileInfo.filename };
	    } else {
	        throw { type:    'Name',
	            message: this.selector.toCSS().trim() + " is undefined",
	            index:   this.index, filename: this.currentFileInfo.filename };
	    }
	};

	MixinCall.prototype._setVisibilityToReplacement = function (replacement) {
	    var i, rule;
	    if (this.blocksVisibility()) {
	        for (i = 0; i < replacement.length; i++) {
	            rule = replacement[i];
	            rule.addVisibilityBlock();
	        }
	    }
	};
	MixinCall.prototype.format = function (args) {
	    return this.selector.toCSS().trim() + '(' +
	        (args ? args.map(function (a) {
	            var argValue = "";
	            if (a.name) {
	                argValue += a.name + ":";
	            }
	            if (a.value.toCSS) {
	                argValue += a.value.toCSS();
	            } else {
	                argValue += "???";
	            }
	            return argValue;
	        }).join(', ') : "") + ")";
	};
	module.exports = MixinCall;

	},{"../functions/default":20,"./mixin-definition":68,"./node":70,"./selector":77}],68:[function(require,module,exports){
	var Selector = require("./selector"),
	    Element = require("./element"),
	    Ruleset = require("./ruleset"),
	    Rule = require("./rule"),
	    Expression = require("./expression"),
	    contexts = require("../contexts");

	var Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {
	    this.name = name;
	    this.selectors = [new Selector([new Element(null, name, this.index, this.currentFileInfo)])];
	    this.params = params;
	    this.condition = condition;
	    this.variadic = variadic;
	    this.arity = params.length;
	    this.rules = rules;
	    this._lookups = {};
	    var optionalParameters = [];
	    this.required = params.reduce(function (count, p) {
	        if (!p.name || (p.name && !p.value)) {
	            return count + 1;
	        }
	        else {
	            optionalParameters.push(p.name);
	            return count;
	        }
	    }, 0);
	    this.optionalParameters = optionalParameters;
	    this.frames = frames;
	    this.copyVisibilityInfo(visibilityInfo);
	};
	Definition.prototype = new Ruleset();
	Definition.prototype.type = "MixinDefinition";
	Definition.prototype.evalFirst = true;
	Definition.prototype.accept = function (visitor) {
	    if (this.params && this.params.length) {
	        this.params = visitor.visitArray(this.params);
	    }
	    this.rules = visitor.visitArray(this.rules);
	    if (this.condition) {
	        this.condition = visitor.visit(this.condition);
	    }
	};
	Definition.prototype.evalParams = function (context, mixinEnv, args, evaldArguments) {
	    /*jshint boss:true */
	    var frame = new Ruleset(null, null),
	        varargs, arg,
	        params = this.params.slice(0),
	        i, j, val, name, isNamedFound, argIndex, argsLength = 0;

	    if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {
	        frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();
	    }
	    mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));

	    if (args) {
	        args = args.slice(0);
	        argsLength = args.length;

	        for (i = 0; i < argsLength; i++) {
	            arg = args[i];
	            if (name = (arg && arg.name)) {
	                isNamedFound = false;
	                for (j = 0; j < params.length; j++) {
	                    if (!evaldArguments[j] && name === params[j].name) {
	                        evaldArguments[j] = arg.value.eval(context);
	                        frame.prependRule(new Rule(name, arg.value.eval(context)));
	                        isNamedFound = true;
	                        break;
	                    }
	                }
	                if (isNamedFound) {
	                    args.splice(i, 1);
	                    i--;
	                    continue;
	                } else {
	                    throw { type: 'Runtime', message: "Named argument for " + this.name +
	                        ' ' + args[i].name + ' not found' };
	                }
	            }
	        }
	    }
	    argIndex = 0;
	    for (i = 0; i < params.length; i++) {
	        if (evaldArguments[i]) { continue; }

	        arg = args && args[argIndex];

	        if (name = params[i].name) {
	            if (params[i].variadic) {
	                varargs = [];
	                for (j = argIndex; j < argsLength; j++) {
	                    varargs.push(args[j].value.eval(context));
	                }
	                frame.prependRule(new Rule(name, new Expression(varargs).eval(context)));
	            } else {
	                val = arg && arg.value;
	                if (val) {
	                    val = val.eval(context);
	                } else if (params[i].value) {
	                    val = params[i].value.eval(mixinEnv);
	                    frame.resetCache();
	                } else {
	                    throw { type: 'Runtime', message: "wrong number of arguments for " + this.name +
	                        ' (' + argsLength + ' for ' + this.arity + ')' };
	                }

	                frame.prependRule(new Rule(name, val));
	                evaldArguments[i] = val;
	            }
	        }

	        if (params[i].variadic && args) {
	            for (j = argIndex; j < argsLength; j++) {
	                evaldArguments[j] = args[j].value.eval(context);
	            }
	        }
	        argIndex++;
	    }

	    return frame;
	};
	Definition.prototype.makeImportant = function() {
	    var rules = !this.rules ? this.rules : this.rules.map(function (r) {
	        if (r.makeImportant) {
	            return r.makeImportant(true);
	        } else {
	            return r;
	        }
	    });
	    var result = new Definition (this.name, this.params, rules, this.condition, this.variadic, this.frames);
	    return result;
	};
	Definition.prototype.eval = function (context) {
	    return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || context.frames.slice(0));
	};
	Definition.prototype.evalCall = function (context, args, important) {
	    var _arguments = [],
	        mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames,
	        frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments),
	        rules, ruleset;

	    frame.prependRule(new Rule('@arguments', new Expression(_arguments).eval(context)));

	    rules = this.rules.slice(0);

	    ruleset = new Ruleset(null, rules);
	    ruleset.originalRuleset = this;
	    ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));
	    if (important) {
	        ruleset = ruleset.makeImportant();
	    }
	    return ruleset;
	};
	Definition.prototype.matchCondition = function (args, context) {
	    if (this.condition && !this.condition.eval(
	        new contexts.Eval(context,
	            [this.evalParams(context, /* the parameter variables*/
	                new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]
	            .concat(this.frames || []) // the parent namespace/mixin frames
	            .concat(context.frames)))) { // the current environment frames
	        return false;
	    }
	    return true;
	};
	Definition.prototype.matchArgs = function (args, context) {
	    var allArgsCnt = (args && args.length) || 0, len, optionalParameters = this.optionalParameters;
	    var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {
	        if (optionalParameters.indexOf(p.name) < 0) {
	            return count + 1;
	        } else {
	            return count;
	        }
	    }, 0);

	    if (! this.variadic) {
	        if (requiredArgsCnt < this.required) {
	            return false;
	        }
	        if (allArgsCnt > this.params.length) {
	            return false;
	        }
	    } else {
	        if (requiredArgsCnt < (this.required - 1)) {
	            return false;
	        }
	    }

	    // check patterns
	    len = Math.min(requiredArgsCnt, this.arity);

	    for (var i = 0; i < len; i++) {
	        if (!this.params[i].name && !this.params[i].variadic) {
	            if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {
	                return false;
	            }
	        }
	    }
	    return true;
	};
	module.exports = Definition;

	},{"../contexts":11,"./element":58,"./expression":59,"./rule":74,"./ruleset":76,"./selector":77}],69:[function(require,module,exports){
	var Node = require("./node"),
	    Operation = require("./operation"),
	    Dimension = require("./dimension");

	var Negative = function (node) {
	    this.value = node;
	};
	Negative.prototype = new Node();
	Negative.prototype.type = "Negative";
	Negative.prototype.genCSS = function (context, output) {
	    output.add('-');
	    this.value.genCSS(context, output);
	};
	Negative.prototype.eval = function (context) {
	    if (context.isMathOn()) {
	        return (new Operation('*', [new Dimension(-1), this.value])).eval(context);
	    }
	    return new Negative(this.value.eval(context));
	};
	module.exports = Negative;

	},{"./dimension":56,"./node":70,"./operation":71}],70:[function(require,module,exports){
	var Node = function() {
	};
	Node.prototype.toCSS = function (context) {
	    var strs = [];
	    this.genCSS(context, {
	        add: function(chunk, fileInfo, index) {
	            strs.push(chunk);
	        },
	        isEmpty: function () {
	            return strs.length === 0;
	        }
	    });
	    return strs.join('');
	};
	Node.prototype.genCSS = function (context, output) {
	    output.add(this.value);
	};
	Node.prototype.accept = function (visitor) {
	    this.value = visitor.visit(this.value);
	};
	Node.prototype.eval = function () { return this; };
	Node.prototype._operate = function (context, op, a, b) {
	    switch (op) {
	        case '+': return a + b;
	        case '-': return a - b;
	        case '*': return a * b;
	        case '/': return a / b;
	    }
	};
	Node.prototype.fround = function(context, value) {
	    var precision = context && context.numPrecision;
	    //add "epsilon" to ensure numbers like 1.000000005 (represented as 1.000000004999....) are properly rounded...
	    return (precision == null) ? value : Number((value + 2e-16).toFixed(precision));
	};
	Node.compare = function (a, b) {
	    /* returns:
	     -1: a < b
	     0: a = b
	     1: a > b
	     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */

	    if ((a.compare) &&
	        // for "symmetric results" force toCSS-based comparison
	        // of Quoted or Anonymous if either value is one of those
	        !(b.type === "Quoted" || b.type === "Anonymous")) {
	        return a.compare(b);
	    } else if (b.compare) {
	        return -b.compare(a);
	    } else if (a.type !== b.type) {
	        return undefined;
	    }

	    a = a.value;
	    b = b.value;
	    if (!Array.isArray(a)) {
	        return a === b ? 0 : undefined;
	    }
	    if (a.length !== b.length) {
	        return undefined;
	    }
	    for (var i = 0; i < a.length; i++) {
	        if (Node.compare(a[i], b[i]) !== 0) {
	            return undefined;
	        }
	    }
	    return 0;
	};

	Node.numericCompare = function (a, b) {
	    return a  <  b ? -1
	        : a === b ?  0
	        : a  >  b ?  1 : undefined;
	};
	// Returns true if this node represents root of ast imported by reference
	Node.prototype.blocksVisibility = function () {
	    if (this.visibilityBlocks == null) {
	        this.visibilityBlocks = 0;
	    }
	    return this.visibilityBlocks !== 0;
	};
	Node.prototype.addVisibilityBlock = function () {
	    if (this.visibilityBlocks == null) {
	        this.visibilityBlocks = 0;
	    }
	    this.visibilityBlocks = this.visibilityBlocks + 1;
	};
	Node.prototype.removeVisibilityBlock = function () {
	    if (this.visibilityBlocks == null) {
	        this.visibilityBlocks = 0;
	    }
	    this.visibilityBlocks = this.visibilityBlocks - 1;
	};
	//Turns on node visibility - if called node will be shown in output regardless
	//of whether it comes from import by reference or not
	Node.prototype.ensureVisibility = function () {
	    this.nodeVisible = true;
	};
	//Turns off node visibility - if called node will NOT be shown in output regardless
	//of whether it comes from import by reference or not
	Node.prototype.ensureInvisibility = function () {
	    this.nodeVisible = false;
	};
	// return values:
	// false - the node must not be visible
	// true - the node must be visible
	// undefined or null - the node has the same visibility as its parent
	Node.prototype.isVisible = function () {
	    return this.nodeVisible;
	};
	Node.prototype.visibilityInfo = function() {
	    return {
	        visibilityBlocks: this.visibilityBlocks,
	        nodeVisible: this.nodeVisible
	    };
	};
	Node.prototype.copyVisibilityInfo = function(info) {
	    if (!info) {
	        return;
	    }
	    this.visibilityBlocks = info.visibilityBlocks;
	    this.nodeVisible = info.nodeVisible;
	};
	module.exports = Node;

	},{}],71:[function(require,module,exports){
	var Node = require("./node"),
	    Color = require("./color"),
	    Dimension = require("./dimension");

	var Operation = function (op, operands, isSpaced) {
	    this.op = op.trim();
	    this.operands = operands;
	    this.isSpaced = isSpaced;
	};
	Operation.prototype = new Node();
	Operation.prototype.type = "Operation";
	Operation.prototype.accept = function (visitor) {
	    this.operands = visitor.visit(this.operands);
	};
	Operation.prototype.eval = function (context) {
	    var a = this.operands[0].eval(context),
	        b = this.operands[1].eval(context);

	    if (context.isMathOn()) {
	        if (a instanceof Dimension && b instanceof Color) {
	            a = a.toColor();
	        }
	        if (b instanceof Dimension && a instanceof Color) {
	            b = b.toColor();
	        }
	        if (!a.operate) {
	            throw { type: "Operation",
	                    message: "Operation on an invalid type" };
	        }

	        return a.operate(context, this.op, b);
	    } else {
	        return new Operation(this.op, [a, b], this.isSpaced);
	    }
	};
	Operation.prototype.genCSS = function (context, output) {
	    this.operands[0].genCSS(context, output);
	    if (this.isSpaced) {
	        output.add(" ");
	    }
	    output.add(this.op);
	    if (this.isSpaced) {
	        output.add(" ");
	    }
	    this.operands[1].genCSS(context, output);
	};

	module.exports = Operation;

	},{"./color":50,"./dimension":56,"./node":70}],72:[function(require,module,exports){
	var Node = require("./node");

	var Paren = function (node) {
	    this.value = node;
	};
	Paren.prototype = new Node();
	Paren.prototype.type = "Paren";
	Paren.prototype.genCSS = function (context, output) {
	    output.add('(');
	    this.value.genCSS(context, output);
	    output.add(')');
	};
	Paren.prototype.eval = function (context) {
	    return new Paren(this.value.eval(context));
	};
	module.exports = Paren;

	},{"./node":70}],73:[function(require,module,exports){
	var Node = require("./node"),
	    JsEvalNode = require("./js-eval-node"),
	    Variable = require("./variable");

	var Quoted = function (str, content, escaped, index, currentFileInfo) {
	    this.escaped = (escaped == null) ? true : escaped;
	    this.value = content || '';
	    this.quote = str.charAt(0);
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;
	};
	Quoted.prototype = new JsEvalNode();
	Quoted.prototype.type = "Quoted";
	Quoted.prototype.genCSS = function (context, output) {
	    if (!this.escaped) {
	        output.add(this.quote, this.currentFileInfo, this.index);
	    }
	    output.add(this.value);
	    if (!this.escaped) {
	        output.add(this.quote);
	    }
	};
	Quoted.prototype.containsVariables = function() {
	    return this.value.match(/(`([^`]+)`)|@\{([\w-]+)\}/);
	};
	Quoted.prototype.eval = function (context) {
	    var that = this, value = this.value;
	    var javascriptReplacement = function (_, exp) {
	        return String(that.evaluateJavaScript(exp, context));
	    };
	    var interpolationReplacement = function (_, name) {
	        var v = new Variable('@' + name, that.index, that.currentFileInfo).eval(context, true);
	        return (v instanceof Quoted) ? v.value : v.toCSS();
	    };
	    function iterativeReplace(value, regexp, replacementFnc) {
	        var evaluatedValue = value;
	        do {
	            value = evaluatedValue;
	            evaluatedValue = value.replace(regexp, replacementFnc);
	        } while (value !== evaluatedValue);
	        return evaluatedValue;
	    }
	    value = iterativeReplace(value, /`([^`]+)`/g, javascriptReplacement);
	    value = iterativeReplace(value, /@\{([\w-]+)\}/g, interpolationReplacement);
	    return new Quoted(this.quote + value + this.quote, value, this.escaped, this.index, this.currentFileInfo);
	};
	Quoted.prototype.compare = function (other) {
	    // when comparing quoted strings allow the quote to differ
	    if (other.type === "Quoted" && !this.escaped && !other.escaped) {
	        return Node.numericCompare(this.value, other.value);
	    } else {
	        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
	    }
	};
	module.exports = Quoted;

	},{"./js-eval-node":64,"./node":70,"./variable":82}],74:[function(require,module,exports){
	var Node = require("./node"),
	    Value = require("./value"),
	    Keyword = require("./keyword");

	var Rule = function (name, value, important, merge, index, currentFileInfo, inline, variable) {
	    this.name = name;
	    this.value = (value instanceof Node) ? value : new Value([value]); //value instanceof tree.Value || value instanceof tree.Ruleset ??
	    this.important = important ? ' ' + important.trim() : '';
	    this.merge = merge;
	    this.index = index;
	    this.currentFileInfo = currentFileInfo;
	    this.inline = inline || false;
	    this.variable = (variable !== undefined) ? variable
	        : (name.charAt && (name.charAt(0) === '@'));
	};

	function evalName(context, name) {
	    var value = "", i, n = name.length,
	        output = {add: function (s) {value += s;}};
	    for (i = 0; i < n; i++) {
	        name[i].eval(context).genCSS(context, output);
	    }
	    return value;
	}

	Rule.prototype = new Node();
	Rule.prototype.type = "Rule";
	Rule.prototype.genCSS = function (context, output) {
	    output.add(this.name + (context.compress ? ':' : ': '), this.currentFileInfo, this.index);
	    try {
	        this.value.genCSS(context, output);
	    }
	    catch(e) {
	        e.index = this.index;
	        e.filename = this.currentFileInfo.filename;
	        throw e;
	    }
	    output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? "" : ";"), this.currentFileInfo, this.index);
	};
	Rule.prototype.eval = function (context) {
	    var strictMathBypass = false, name = this.name, evaldValue, variable = this.variable;
	    if (typeof name !== "string") {
	        // expand 'primitive' name directly to get
	        // things faster (~10% for benchmark.less):
	        name = (name.length === 1) && (name[0] instanceof Keyword) ?
	                name[0].value : evalName(context, name);
	        variable = false; // never treat expanded interpolation as new variable name
	    }
	    if (name === "font" && !context.strictMath) {
	        strictMathBypass = true;
	        context.strictMath = true;
	    }
	    try {
	        context.importantScope.push({});
	        evaldValue = this.value.eval(context);

	        if (!this.variable && evaldValue.type === "DetachedRuleset") {
	            throw { message: "Rulesets cannot be evaluated on a property.",
	                    index: this.index, filename: this.currentFileInfo.filename };
	        }
	        var important = this.important,
	            importantResult = context.importantScope.pop();
	        if (!important && importantResult.important) {
	            important = importantResult.important;
	        }

	        return new Rule(name,
	                          evaldValue,
	                          important,
	                          this.merge,
	                          this.index, this.currentFileInfo, this.inline,
	                              variable);
	    }
	    catch(e) {
	        if (typeof e.index !== 'number') {
	            e.index = this.index;
	            e.filename = this.currentFileInfo.filename;
	        }
	        throw e;
	    }
	    finally {
	        if (strictMathBypass) {
	            context.strictMath = false;
	        }
	    }
	};
	Rule.prototype.makeImportant = function () {
	    return new Rule(this.name,
	                          this.value,
	                          "!important",
	                          this.merge,
	                          this.index, this.currentFileInfo, this.inline);
	};

	module.exports = Rule;
	},{"./keyword":65,"./node":70,"./value":81}],75:[function(require,module,exports){
	var Node = require("./node"),
	    Variable = require("./variable");

	var RulesetCall = function (variable) {
	    this.variable = variable;
	};
	RulesetCall.prototype = new Node();
	RulesetCall.prototype.type = "RulesetCall";
	RulesetCall.prototype.eval = function (context) {
	    var detachedRuleset = new Variable(this.variable).eval(context);
	    return detachedRuleset.callEval(context);
	};
	module.exports = RulesetCall;

	},{"./node":70,"./variable":82}],76:[function(require,module,exports){
	var Node = require("./node"),
	    Rule = require("./rule"),
	    Selector = require("./selector"),
	    Element = require("./element"),
	    Paren = require("./paren"),
	    contexts = require("../contexts"),
	    globalFunctionRegistry = require("../functions/function-registry"),
	    defaultFunc = require("../functions/default"),
	    getDebugInfo = require("./debug-info");

	var Ruleset = function (selectors, rules, strictImports, visibilityInfo) {
	    this.selectors = selectors;
	    this.rules = rules;
	    this._lookups = {};
	    this.strictImports = strictImports;
	    this.copyVisibilityInfo(visibilityInfo);
	};
	Ruleset.prototype = new Node();
	Ruleset.prototype.type = "Ruleset";
	Ruleset.prototype.isRuleset = true;
	Ruleset.prototype.isRulesetLike = true;
	Ruleset.prototype.accept = function (visitor) {
	    if (this.paths) {
	        this.paths = visitor.visitArray(this.paths, true);
	    } else if (this.selectors) {
	        this.selectors = visitor.visitArray(this.selectors);
	    }
	    if (this.rules && this.rules.length) {
	        this.rules = visitor.visitArray(this.rules);
	    }
	};
	Ruleset.prototype.eval = function (context) {
	    var thisSelectors = this.selectors, selectors,
	        selCnt, selector, i, hasOnePassingSelector = false;

	    if (thisSelectors && (selCnt = thisSelectors.length)) {
	        selectors = [];
	        defaultFunc.error({
	            type: "Syntax",
	            message: "it is currently only allowed in parametric mixin guards,"
	        });
	        for (i = 0; i < selCnt; i++) {
	            selector = thisSelectors[i].eval(context);
	            selectors.push(selector);
	            if (selector.evaldCondition) {
	                hasOnePassingSelector = true;
	            }
	        }
	        defaultFunc.reset();
	    } else {
	        hasOnePassingSelector = true;
	    }

	    var rules = this.rules ? this.rules.slice(0) : null,
	        ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo()),
	        rule, subRule;

	    ruleset.originalRuleset = this;
	    ruleset.root = this.root;
	    ruleset.firstRoot = this.firstRoot;
	    ruleset.allowImports = this.allowImports;

	    if (this.debugInfo) {
	        ruleset.debugInfo = this.debugInfo;
	    }

	    if (!hasOnePassingSelector) {
	        rules.length = 0;
	    }

	    // inherit a function registry from the frames stack when possible;
	    // otherwise from the global registry
	    ruleset.functionRegistry = (function (frames) {
	        var i = 0,
	            n = frames.length,
	            found;
	        for ( ; i !== n ; ++i ) {
	            found = frames[ i ].functionRegistry;
	            if ( found ) { return found; }
	        }
	        return globalFunctionRegistry;
	    }(context.frames)).inherit();

	    // push the current ruleset to the frames stack
	    var ctxFrames = context.frames;
	    ctxFrames.unshift(ruleset);

	    // currrent selectors
	    var ctxSelectors = context.selectors;
	    if (!ctxSelectors) {
	        context.selectors = ctxSelectors = [];
	    }
	    ctxSelectors.unshift(this.selectors);

	    // Evaluate imports
	    if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {
	        ruleset.evalImports(context);
	    }

	    // Store the frames around mixin definitions,
	    // so they can be evaluated like closures when the time comes.
	    var rsRules = ruleset.rules, rsRuleCnt = rsRules ? rsRules.length : 0;
	    for (i = 0; i < rsRuleCnt; i++) {
	        if (rsRules[i].evalFirst) {
	            rsRules[i] = rsRules[i].eval(context);
	        }
	    }

	    var mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;

	    // Evaluate mixin calls.
	    for (i = 0; i < rsRuleCnt; i++) {
	        if (rsRules[i].type === "MixinCall") {
	            /*jshint loopfunc:true */
	            rules = rsRules[i].eval(context).filter(function(r) {
	                if ((r instanceof Rule) && r.variable) {
	                    // do not pollute the scope if the variable is
	                    // already there. consider returning false here
	                    // but we need a way to "return" variable from mixins
	                    return !(ruleset.variable(r.name));
	                }
	                return true;
	            });
	            rsRules.splice.apply(rsRules, [i, 1].concat(rules));
	            rsRuleCnt += rules.length - 1;
	            i += rules.length - 1;
	            ruleset.resetCache();
	        } else if (rsRules[i].type === "RulesetCall") {
	            /*jshint loopfunc:true */
	            rules = rsRules[i].eval(context).rules.filter(function(r) {
	                if ((r instanceof Rule) && r.variable) {
	                    // do not pollute the scope at all
	                    return false;
	                }
	                return true;
	            });
	            rsRules.splice.apply(rsRules, [i, 1].concat(rules));
	            rsRuleCnt += rules.length - 1;
	            i += rules.length - 1;
	            ruleset.resetCache();
	        }
	    }

	    // Evaluate everything else
	    for (i = 0; i < rsRules.length; i++) {
	        rule = rsRules[i];
	        if (!rule.evalFirst) {
	            rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;
	        }
	    }

	    // Evaluate everything else
	    for (i = 0; i < rsRules.length; i++) {
	        rule = rsRules[i];
	        // for rulesets, check if it is a css guard and can be removed
	        if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {
	            // check if it can be folded in (e.g. & where)
	            if (rule.selectors[0].isJustParentSelector()) {
	                rsRules.splice(i--, 1);

	                for (var j = 0; j < rule.rules.length; j++) {
	                    subRule = rule.rules[j];
	                    subRule.copyVisibilityInfo(rule.visibilityInfo());
	                    if (!(subRule instanceof Rule) || !subRule.variable) {
	                        rsRules.splice(++i, 0, subRule);
	                    }
	                }
	            }
	        }
	    }

	    // Pop the stack
	    ctxFrames.shift();
	    ctxSelectors.shift();

	    if (context.mediaBlocks) {
	        for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {
	            context.mediaBlocks[i].bubbleSelectors(selectors);
	        }
	    }

	    return ruleset;
	};
	Ruleset.prototype.evalImports = function(context) {
	    var rules = this.rules, i, importRules;
	    if (!rules) { return; }

	    for (i = 0; i < rules.length; i++) {
	        if (rules[i].type === "Import") {
	            importRules = rules[i].eval(context);
	            if (importRules && (importRules.length || importRules.length === 0)) {
	                rules.splice.apply(rules, [i, 1].concat(importRules));
	                i+= importRules.length - 1;
	            } else {
	                rules.splice(i, 1, importRules);
	            }
	            this.resetCache();
	        }
	    }
	};
	Ruleset.prototype.makeImportant = function() {
	    var result = new Ruleset(this.selectors, this.rules.map(function (r) {
	        if (r.makeImportant) {
	            return r.makeImportant();
	        } else {
	            return r;
	        }
	    }), this.strictImports, this.visibilityInfo());

	    return result;
	};
	Ruleset.prototype.matchArgs = function (args) {
	    return !args || args.length === 0;
	};
	// lets you call a css selector with a guard
	Ruleset.prototype.matchCondition = function (args, context) {
	    var lastSelector = this.selectors[this.selectors.length - 1];
	    if (!lastSelector.evaldCondition) {
	        return false;
	    }
	    if (lastSelector.condition &&
	        !lastSelector.condition.eval(
	            new contexts.Eval(context,
	                context.frames))) {
	        return false;
	    }
	    return true;
	};
	Ruleset.prototype.resetCache = function () {
	    this._rulesets = null;
	    this._variables = null;
	    this._lookups = {};
	};
	Ruleset.prototype.variables = function () {
	    if (!this._variables) {
	        this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {
	            if (r instanceof Rule && r.variable === true) {
	                hash[r.name] = r;
	            }
	            // when evaluating variables in an import statement, imports have not been eval'd
	            // so we need to go inside import statements.
	            // guard against root being a string (in the case of inlined less)
	            if (r.type === "Import" && r.root && r.root.variables) {
	                var vars = r.root.variables();
	                for (var name in vars) {
	                    if (vars.hasOwnProperty(name)) {
	                        hash[name] = vars[name];
	                    }
	                }
	            }
	            return hash;
	        }, {});
	    }
	    return this._variables;
	};
	Ruleset.prototype.variable = function (name) {
	    return this.variables()[name];
	};
	Ruleset.prototype.rulesets = function () {
	    if (!this.rules) { return []; }

	    var filtRules = [], rules = this.rules, cnt = rules.length,
	        i, rule;

	    for (i = 0; i < cnt; i++) {
	        rule = rules[i];
	        if (rule.isRuleset) {
	            filtRules.push(rule);
	        }
	    }

	    return filtRules;
	};
	Ruleset.prototype.prependRule = function (rule) {
	    var rules = this.rules;
	    if (rules) {
	        rules.unshift(rule);
	    } else {
	        this.rules = [ rule ];
	    }
	};
	Ruleset.prototype.find = function (selector, self, filter) {
	    self = self || this;
	    var rules = [], match, foundMixins,
	        key = selector.toCSS();

	    if (key in this._lookups) { return this._lookups[key]; }

	    this.rulesets().forEach(function (rule) {
	        if (rule !== self) {
	            for (var j = 0; j < rule.selectors.length; j++) {
	                match = selector.match(rule.selectors[j]);
	                if (match) {
	                    if (selector.elements.length > match) {
	                        if (!filter || filter(rule)) {
	                            foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);
	                            for (var i = 0; i < foundMixins.length; ++i) {
	                                foundMixins[i].path.push(rule);
	                            }
	                            Array.prototype.push.apply(rules, foundMixins);
	                        }
	                    } else {
	                        rules.push({ rule: rule, path: []});
	                    }
	                    break;
	                }
	            }
	        }
	    });
	    this._lookups[key] = rules;
	    return rules;
	};
	Ruleset.prototype.genCSS = function (context, output) {
	    var i, j,
	        charsetRuleNodes = [],
	        ruleNodes = [],
	        debugInfo,     // Line number debugging
	        rule,
	        path;

	    context.tabLevel = (context.tabLevel || 0);

	    if (!this.root) {
	        context.tabLevel++;
	    }

	    var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join("  "),
	        tabSetStr = context.compress ? '' : Array(context.tabLevel).join("  "),
	        sep;

	    function isRulesetLikeNode(rule) {
	        // if it has nested rules, then it should be treated like a ruleset
	        // medias and comments do not have nested rules, but should be treated like rulesets anyway
	        // some directives and anonymous nodes are ruleset like, others are not
	        if (typeof rule.isRulesetLike === "boolean") {
	            return rule.isRulesetLike;
	        } else if (typeof rule.isRulesetLike === "function") {
	            return rule.isRulesetLike();
	        }

	        //anything else is assumed to be a rule
	        return false;
	    }

	    var charsetNodeIndex = 0;
	    var importNodeIndex = 0;
	    for (i = 0; i < this.rules.length; i++) {
	        rule = this.rules[i];
	        if (rule.type === "Comment") {
	            if (importNodeIndex === i) {
	                importNodeIndex++;
	            }
	            ruleNodes.push(rule);
	        } else if (rule.isCharset && rule.isCharset()) {
	            ruleNodes.splice(charsetNodeIndex, 0, rule);
	            charsetNodeIndex++;
	            importNodeIndex++;
	        } else if (rule.type === "Import") {
	            ruleNodes.splice(importNodeIndex, 0, rule);
	            importNodeIndex++;
	        } else {
	            ruleNodes.push(rule);
	        }
	    }
	    ruleNodes = charsetRuleNodes.concat(ruleNodes);

	    // If this is the root node, we don't render
	    // a selector, or {}.
	    if (!this.root) {
	        debugInfo = getDebugInfo(context, this, tabSetStr);

	        if (debugInfo) {
	            output.add(debugInfo);
	            output.add(tabSetStr);
	        }

	        var paths = this.paths, pathCnt = paths.length,
	            pathSubCnt;

	        sep = context.compress ? ',' : (',\n' + tabSetStr);

	        for (i = 0; i < pathCnt; i++) {
	            path = paths[i];
	            if (!(pathSubCnt = path.length)) { continue; }
	            if (i > 0) { output.add(sep); }

	            context.firstSelector = true;
	            path[0].genCSS(context, output);

	            context.firstSelector = false;
	            for (j = 1; j < pathSubCnt; j++) {
	                path[j].genCSS(context, output);
	            }
	        }

	        output.add((context.compress ? '{' : ' {\n') + tabRuleStr);
	    }

	    // Compile rules and rulesets
	    for (i = 0; i < ruleNodes.length; i++) {
	        rule = ruleNodes[i];

	        if (i + 1 === ruleNodes.length) {
	            context.lastRule = true;
	        }

	        var currentLastRule = context.lastRule;
	        if (isRulesetLikeNode(rule)) {
	            context.lastRule = false;
	        }

	        if (rule.genCSS) {
	            rule.genCSS(context, output);
	        } else if (rule.value) {
	            output.add(rule.value.toString());
	        }

	        context.lastRule = currentLastRule;

	        if (!context.lastRule) {
	            output.add(context.compress ? '' : ('\n' + tabRuleStr));
	        } else {
	            context.lastRule = false;
	        }
	    }

	    if (!this.root) {
	        output.add((context.compress ? '}' : '\n' + tabSetStr + '}'));
	        context.tabLevel--;
	    }

	    if (!output.isEmpty() && !context.compress && this.firstRoot) {
	        output.add('\n');
	    }
	};

	Ruleset.prototype.joinSelectors = function (paths, context, selectors) {
	    for (var s = 0; s < selectors.length; s++) {
	        this.joinSelector(paths, context, selectors[s]);
	    }
	};

	Ruleset.prototype.joinSelector = function (paths, context, selector) {

	    function createParenthesis(elementsToPak, originalElement) {
	        var replacementParen, j;
	        if (elementsToPak.length === 0) {
	            replacementParen = new Paren(elementsToPak[0]);
	        } else {
	            var insideParent = [];
	            for (j = 0; j < elementsToPak.length; j++) {
	                insideParent.push(new Element(null, elementsToPak[j], originalElement.index, originalElement.currentFileInfo));
	            }
	            replacementParen = new Paren(new Selector(insideParent));
	        }
	        return replacementParen;
	    }

	    function createSelector(containedElement, originalElement) {
	        var element, selector;
	        element = new Element(null, containedElement, originalElement.index, originalElement.currentFileInfo);
	        selector = new Selector([element]);
	        return selector;
	    }

	    // replace all parent selectors inside `inSelector` by content of `context` array
	    // resulting selectors are returned inside `paths` array
	    // returns true if `inSelector` contained at least one parent selector
	    function replaceParentSelector(paths, context, inSelector) {
	        // The paths are [[Selector]]
	        // The first list is a list of comma separated selectors
	        // The inner list is a list of inheritance separated selectors
	        // e.g.
	        // .a, .b {
	        //   .c {
	        //   }
	        // }
	        // == [[.a] [.c]] [[.b] [.c]]
	        //
	        var i, j, k, currentElements, newSelectors, selectorsMultiplied, sel, el, hadParentSelector = false, length, lastSelector;
	        function findNestedSelector(element) {
	            var maybeSelector;
	            if (element.value.type !== 'Paren') {
	                return null;
	            }

	            maybeSelector = element.value.value;
	            if (maybeSelector.type !== 'Selector') {
	                return null;
	            }

	            return maybeSelector;
	        }

	        // the elements from the current selector so far
	        currentElements = [];
	        // the current list of new selectors to add to the path.
	        // We will build it up. We initiate it with one empty selector as we "multiply" the new selectors
	        // by the parents
	        newSelectors = [
	            []
	        ];

	        for (i = 0; i < inSelector.elements.length; i++) {
	            el = inSelector.elements[i];
	            // non parent reference elements just get added
	            if (el.value !== "&") {
	                var nestedSelector = findNestedSelector(el);
	                if (nestedSelector != null) {
	                    // merge the current list of non parent selector elements
	                    // on to the current list of selectors to add
	                    mergeElementsOnToSelectors(currentElements, newSelectors);

	                    var nestedPaths = [], replaced, replacedNewSelectors = [];
	                    replaced = replaceParentSelector(nestedPaths, context, nestedSelector);
	                    hadParentSelector = hadParentSelector || replaced;
	                    //the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors
	                    for (k = 0; k < nestedPaths.length; k++) {
	                        var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);
	                        addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);
	                    }
	                    newSelectors = replacedNewSelectors;
	                    currentElements = [];

	                } else {
	                    currentElements.push(el);
	                }

	            } else {
	                hadParentSelector = true;
	                // the new list of selectors to add
	                selectorsMultiplied = [];

	                // merge the current list of non parent selector elements
	                // on to the current list of selectors to add
	                mergeElementsOnToSelectors(currentElements, newSelectors);

	                // loop through our current selectors
	                for (j = 0; j < newSelectors.length; j++) {
	                    sel = newSelectors[j];
	                    // if we don't have any parent paths, the & might be in a mixin so that it can be used
	                    // whether there are parents or not
	                    if (context.length === 0) {
	                        // the combinator used on el should now be applied to the next element instead so that
	                        // it is not lost
	                        if (sel.length > 0) {
	                            sel[0].elements.push(new Element(el.combinator, '', el.index, el.currentFileInfo));
	                        }
	                        selectorsMultiplied.push(sel);
	                    }
	                    else {
	                        // and the parent selectors
	                        for (k = 0; k < context.length; k++) {
	                            // We need to put the current selectors
	                            // then join the last selector's elements on to the parents selectors
	                            var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);
	                            // add that to our new set of selectors
	                            selectorsMultiplied.push(newSelectorPath);
	                        }
	                    }
	                }

	                // our new selectors has been multiplied, so reset the state
	                newSelectors = selectorsMultiplied;
	                currentElements = [];
	            }
	        }

	        // if we have any elements left over (e.g. .a& .b == .b)
	        // add them on to all the current selectors
	        mergeElementsOnToSelectors(currentElements, newSelectors);

	        for (i = 0; i < newSelectors.length; i++) {
	            length = newSelectors[i].length;
	            if (length > 0) {
	                paths.push(newSelectors[i]);
	                lastSelector = newSelectors[i][length - 1];
	                newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);
	                //newSelectors[i][length - 1].copyVisibilityInfo(inSelector.visibilityInfo());
	            }
	        }

	        return hadParentSelector;
	    }

	    // joins selector path from `beginningPath` with selector path in `addPath`
	    // `replacedElement` contains element that is being replaced by `addPath`
	    // returns concatenated path
	    function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {
	        var newSelectorPath, lastSelector, newJoinedSelector;
	        // our new selector path
	        newSelectorPath = [];

	        //construct the joined selector - if & is the first thing this will be empty,
	        // if not newJoinedSelector will be the last set of elements in the selector
	        if (beginningPath.length > 0) {
	            newSelectorPath = beginningPath.slice(0);
	            lastSelector = newSelectorPath.pop();
	            newJoinedSelector = originalSelector.createDerived(lastSelector.elements.slice(0));
	        }
	        else {
	            newJoinedSelector = originalSelector.createDerived([]);
	        }

	        if (addPath.length > 0) {
	            // /deep/ is a combinator that is valid without anything in front of it
	            // so if the & does not have a combinator that is "" or " " then
	            // and there is a combinator on the parent, then grab that.
	            // this also allows + a { & .b { .a & { ... though not sure why you would want to do that
	            var combinator = replacedElement.combinator, parentEl = addPath[0].elements[0];
	            if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {
	                combinator = parentEl.combinator;
	            }
	            // join the elements so far with the first part of the parent
	            newJoinedSelector.elements.push(new Element(combinator, parentEl.value, replacedElement.index, replacedElement.currentFileInfo));
	            newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));
	        }

	        // now add the joined selector - but only if it is not empty
	        if (newJoinedSelector.elements.length !== 0) {
	            newSelectorPath.push(newJoinedSelector);
	        }

	        //put together the parent selectors after the join (e.g. the rest of the parent)
	        if (addPath.length > 1) {
	            var restOfPath = addPath.slice(1);
	            restOfPath = restOfPath.map(function (selector) {
	                return selector.createDerived(selector.elements, []);
	            });
	            newSelectorPath = newSelectorPath.concat(restOfPath);
	        }
	        return newSelectorPath;
	    }

	    // joins selector path from `beginningPath` with every selector path in `addPaths` array
	    // `replacedElement` contains element that is being replaced by `addPath`
	    // returns array with all concatenated paths
	    function addAllReplacementsIntoPath( beginningPath, addPaths, replacedElement, originalSelector, result) {
	        var j;
	        for (j = 0; j < beginningPath.length; j++) {
	            var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);
	            result.push(newSelectorPath);
	        }
	        return result;
	    }

	    function mergeElementsOnToSelectors(elements, selectors) {
	        var i, sel;

	        if (elements.length === 0) {
	            return ;
	        }
	        if (selectors.length === 0) {
	            selectors.push([ new Selector(elements) ]);
	            return;
	        }

	        for (i = 0; i < selectors.length; i++) {
	            sel = selectors[i];

	            // if the previous thing in sel is a parent this needs to join on to it
	            if (sel.length > 0) {
	                sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));
	            }
	            else {
	                sel.push(new Selector(elements));
	            }
	        }
	    }

	    function deriveSelector(visibilityInfo, deriveFrom) {
	        var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);
	        newSelector.copyVisibilityInfo(visibilityInfo);
	        return newSelector;
	    }

	    // joinSelector code follows
	    var i, newPaths, hadParentSelector;

	    newPaths = [];
	    hadParentSelector = replaceParentSelector(newPaths, context, selector);

	    if (!hadParentSelector) {
	        if (context.length > 0) {
	            newPaths = [];
	            for (i = 0; i < context.length; i++) {
	                //var concatenated = [];
	                //context[i].forEach(function(entry) {
	                //    var newEntry = entry.createDerived(entry.elements, entry.extendList, entry.evaldCondition);
	                //    newEntry.copyVisibilityInfo(selector.visibilityInfo());
	                //    concatenated.push(newEntry);
	                //}, this);
	                var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));

	                concatenated.push(selector);
	                newPaths.push(concatenated);
	            }
	        }
	        else {
	            newPaths = [[selector]];
	        }
	    }

	    for (i = 0; i < newPaths.length; i++) {
	        paths.push(newPaths[i]);
	    }

	};
	module.exports = Ruleset;

	},{"../contexts":11,"../functions/default":20,"../functions/function-registry":22,"./debug-info":54,"./element":58,"./node":70,"./paren":72,"./rule":74,"./selector":77}],77:[function(require,module,exports){
	var Node = require("./node"),
	    Element = require("./element");

	var Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {
	    this.elements = elements;
	    this.extendList = extendList;
	    this.condition = condition;
	    this.currentFileInfo = currentFileInfo || {};
	    if (!condition) {
	        this.evaldCondition = true;
	    }
	    this.copyVisibilityInfo(visibilityInfo);
	};
	Selector.prototype = new Node();
	Selector.prototype.type = "Selector";
	Selector.prototype.accept = function (visitor) {
	    if (this.elements) {
	        this.elements = visitor.visitArray(this.elements);
	    }
	    if (this.extendList) {
	        this.extendList = visitor.visitArray(this.extendList);
	    }
	    if (this.condition) {
	        this.condition = visitor.visit(this.condition);
	    }
	};
	Selector.prototype.createDerived = function(elements, extendList, evaldCondition) {
	    var info = this.visibilityInfo();
	    evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;
	    var newSelector = new Selector(elements, extendList || this.extendList, null, this.index, this.currentFileInfo, info);
	    newSelector.evaldCondition = evaldCondition;
	    newSelector.mediaEmpty = this.mediaEmpty;
	    return newSelector;
	};
	Selector.prototype.createEmptySelectors = function() {
	    var el = new Element('', '&', this.index, this.currentFileInfo),
	        sels = [new Selector([el], null, null, this.index, this.currentFileInfo)];
	    sels[0].mediaEmpty = true;
	    return sels;
	};
	Selector.prototype.match = function (other) {
	    var elements = this.elements,
	        len = elements.length,
	        olen, i;

	    other.CacheElements();

	    olen = other._elements.length;
	    if (olen === 0 || len < olen) {
	        return 0;
	    } else {
	        for (i = 0; i < olen; i++) {
	            if (elements[i].value !== other._elements[i]) {
	                return 0;
	            }
	        }
	    }

	    return olen; // return number of matched elements
	};
	Selector.prototype.CacheElements = function() {
	    if (this._elements) {
	        return;
	    }

	    var elements = this.elements.map( function(v) {
	        return v.combinator.value + (v.value.value || v.value);
	    }).join("").match(/[,&#\*\.\w-]([\w-]|(\\.))*/g);

	    if (elements) {
	        if (elements[0] === "&") {
	            elements.shift();
	        }
	    } else {
	        elements = [];
	    }

	    this._elements = elements;
	};
	Selector.prototype.isJustParentSelector = function() {
	    return !this.mediaEmpty &&
	        this.elements.length === 1 &&
	        this.elements[0].value === '&' &&
	        (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');
	};
	Selector.prototype.eval = function (context) {
	    var evaldCondition = this.condition && this.condition.eval(context),
	        elements = this.elements, extendList = this.extendList;

	    elements = elements && elements.map(function (e) { return e.eval(context); });
	    extendList = extendList && extendList.map(function(extend) { return extend.eval(context); });

	    return this.createDerived(elements, extendList, evaldCondition);
	};
	Selector.prototype.genCSS = function (context, output) {
	    var i, element;
	    if ((!context || !context.firstSelector) && this.elements[0].combinator.value === "") {
	        output.add(' ', this.currentFileInfo, this.index);
	    }
	    if (!this._css) {
	        //TODO caching? speed comparison?
	        for (i = 0; i < this.elements.length; i++) {
	            element = this.elements[i];
	            element.genCSS(context, output);
	        }
	    }
	};
	Selector.prototype.getIsOutput = function() {
	    return this.evaldCondition;
	};
	module.exports = Selector;

	},{"./element":58,"./node":70}],78:[function(require,module,exports){
	var Node = require("./node");

	var UnicodeDescriptor = function (value) {
	    this.value = value;
	};
	UnicodeDescriptor.prototype = new Node();
	UnicodeDescriptor.prototype.type = "UnicodeDescriptor";

	module.exports = UnicodeDescriptor;

	},{"./node":70}],79:[function(require,module,exports){
	var Node = require("./node"),
	    unitConversions = require("../data/unit-conversions");

	var Unit = function (numerator, denominator, backupUnit) {
	    this.numerator = numerator ? numerator.slice(0).sort() : [];
	    this.denominator = denominator ? denominator.slice(0).sort() : [];
	    if (backupUnit) {
	        this.backupUnit = backupUnit;
	    } else if (numerator && numerator.length) {
	        this.backupUnit = numerator[0];
	    }
	};

	Unit.prototype = new Node();
	Unit.prototype.type = "Unit";
	Unit.prototype.clone = function () {
	    return new Unit(this.numerator.slice(0), this.denominator.slice(0), this.backupUnit);
	};
	Unit.prototype.genCSS = function (context, output) {
	    // Dimension checks the unit is singular and throws an error if in strict math mode.
	    var strictUnits = context && context.strictUnits;
	    if (this.numerator.length === 1) {
	        output.add(this.numerator[0]); // the ideal situation
	    } else if (!strictUnits && this.backupUnit) {
	        output.add(this.backupUnit);
	    } else if (!strictUnits && this.denominator.length) {
	        output.add(this.denominator[0]);
	    }
	};
	Unit.prototype.toString = function () {
	    var i, returnStr = this.numerator.join("*");
	    for (i = 0; i < this.denominator.length; i++) {
	        returnStr += "/" + this.denominator[i];
	    }
	    return returnStr;
	};
	Unit.prototype.compare = function (other) {
	    return this.is(other.toString()) ? 0 : undefined;
	};
	Unit.prototype.is = function (unitString) {
	    return this.toString().toUpperCase() === unitString.toUpperCase();
	};
	Unit.prototype.isLength = function () {
	    return Boolean(this.toCSS().match(/px|em|%|in|cm|mm|pc|pt|ex/));
	};
	Unit.prototype.isEmpty = function () {
	    return this.numerator.length === 0 && this.denominator.length === 0;
	};
	Unit.prototype.isSingular = function() {
	    return this.numerator.length <= 1 && this.denominator.length === 0;
	};
	Unit.prototype.map = function(callback) {
	    var i;

	    for (i = 0; i < this.numerator.length; i++) {
	        this.numerator[i] = callback(this.numerator[i], false);
	    }

	    for (i = 0; i < this.denominator.length; i++) {
	        this.denominator[i] = callback(this.denominator[i], true);
	    }
	};
	Unit.prototype.usedUnits = function() {
	    var group, result = {}, mapUnit;

	    mapUnit = function (atomicUnit) {
	        /*jshint loopfunc:true */
	        if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {
	            result[groupName] = atomicUnit;
	        }

	        return atomicUnit;
	    };

	    for (var groupName in unitConversions) {
	        if (unitConversions.hasOwnProperty(groupName)) {
	            group = unitConversions[groupName];

	            this.map(mapUnit);
	        }
	    }

	    return result;
	};
	Unit.prototype.cancel = function () {
	    var counter = {}, atomicUnit, i;

	    for (i = 0; i < this.numerator.length; i++) {
	        atomicUnit = this.numerator[i];
	        counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;
	    }

	    for (i = 0; i < this.denominator.length; i++) {
	        atomicUnit = this.denominator[i];
	        counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;
	    }

	    this.numerator = [];
	    this.denominator = [];

	    for (atomicUnit in counter) {
	        if (counter.hasOwnProperty(atomicUnit)) {
	            var count = counter[atomicUnit];

	            if (count > 0) {
	                for (i = 0; i < count; i++) {
	                    this.numerator.push(atomicUnit);
	                }
	            } else if (count < 0) {
	                for (i = 0; i < -count; i++) {
	                    this.denominator.push(atomicUnit);
	                }
	            }
	        }
	    }

	    this.numerator.sort();
	    this.denominator.sort();
	};
	module.exports = Unit;

	},{"../data/unit-conversions":14,"./node":70}],80:[function(require,module,exports){
	var Node = require("./node");

	var URL = function (val, index, currentFileInfo, isEvald) {
	    this.value = val;
	    this.currentFileInfo = currentFileInfo;
	    this.index = index;
	    this.isEvald = isEvald;
	};
	URL.prototype = new Node();
	URL.prototype.type = "Url";
	URL.prototype.accept = function (visitor) {
	    this.value = visitor.visit(this.value);
	};
	URL.prototype.genCSS = function (context, output) {
	    output.add("url(");
	    this.value.genCSS(context, output);
	    output.add(")");
	};
	URL.prototype.eval = function (context) {
	    var val = this.value.eval(context),
	        rootpath;

	    if (!this.isEvald) {
	        // Add the base path if the URL is relative
	        rootpath = this.currentFileInfo && this.currentFileInfo.rootpath;
	        if (rootpath &&
	            typeof val.value === "string" &&
	            context.isPathRelative(val.value)) {

	            if (!val.quote) {
	                rootpath = rootpath.replace(/[\(\)'"\s]/g, function(match) { return "\\" + match; });
	            }
	            val.value = rootpath + val.value;
	        }

	        val.value = context.normalizePath(val.value);

	        // Add url args if enabled
	        if (context.urlArgs) {
	            if (!val.value.match(/^\s*data:/)) {
	                var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';
	                var urlArgs = delimiter + context.urlArgs;
	                if (val.value.indexOf('#') !== -1) {
	                    val.value = val.value.replace('#', urlArgs + '#');
	                } else {
	                    val.value += urlArgs;
	                }
	            }
	        }
	    }

	    return new URL(val, this.index, this.currentFileInfo, true);
	};
	module.exports = URL;

	},{"./node":70}],81:[function(require,module,exports){
	var Node = require("./node");

	var Value = function (value) {
	    this.value = value;
	    if (!value) {
	        throw new Error("Value requires an array argument");
	    }
	};
	Value.prototype = new Node();
	Value.prototype.type = "Value";
	Value.prototype.accept = function (visitor) {
	    if (this.value) {
	        this.value = visitor.visitArray(this.value);
	    }
	};
	Value.prototype.eval = function (context) {
	    if (this.value.length === 1) {
	        return this.value[0].eval(context);
	    } else {
	        return new Value(this.value.map(function (v) {
	            return v.eval(context);
	        }));
	    }
	};
	Value.prototype.genCSS = function (context, output) {
	    var i;
	    for (i = 0; i < this.value.length; i++) {
	        this.value[i].genCSS(context, output);
	        if (i + 1 < this.value.length) {
	            output.add((context && context.compress) ? ',' : ', ');
	        }
	    }
	};
	module.exports = Value;

	},{"./node":70}],82:[function(require,module,exports){
	var Node = require("./node");

	var Variable = function (name, index, currentFileInfo) {
	    this.name = name;
	    this.index = index;
	    this.currentFileInfo = currentFileInfo || {};
	};
	Variable.prototype = new Node();
	Variable.prototype.type = "Variable";
	Variable.prototype.eval = function (context) {
	    var variable, name = this.name;

	    if (name.indexOf('@@') === 0) {
	        name = '@' + new Variable(name.slice(1), this.index, this.currentFileInfo).eval(context).value;
	    }

	    if (this.evaluating) {
	        throw { type: 'Name',
	                message: "Recursive variable definition for " + name,
	                filename: this.currentFileInfo.filename,
	                index: this.index };
	    }

	    this.evaluating = true;

	    variable = this.find(context.frames, function (frame) {
	        var v = frame.variable(name);
	        if (v) {
	            if (v.important) {
	                var importantScope = context.importantScope[context.importantScope.length - 1];
	                importantScope.important = v.important;
	            }
	            return v.value.eval(context);
	        }
	    });
	    if (variable) {
	        this.evaluating = false;
	        return variable;
	    } else {
	        throw { type: 'Name',
	                message: "variable " + name + " is undefined",
	                filename: this.currentFileInfo.filename,
	                index: this.index };
	    }
	};
	Variable.prototype.find = function (obj, fun) {
	    for (var i = 0, r; i < obj.length; i++) {
	        r = fun.call(obj, obj[i]);
	        if (r) { return r; }
	    }
	    return null;
	};
	module.exports = Variable;

	},{"./node":70}],83:[function(require,module,exports){
	module.exports = {
	    getLocation: function(index, inputStream) {
	        var n = index + 1,
	            line = null,
	            column = -1;

	        while (--n >= 0 && inputStream.charAt(n) !== '\n') {
	            column++;
	        }

	        if (typeof index === 'number') {
	            line = (inputStream.slice(0, index).match(/\n/g) || "").length;
	        }

	        return {
	            line: line,
	            column: column
	        };
	    }
	};

	},{}],84:[function(require,module,exports){
	var tree = require("../tree"),
	    Visitor = require("./visitor"),
	    logger = require("../logger");

	/*jshint loopfunc:true */

	var ExtendFinderVisitor = function() {
	    this._visitor = new Visitor(this);
	    this.contexts = [];
	    this.allExtendsStack = [[]];
	};

	ExtendFinderVisitor.prototype = {
	    run: function (root) {
	        root = this._visitor.visit(root);
	        root.allExtends = this.allExtendsStack[0];
	        return root;
	    },
	    visitRule: function (ruleNode, visitArgs) {
	        visitArgs.visitDeeper = false;
	    },
	    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
	        visitArgs.visitDeeper = false;
	    },
	    visitRuleset: function (rulesetNode, visitArgs) {
	        if (rulesetNode.root) {
	            return;
	        }

	        var i, j, extend, allSelectorsExtendList = [], extendList;

	        // get &:extend(.a); rules which apply to all selectors in this ruleset
	        var rules = rulesetNode.rules, ruleCnt = rules ? rules.length : 0;
	        for (i = 0; i < ruleCnt; i++) {
	            if (rulesetNode.rules[i] instanceof tree.Extend) {
	                allSelectorsExtendList.push(rules[i]);
	                rulesetNode.extendOnEveryPath = true;
	            }
	        }

	        // now find every selector and apply the extends that apply to all extends
	        // and the ones which apply to an individual extend
	        var paths = rulesetNode.paths;
	        for (i = 0; i < paths.length; i++) {
	            var selectorPath = paths[i],
	                selector = selectorPath[selectorPath.length - 1],
	                selExtendList = selector.extendList;

	            extendList = selExtendList ? selExtendList.slice(0).concat(allSelectorsExtendList)
	                                       : allSelectorsExtendList;

	            if (extendList) {
	                extendList = extendList.map(function(allSelectorsExtend) {
	                    return allSelectorsExtend.clone();
	                });
	            }

	            for (j = 0; j < extendList.length; j++) {
	                this.foundExtends = true;
	                extend = extendList[j];
	                extend.findSelfSelectors(selectorPath);
	                extend.ruleset = rulesetNode;
	                if (j === 0) { extend.firstExtendOnThisSelectorPath = true; }
	                this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);
	            }
	        }

	        this.contexts.push(rulesetNode.selectors);
	    },
	    visitRulesetOut: function (rulesetNode) {
	        if (!rulesetNode.root) {
	            this.contexts.length = this.contexts.length - 1;
	        }
	    },
	    visitMedia: function (mediaNode, visitArgs) {
	        mediaNode.allExtends = [];
	        this.allExtendsStack.push(mediaNode.allExtends);
	    },
	    visitMediaOut: function (mediaNode) {
	        this.allExtendsStack.length = this.allExtendsStack.length - 1;
	    },
	    visitDirective: function (directiveNode, visitArgs) {
	        directiveNode.allExtends = [];
	        this.allExtendsStack.push(directiveNode.allExtends);
	    },
	    visitDirectiveOut: function (directiveNode) {
	        this.allExtendsStack.length = this.allExtendsStack.length - 1;
	    }
	};

	var ProcessExtendsVisitor = function() {
	    this._visitor = new Visitor(this);
	};

	ProcessExtendsVisitor.prototype = {
	    run: function(root) {
	        var extendFinder = new ExtendFinderVisitor();
	        this.extendIndicies = {};
	        extendFinder.run(root);
	        if (!extendFinder.foundExtends) { return root; }
	        root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));
	        this.allExtendsStack = [root.allExtends];
	        var newRoot = this._visitor.visit(root);
	        this.checkExtendsForNonMatched(root.allExtends);
	        return newRoot;
	    },
	    checkExtendsForNonMatched: function(extendList) {
	        var indicies = this.extendIndicies;
	        extendList.filter(function(extend) {
	            return !extend.hasFoundMatches && extend.parent_ids.length == 1;
	        }).forEach(function(extend) {
	                var selector = "_unknown_";
	                try {
	                    selector = extend.selector.toCSS({});
	                }
	                catch(_) {}

	                if (!indicies[extend.index + ' ' + selector]) {
	                    indicies[extend.index + ' ' + selector] = true;
	                    logger.warn("extend '" + selector + "' has no matches");
	                }
	            });
	    },
	    doExtendChaining: function (extendsList, extendsListTarget, iterationCount) {
	        //
	        // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering
	        // and pasting the selector we would do normally, but we are also adding an extend with the same target selector
	        // this means this new extend can then go and alter other extends
	        //
	        // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors
	        // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already
	        // processed if we look at each selector at a time, as is done in visitRuleset

	        var extendIndex, targetExtendIndex, matches, extendsToAdd = [], newSelector, extendVisitor = this, selectorPath,
	            extend, targetExtend, newExtend;

	        iterationCount = iterationCount || 0;

	        //loop through comparing every extend with every target extend.
	        // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place
	        // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one
	        // and the second is the target.
	        // the seperation into two lists allows us to process a subset of chains with a bigger set, as is the
	        // case when processing media queries
	        for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {
	            for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {

	                extend = extendsList[extendIndex];
	                targetExtend = extendsListTarget[targetExtendIndex];

	                // look for circular references
	                if ( extend.parent_ids.indexOf( targetExtend.object_id ) >= 0 ) { continue; }

	                // find a match in the target extends self selector (the bit before :extend)
	                selectorPath = [targetExtend.selfSelectors[0]];
	                matches = extendVisitor.findMatch(extend, selectorPath);

	                if (matches.length) {
	                    extend.hasFoundMatches = true;

	                    // we found a match, so for each self selector..
	                    extend.selfSelectors.forEach(function(selfSelector) {
	                        var info = targetExtend.visibilityInfo();

	                        // process the extend as usual
	                        newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());

	                        // but now we create a new extend from it
	                        newExtend = new(tree.Extend)(targetExtend.selector, targetExtend.option, 0, targetExtend.currentFileInfo, info);
	                        newExtend.selfSelectors = newSelector;

	                        // add the extend onto the list of extends for that selector
	                        newSelector[newSelector.length - 1].extendList = [newExtend];

	                        // record that we need to add it.
	                        extendsToAdd.push(newExtend);
	                        newExtend.ruleset = targetExtend.ruleset;

	                        //remember its parents for circular references
	                        newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);

	                        // only process the selector once.. if we have :extend(.a,.b) then multiple
	                        // extends will look at the same selector path, so when extending
	                        // we know that any others will be duplicates in terms of what is added to the css
	                        if (targetExtend.firstExtendOnThisSelectorPath) {
	                            newExtend.firstExtendOnThisSelectorPath = true;
	                            targetExtend.ruleset.paths.push(newSelector);
	                        }
	                    });
	                }
	            }
	        }

	        if (extendsToAdd.length) {
	            // try to detect circular references to stop a stack overflow.
	            // may no longer be needed.
	            this.extendChainCount++;
	            if (iterationCount > 100) {
	                var selectorOne = "{unable to calculate}";
	                var selectorTwo = "{unable to calculate}";
	                try {
	                    selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();
	                    selectorTwo = extendsToAdd[0].selector.toCSS();
	                }
	                catch(e) {}
	                throw { message: "extend circular reference detected. One of the circular extends is currently:" +
	                    selectorOne + ":extend(" + selectorTwo + ")"};
	            }

	            // now process the new extends on the existing rules so that we can handle a extending b extending c extending
	            // d extending e...
	            return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));
	        } else {
	            return extendsToAdd;
	        }
	    },
	    visitRule: function (ruleNode, visitArgs) {
	        visitArgs.visitDeeper = false;
	    },
	    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
	        visitArgs.visitDeeper = false;
	    },
	    visitSelector: function (selectorNode, visitArgs) {
	        visitArgs.visitDeeper = false;
	    },
	    visitRuleset: function (rulesetNode, visitArgs) {
	        if (rulesetNode.root) {
	            return;
	        }
	        var matches, pathIndex, extendIndex, allExtends = this.allExtendsStack[this.allExtendsStack.length - 1],
	            selectorsToAdd = [], extendVisitor = this, selectorPath;

	        // look at each selector path in the ruleset, find any extend matches and then copy, find and replace

	        for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {
	            for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {
	                selectorPath = rulesetNode.paths[pathIndex];

	                // extending extends happens initially, before the main pass
	                if (rulesetNode.extendOnEveryPath) { continue; }
	                var extendList = selectorPath[selectorPath.length - 1].extendList;
	                if (extendList && extendList.length) { continue; }

	                matches = this.findMatch(allExtends[extendIndex], selectorPath);

	                if (matches.length) {
	                    allExtends[extendIndex].hasFoundMatches = true;

	                    allExtends[extendIndex].selfSelectors.forEach(function(selfSelector) {
	                        var extendedSelectors;
	                        extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());
	                        selectorsToAdd.push(extendedSelectors);
	                    });
	                }
	            }
	        }
	        rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);
	    },
	    findMatch: function (extend, haystackSelectorPath) {
	        //
	        // look through the haystack selector path to try and find the needle - extend.selector
	        // returns an array of selector matches that can then be replaced
	        //
	        var haystackSelectorIndex, hackstackSelector, hackstackElementIndex, haystackElement,
	            targetCombinator, i,
	            extendVisitor = this,
	            needleElements = extend.selector.elements,
	            potentialMatches = [], potentialMatch, matches = [];

	        // loop through the haystack elements
	        for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {
	            hackstackSelector = haystackSelectorPath[haystackSelectorIndex];

	            for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {

	                haystackElement = hackstackSelector.elements[hackstackElementIndex];

	                // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.
	                if (extend.allowBefore || (haystackSelectorIndex === 0 && hackstackElementIndex === 0)) {
	                    potentialMatches.push({pathIndex: haystackSelectorIndex, index: hackstackElementIndex, matched: 0,
	                        initialCombinator: haystackElement.combinator});
	                }

	                for (i = 0; i < potentialMatches.length; i++) {
	                    potentialMatch = potentialMatches[i];

	                    // selectors add " " onto the first element. When we use & it joins the selectors together, but if we don't
	                    // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to
	                    // work out what the resulting combinator will be
	                    targetCombinator = haystackElement.combinator.value;
	                    if (targetCombinator === '' && hackstackElementIndex === 0) {
	                        targetCombinator = ' ';
	                    }

	                    // if we don't match, null our match to indicate failure
	                    if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) ||
	                        (potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator)) {
	                        potentialMatch = null;
	                    } else {
	                        potentialMatch.matched++;
	                    }

	                    // if we are still valid and have finished, test whether we have elements after and whether these are allowed
	                    if (potentialMatch) {
	                        potentialMatch.finished = potentialMatch.matched === needleElements.length;
	                        if (potentialMatch.finished &&
	                            (!extend.allowAfter &&
	                                (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {
	                            potentialMatch = null;
	                        }
	                    }
	                    // if null we remove, if not, we are still valid, so either push as a valid match or continue
	                    if (potentialMatch) {
	                        if (potentialMatch.finished) {
	                            potentialMatch.length = needleElements.length;
	                            potentialMatch.endPathIndex = haystackSelectorIndex;
	                            potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match
	                            potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again
	                            matches.push(potentialMatch);
	                        }
	                    } else {
	                        potentialMatches.splice(i, 1);
	                        i--;
	                    }
	                }
	            }
	        }
	        return matches;
	    },
	    isElementValuesEqual: function(elementValue1, elementValue2) {
	        if (typeof elementValue1 === "string" || typeof elementValue2 === "string") {
	            return elementValue1 === elementValue2;
	        }
	        if (elementValue1 instanceof tree.Attribute) {
	            if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {
	                return false;
	            }
	            if (!elementValue1.value || !elementValue2.value) {
	                if (elementValue1.value || elementValue2.value) {
	                    return false;
	                }
	                return true;
	            }
	            elementValue1 = elementValue1.value.value || elementValue1.value;
	            elementValue2 = elementValue2.value.value || elementValue2.value;
	            return elementValue1 === elementValue2;
	        }
	        elementValue1 = elementValue1.value;
	        elementValue2 = elementValue2.value;
	        if (elementValue1 instanceof tree.Selector) {
	            if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {
	                return false;
	            }
	            for (var i = 0; i  < elementValue1.elements.length; i++) {
	                if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {
	                    if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {
	                        return false;
	                    }
	                }
	                if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        return false;
	    },
	    extendSelector:function (matches, selectorPath, replacementSelector, isVisible) {

	        //for a set of matches, replace each match with the replacement selector

	        var currentSelectorPathIndex = 0,
	            currentSelectorPathElementIndex = 0,
	            path = [],
	            matchIndex,
	            selector,
	            firstElement,
	            match,
	            newElements;

	        for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {
	            match = matches[matchIndex];
	            selector = selectorPath[match.pathIndex];
	            firstElement = new tree.Element(
	                match.initialCombinator,
	                replacementSelector.elements[0].value,
	                replacementSelector.elements[0].index,
	                replacementSelector.elements[0].currentFileInfo
	            );

	            if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {
	                path[path.length - 1].elements = path[path.length - 1]
	                    .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
	                currentSelectorPathElementIndex = 0;
	                currentSelectorPathIndex++;
	            }

	            newElements = selector.elements
	                .slice(currentSelectorPathElementIndex, match.index)
	                .concat([firstElement])
	                .concat(replacementSelector.elements.slice(1));

	            if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {
	                path[path.length - 1].elements =
	                    path[path.length - 1].elements.concat(newElements);
	            } else {
	                path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));

	                path.push(new tree.Selector(
	                    newElements
	                ));
	            }
	            currentSelectorPathIndex = match.endPathIndex;
	            currentSelectorPathElementIndex = match.endPathElementIndex;
	            if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {
	                currentSelectorPathElementIndex = 0;
	                currentSelectorPathIndex++;
	            }
	        }

	        if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {
	            path[path.length - 1].elements = path[path.length - 1]
	                .elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
	            currentSelectorPathIndex++;
	        }

	        path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));
	        path = path.map(function (currentValue) {
	            // we can re-use elements here, because the visibility property matters only for selectors
	            var derived = currentValue.createDerived(currentValue.elements);
	            if (isVisible) {
	                derived.ensureVisibility();
	            } else {
	                derived.ensureInvisibility();
	            }
	            return derived;
	        });
	        return path;
	    },
	    visitMedia: function (mediaNode, visitArgs) {
	        var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
	        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));
	        this.allExtendsStack.push(newAllExtends);
	    },
	    visitMediaOut: function (mediaNode) {
	        var lastIndex = this.allExtendsStack.length - 1;
	        this.allExtendsStack.length = lastIndex;
	    },
	    visitDirective: function (directiveNode, visitArgs) {
	        var newAllExtends = directiveNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
	        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, directiveNode.allExtends));
	        this.allExtendsStack.push(newAllExtends);
	    },
	    visitDirectiveOut: function (directiveNode) {
	        var lastIndex = this.allExtendsStack.length - 1;
	        this.allExtendsStack.length = lastIndex;
	    }
	};

	module.exports = ProcessExtendsVisitor;

	},{"../logger":33,"../tree":62,"./visitor":91}],85:[function(require,module,exports){
	function ImportSequencer(onSequencerEmpty) {
	    this.imports = [];
	    this.variableImports = [];
	    this._onSequencerEmpty = onSequencerEmpty;
	    this._currentDepth = 0;
	}

	ImportSequencer.prototype.addImport = function(callback) {
	    var importSequencer = this,
	        importItem = {
	            callback: callback,
	            args: null,
	            isReady: false
	        };
	    this.imports.push(importItem);
	    return function() {
	        importItem.args = Array.prototype.slice.call(arguments, 0);
	        importItem.isReady = true;
	        importSequencer.tryRun();
	    };
	};

	ImportSequencer.prototype.addVariableImport = function(callback) {
	    this.variableImports.push(callback);
	};

	ImportSequencer.prototype.tryRun = function() {
	    this._currentDepth++;
	    try {
	        while (true) {
	            while (this.imports.length > 0) {
	                var importItem = this.imports[0];
	                if (!importItem.isReady) {
	                    return;
	                }
	                this.imports = this.imports.slice(1);
	                importItem.callback.apply(null, importItem.args);
	            }
	            if (this.variableImports.length === 0) {
	                break;
	            }
	            var variableImport = this.variableImports[0];
	            this.variableImports = this.variableImports.slice(1);
	            variableImport();
	        }
	    } finally {
	        this._currentDepth--;
	    }
	    if (this._currentDepth === 0 && this._onSequencerEmpty) {
	        this._onSequencerEmpty();
	    }
	};

	module.exports = ImportSequencer;

	},{}],86:[function(require,module,exports){
	var contexts = require("../contexts"),
	    Visitor = require("./visitor"),
	    ImportSequencer = require("./import-sequencer");

	var ImportVisitor = function(importer, finish) {

	    this._visitor = new Visitor(this);
	    this._importer = importer;
	    this._finish = finish;
	    this.context = new contexts.Eval();
	    this.importCount = 0;
	    this.onceFileDetectionMap = {};
	    this.recursionDetector = {};
	    this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));
	};

	ImportVisitor.prototype = {
	    isReplacing: false,
	    run: function (root) {
	        try {
	            // process the contents
	            this._visitor.visit(root);
	        }
	        catch(e) {
	            this.error = e;
	        }

	        this.isFinished = true;
	        this._sequencer.tryRun();
	    },
	    _onSequencerEmpty: function() {
	        if (!this.isFinished) {
	            return;
	        }
	        this._finish(this.error);
	    },
	    visitImport: function (importNode, visitArgs) {
	        var inlineCSS = importNode.options.inline;

	        if (!importNode.css || inlineCSS) {

	            var context = new contexts.Eval(this.context, this.context.frames.slice(0));
	            var importParent = context.frames[0];

	            this.importCount++;
	            if (importNode.isVariableImport()) {
	                this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));
	            } else {
	                this.processImportNode(importNode, context, importParent);
	            }
	        }
	        visitArgs.visitDeeper = false;
	    },
	    processImportNode: function(importNode, context, importParent) {
	        var evaldImportNode,
	            inlineCSS = importNode.options.inline;

	        try {
	            evaldImportNode = importNode.evalForImport(context);
	        } catch(e) {
	            if (!e.filename) { e.index = importNode.index; e.filename = importNode.currentFileInfo.filename; }
	            // attempt to eval properly and treat as css
	            importNode.css = true;
	            // if that fails, this error will be thrown
	            importNode.error = e;
	        }

	        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {

	            if (evaldImportNode.options.multiple) {
	                context.importMultiple = true;
	            }

	            // try appending if we haven't determined if it is css or not
	            var tryAppendLessExtension = evaldImportNode.css === undefined;

	            for (var i = 0; i < importParent.rules.length; i++) {
	                if (importParent.rules[i] === importNode) {
	                    importParent.rules[i] = evaldImportNode;
	                    break;
	                }
	            }

	            var onImported = this.onImported.bind(this, evaldImportNode, context),
	                sequencedOnImported = this._sequencer.addImport(onImported);

	            this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.currentFileInfo,
	                evaldImportNode.options, sequencedOnImported);
	        } else {
	            this.importCount--;
	            if (this.isFinished) {
	                this._sequencer.tryRun();
	            }
	        }
	    },
	    onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {
	        if (e) {
	            if (!e.filename) {
	                e.index = importNode.index; e.filename = importNode.currentFileInfo.filename;
	            }
	            this.error = e;
	        }

	        var importVisitor = this,
	            inlineCSS = importNode.options.inline,
	            isPlugin = importNode.options.plugin,
	            isOptional = importNode.options.optional,
	            duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;

	        if (!context.importMultiple) {
	            if (duplicateImport) {
	                importNode.skip = true;
	            } else {
	                importNode.skip = function() {
	                    if (fullPath in importVisitor.onceFileDetectionMap) {
	                        return true;
	                    }
	                    importVisitor.onceFileDetectionMap[fullPath] = true;
	                    return false;
	                };
	            }
	        }

	        if (!fullPath && isOptional) {
	            importNode.skip = true;
	        }

	        if (root) {
	            importNode.root = root;
	            importNode.importedFilename = fullPath;

	            if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {
	                importVisitor.recursionDetector[fullPath] = true;

	                var oldContext = this.context;
	                this.context = context;
	                try {
	                    this._visitor.visit(root);
	                } catch (e) {
	                    this.error = e;
	                }
	                this.context = oldContext;
	            }
	        }

	        importVisitor.importCount--;

	        if (importVisitor.isFinished) {
	            importVisitor._sequencer.tryRun();
	        }
	    },
	    visitRule: function (ruleNode, visitArgs) {
	        if (ruleNode.value.type === "DetachedRuleset") {
	            this.context.frames.unshift(ruleNode);
	        } else {
	            visitArgs.visitDeeper = false;
	        }
	    },
	    visitRuleOut : function(ruleNode) {
	        if (ruleNode.value.type === "DetachedRuleset") {
	            this.context.frames.shift();
	        }
	    },
	    visitDirective: function (directiveNode, visitArgs) {
	        this.context.frames.unshift(directiveNode);
	    },
	    visitDirectiveOut: function (directiveNode) {
	        this.context.frames.shift();
	    },
	    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
	        this.context.frames.unshift(mixinDefinitionNode);
	    },
	    visitMixinDefinitionOut: function (mixinDefinitionNode) {
	        this.context.frames.shift();
	    },
	    visitRuleset: function (rulesetNode, visitArgs) {
	        this.context.frames.unshift(rulesetNode);
	    },
	    visitRulesetOut: function (rulesetNode) {
	        this.context.frames.shift();
	    },
	    visitMedia: function (mediaNode, visitArgs) {
	        this.context.frames.unshift(mediaNode.rules[0]);
	    },
	    visitMediaOut: function (mediaNode) {
	        this.context.frames.shift();
	    }
	};
	module.exports = ImportVisitor;

	},{"../contexts":11,"./import-sequencer":85,"./visitor":91}],87:[function(require,module,exports){
	var visitors = {
	    Visitor: require("./visitor"),
	    ImportVisitor: require('./import-visitor'),
	    MarkVisibleSelectorsVisitor: require("./set-tree-visibility-visitor"),
	    ExtendVisitor: require('./extend-visitor'),
	    JoinSelectorVisitor: require('./join-selector-visitor'),
	    ToCSSVisitor: require('./to-css-visitor')
	};

	module.exports = visitors;

	},{"./extend-visitor":84,"./import-visitor":86,"./join-selector-visitor":88,"./set-tree-visibility-visitor":89,"./to-css-visitor":90,"./visitor":91}],88:[function(require,module,exports){
	var Visitor = require("./visitor");

	var JoinSelectorVisitor = function() {
	    this.contexts = [[]];
	    this._visitor = new Visitor(this);
	};

	JoinSelectorVisitor.prototype = {
	    run: function (root) {
	        return this._visitor.visit(root);
	    },
	    visitRule: function (ruleNode, visitArgs) {
	        visitArgs.visitDeeper = false;
	    },
	    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
	        visitArgs.visitDeeper = false;
	    },

	    visitRuleset: function (rulesetNode, visitArgs) {
	        var context = this.contexts[this.contexts.length - 1],
	            paths = [], selectors;

	        this.contexts.push(paths);

	        if (! rulesetNode.root) {
	            selectors = rulesetNode.selectors;
	            if (selectors) {
	                selectors = selectors.filter(function(selector) { return selector.getIsOutput(); });
	                rulesetNode.selectors = selectors.length ? selectors : (selectors = null);
	                if (selectors) { rulesetNode.joinSelectors(paths, context, selectors); }
	            }
	            if (!selectors) { rulesetNode.rules = null; }
	            rulesetNode.paths = paths;
	        }
	    },
	    visitRulesetOut: function (rulesetNode) {
	        this.contexts.length = this.contexts.length - 1;
	    },
	    visitMedia: function (mediaNode, visitArgs) {
	        var context = this.contexts[this.contexts.length - 1];
	        mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);
	    },
	    visitDirective: function (directiveNode, visitArgs) {
	        var context = this.contexts[this.contexts.length - 1];
	        if (directiveNode.rules && directiveNode.rules.length) {
	            directiveNode.rules[0].root = (directiveNode.isRooted || context.length === 0 || null);
	        }
	    }
	};

	module.exports = JoinSelectorVisitor;

	},{"./visitor":91}],89:[function(require,module,exports){
	var SetTreeVisibilityVisitor = function(visible) {
	    this.visible = visible;
	};
	SetTreeVisibilityVisitor.prototype.run = function(root) {
	    this.visit(root);
	};
	SetTreeVisibilityVisitor.prototype.visitArray = function(nodes) {
	    if (!nodes) {
	        return nodes;
	    }

	    var cnt = nodes.length, i;
	    for (i = 0; i < cnt; i++) {
	        this.visit(nodes[i]);
	    }
	    return nodes;
	};
	SetTreeVisibilityVisitor.prototype.visit = function(node) {
	    if (!node) {
	        return node;
	    }
	    if (node.constructor === Array) {
	        return this.visitArray(node);
	    }

	    if (!node.blocksVisibility || node.blocksVisibility()) {
	        return node;
	    }
	    if (this.visible) {
	        node.ensureVisibility();
	    } else {
	        node.ensureInvisibility();
	    }

	    node.accept(this);
	    return node;
	};
	module.exports = SetTreeVisibilityVisitor;
	},{}],90:[function(require,module,exports){
	var tree = require("../tree"),
	    Visitor = require("./visitor");

	var CSSVisitorUtils = function(context) {
	    this._visitor = new Visitor(this);
	    this._context = context;
	};

	CSSVisitorUtils.prototype = {
	    containsSilentNonBlockedChild: function(bodyRules) {
	        var rule;
	        if (bodyRules == null) {
	            return false;
	        }
	        for (var r = 0; r < bodyRules.length; r++) {
	            rule = bodyRules[r];
	            if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {
	                //the directive contains something that was referenced (likely by extend)
	                //therefore it needs to be shown in output too
	                return true;
	            }
	        }
	        return false;
	    },

	    keepOnlyVisibleChilds: function(owner) {
	        if (owner == null || owner.rules == null) {
	            return ;
	        }

	        owner.rules = owner.rules.filter(function(thing) {
	                return thing.isVisible();
	            }
	        );
	    },

	    isEmpty: function(owner) {
	        if (owner == null || owner.rules == null) {
	            return true;
	        }
	        return owner.rules.length === 0;
	    },

	    hasVisibleSelector: function(rulesetNode) {
	        if (rulesetNode == null || rulesetNode.paths == null) {
	            return false;
	        }
	        return rulesetNode.paths.length > 0;
	    },

	    resolveVisibility: function (node, originalRules) {
	        if (!node.blocksVisibility()) {
	            if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {
	                return ;
	            }

	            return node;
	        }

	        var compiledRulesBody = node.rules[0];
	        this.keepOnlyVisibleChilds(compiledRulesBody);

	        if (this.isEmpty(compiledRulesBody)) {
	            return ;
	        }

	        node.ensureVisibility();
	        node.removeVisibilityBlock();

	        return node;
	    },

	    isVisibleRuleset: function(rulesetNode) {
	        if (rulesetNode.firstRoot) {
	            return true;
	        }

	        if (this.isEmpty(rulesetNode)) {
	            return false;
	        }

	        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {
	            return false;
	        }

	        return true;
	    }

	};

	var ToCSSVisitor = function(context) {
	    this._visitor = new Visitor(this);
	    this._context = context;
	    this.utils = new CSSVisitorUtils(context);
	};

	ToCSSVisitor.prototype = {
	    isReplacing: true,
	    run: function (root) {
	        return this._visitor.visit(root);
	    },

	    visitRule: function (ruleNode, visitArgs) {
	        if (ruleNode.blocksVisibility() || ruleNode.variable) {
	            return;
	        }
	        return ruleNode;
	    },

	    visitMixinDefinition: function (mixinNode, visitArgs) {
	        // mixin definitions do not get eval'd - this means they keep state
	        // so we have to clear that state here so it isn't used if toCSS is called twice
	        mixinNode.frames = [];
	    },

	    visitExtend: function (extendNode, visitArgs) {
	    },

	    visitComment: function (commentNode, visitArgs) {
	        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {
	            return;
	        }
	        return commentNode;
	    },

	    visitMedia: function(mediaNode, visitArgs) {
	        var originalRules = mediaNode.rules[0].rules;
	        mediaNode.accept(this._visitor);
	        visitArgs.visitDeeper = false;

	        return this.utils.resolveVisibility(mediaNode, originalRules);
	    },

	    visitImport: function (importNode, visitArgs) {
	        if (importNode.blocksVisibility()) {
	            return ;
	        }
	        return importNode;
	    },

	    visitDirective: function(directiveNode, visitArgs) {
	        if (directiveNode.rules && directiveNode.rules.length) {
	            return this.visitDirectiveWithBody(directiveNode, visitArgs);
	        } else {
	            return this.visitDirectiveWithoutBody(directiveNode, visitArgs);
	        }
	        return directiveNode;
	    },

	    visitDirectiveWithBody: function(directiveNode, visitArgs) {
	        //if there is only one nested ruleset and that one has no path, then it is
	        //just fake ruleset
	        function hasFakeRuleset(directiveNode) {
	            var bodyRules = directiveNode.rules;
	            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);
	        }
	        function getBodyRules(directiveNode) {
	            var nodeRules = directiveNode.rules;
	            if (hasFakeRuleset(directiveNode)) {
	                return nodeRules[0].rules;
	            }

	            return nodeRules;
	        }
	        //it is still true that it is only one ruleset in array
	        //this is last such moment
	        //process childs
	        var originalRules = getBodyRules(directiveNode);
	        directiveNode.accept(this._visitor);
	        visitArgs.visitDeeper = false;

	        if (!this.utils.isEmpty(directiveNode)) {
	            this._mergeRules(directiveNode.rules[0].rules);
	        }

	        return this.utils.resolveVisibility(directiveNode, originalRules);
	    },

	    visitDirectiveWithoutBody: function(directiveNode, visitArgs) {
	        if (directiveNode.blocksVisibility()) {
	            return;
	        }

	        if (directiveNode.name === "@charset") {
	            // Only output the debug info together with subsequent @charset definitions
	            // a comment (or @media statement) before the actual @charset directive would
	            // be considered illegal css as it has to be on the first line
	            if (this.charset) {
	                if (directiveNode.debugInfo) {
	                    var comment = new tree.Comment("/* " + directiveNode.toCSS(this._context).replace(/\n/g, "") + " */\n");
	                    comment.debugInfo = directiveNode.debugInfo;
	                    return this._visitor.visit(comment);
	                }
	                return;
	            }
	            this.charset = true;
	        }

	        return directiveNode;
	    },

	    checkPropertiesInRoot: function(rules) {
	        var ruleNode;
	        for (var i = 0; i < rules.length; i++) {
	            ruleNode = rules[i];
	            if (ruleNode instanceof tree.Rule && !ruleNode.variable) {
	                throw { message: "properties must be inside selector blocks, they cannot be in the root.",
	                    index: ruleNode.index, filename: ruleNode.currentFileInfo ? ruleNode.currentFileInfo.filename : null};
	            }
	        }
	    },

	    visitRuleset: function (rulesetNode, visitArgs) {
	        //at this point rulesets are nested into each other
	        var rule, rulesets = [];
	        if (rulesetNode.firstRoot) {
	            this.checkPropertiesInRoot(rulesetNode.rules);
	        }
	        if (! rulesetNode.root) {
	            //remove invisible paths
	            this._compileRulesetPaths(rulesetNode);

	            // remove rulesets from this ruleset body and compile them separately
	            var nodeRules = rulesetNode.rules, nodeRuleCnt = nodeRules ? nodeRules.length : 0;
	            for (var i = 0; i < nodeRuleCnt; ) {
	                rule = nodeRules[i];
	                if (rule && rule.rules) {
	                    // visit because we are moving them out from being a child
	                    rulesets.push(this._visitor.visit(rule));
	                    nodeRules.splice(i, 1);
	                    nodeRuleCnt--;
	                    continue;
	                }
	                i++;
	            }
	            // accept the visitor to remove rules and refactor itself
	            // then we can decide nogw whether we want it or not
	            // compile body
	            if (nodeRuleCnt > 0) {
	                rulesetNode.accept(this._visitor);
	            } else {
	                rulesetNode.rules = null;
	            }
	            visitArgs.visitDeeper = false;

	        } else { //if (! rulesetNode.root) {
	            rulesetNode.accept(this._visitor);
	            visitArgs.visitDeeper = false;
	        }

	        if (rulesetNode.rules) {
	            this._mergeRules(rulesetNode.rules);
	            this._removeDuplicateRules(rulesetNode.rules);
	        }

	        //now decide whether we keep the ruleset
	        if (this.utils.isVisibleRuleset(rulesetNode)) {
	            rulesetNode.ensureVisibility();
	            rulesets.splice(0, 0, rulesetNode);
	        }

	        if (rulesets.length === 1) {
	            return rulesets[0];
	        }
	        return rulesets;
	    },

	    _compileRulesetPaths: function(rulesetNode) {
	        if (rulesetNode.paths) {
	            rulesetNode.paths = rulesetNode.paths
	                .filter(function(p) {
	                    var i;
	                    if (p[0].elements[0].combinator.value === ' ') {
	                        p[0].elements[0].combinator = new(tree.Combinator)('');
	                    }
	                    for (i = 0; i < p.length; i++) {
	                        if (p[i].isVisible() && p[i].getIsOutput()) {
	                            return true;
	                        }
	                    }
	                    return false;
	                });
	        }
	    },

	    _removeDuplicateRules: function(rules) {
	        if (!rules) { return; }

	        // remove duplicates
	        var ruleCache = {},
	            ruleList, rule, i;

	        for (i = rules.length - 1; i >= 0 ; i--) {
	            rule = rules[i];
	            if (rule instanceof tree.Rule) {
	                if (!ruleCache[rule.name]) {
	                    ruleCache[rule.name] = rule;
	                } else {
	                    ruleList = ruleCache[rule.name];
	                    if (ruleList instanceof tree.Rule) {
	                        ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];
	                    }
	                    var ruleCSS = rule.toCSS(this._context);
	                    if (ruleList.indexOf(ruleCSS) !== -1) {
	                        rules.splice(i, 1);
	                    } else {
	                        ruleList.push(ruleCSS);
	                    }
	                }
	            }
	        }
	    },

	    _mergeRules: function (rules) {
	        if (!rules) { return; }

	        var groups = {},
	            parts,
	            rule,
	            key;

	        for (var i = 0; i < rules.length; i++) {
	            rule = rules[i];

	            if ((rule instanceof tree.Rule) && rule.merge) {
	                key = [rule.name,
	                    rule.important ? "!" : ""].join(",");

	                if (!groups[key]) {
	                    groups[key] = [];
	                } else {
	                    rules.splice(i--, 1);
	                }

	                groups[key].push(rule);
	            }
	        }

	        Object.keys(groups).map(function (k) {

	            function toExpression(values) {
	                return new (tree.Expression)(values.map(function (p) {
	                    return p.value;
	                }));
	            }

	            function toValue(values) {
	                return new (tree.Value)(values.map(function (p) {
	                    return p;
	                }));
	            }

	            parts = groups[k];

	            if (parts.length > 1) {
	                rule = parts[0];
	                var spacedGroups = [];
	                var lastSpacedGroup = [];
	                parts.map(function (p) {
	                    if (p.merge === "+") {
	                        if (lastSpacedGroup.length > 0) {
	                            spacedGroups.push(toExpression(lastSpacedGroup));
	                        }
	                        lastSpacedGroup = [];
	                    }
	                    lastSpacedGroup.push(p);
	                });
	                spacedGroups.push(toExpression(lastSpacedGroup));
	                rule.value = toValue(spacedGroups);
	            }
	        });
	    },

	    visitAnonymous: function(anonymousNode, visitArgs) {
	        if (anonymousNode.blocksVisibility()) {
	            return ;
	        }
	        anonymousNode.accept(this._visitor);
	        return anonymousNode;
	    }
	};

	module.exports = ToCSSVisitor;

	},{"../tree":62,"./visitor":91}],91:[function(require,module,exports){
	var tree = require("../tree");

	var _visitArgs = { visitDeeper: true },
	    _hasIndexed = false;

	function _noop(node) {
	    return node;
	}

	function indexNodeTypes(parent, ticker) {
	    // add .typeIndex to tree node types for lookup table
	    var key, child;
	    for (key in parent) {
	        if (parent.hasOwnProperty(key)) {
	            child = parent[key];
	            switch (typeof child) {
	                case "function":
	                    // ignore bound functions directly on tree which do not have a prototype
	                    // or aren't nodes
	                    if (child.prototype && child.prototype.type) {
	                        child.prototype.typeIndex = ticker++;
	                    }
	                    break;
	                case "object":
	                    ticker = indexNodeTypes(child, ticker);
	                    break;
	            }
	        }
	    }
	    return ticker;
	}

	var Visitor = function(implementation) {
	    this._implementation = implementation;
	    this._visitFnCache = [];

	    if (!_hasIndexed) {
	        indexNodeTypes(tree, 1);
	        _hasIndexed = true;
	    }
	};

	Visitor.prototype = {
	    visit: function(node) {
	        if (!node) {
	            return node;
	        }

	        var nodeTypeIndex = node.typeIndex;
	        if (!nodeTypeIndex) {
	            return node;
	        }

	        var visitFnCache = this._visitFnCache,
	            impl = this._implementation,
	            aryIndx = nodeTypeIndex << 1,
	            outAryIndex = aryIndx | 1,
	            func = visitFnCache[aryIndx],
	            funcOut = visitFnCache[outAryIndex],
	            visitArgs = _visitArgs,
	            fnName;

	        visitArgs.visitDeeper = true;

	        if (!func) {
	            fnName = "visit" + node.type;
	            func = impl[fnName] || _noop;
	            funcOut = impl[fnName + "Out"] || _noop;
	            visitFnCache[aryIndx] = func;
	            visitFnCache[outAryIndex] = funcOut;
	        }

	        if (func !== _noop) {
	            var newNode = func.call(impl, node, visitArgs);
	            if (impl.isReplacing) {
	                node = newNode;
	            }
	        }

	        if (visitArgs.visitDeeper && node && node.accept) {
	            node.accept(this);
	        }

	        if (funcOut != _noop) {
	            funcOut.call(impl, node);
	        }

	        return node;
	    },
	    visitArray: function(nodes, nonReplacing) {
	        if (!nodes) {
	            return nodes;
	        }

	        var cnt = nodes.length, i;

	        // Non-replacing
	        if (nonReplacing || !this._implementation.isReplacing) {
	            for (i = 0; i < cnt; i++) {
	                this.visit(nodes[i]);
	            }
	            return nodes;
	        }

	        // Replacing
	        var out = [];
	        for (i = 0; i < cnt; i++) {
	            var evald = this.visit(nodes[i]);
	            if (evald === undefined) { continue; }
	            if (!evald.splice) {
	                out.push(evald);
	            } else if (evald.length) {
	                this.flatten(evald, out);
	            }
	        }
	        return out;
	    },
	    flatten: function(arr, out) {
	        if (!out) {
	            out = [];
	        }

	        var cnt, i, item,
	            nestedCnt, j, nestedItem;

	        for (i = 0, cnt = arr.length; i < cnt; i++) {
	            item = arr[i];
	            if (item === undefined) {
	                continue;
	            }
	            if (!item.splice) {
	                out.push(item);
	                continue;
	            }

	            for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {
	                nestedItem = item[j];
	                if (nestedItem === undefined) {
	                    continue;
	                }
	                if (!nestedItem.splice) {
	                    out.push(nestedItem);
	                } else if (nestedItem.length) {
	                    this.flatten(nestedItem, out);
	                }
	            }
	        }

	        return out;
	    }
	};
	module.exports = Visitor;

	},{"../tree":62}],92:[function(require,module,exports){
	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    draining = true;
	    var currentQueue;
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        var i = -1;
	        while (++i < len) {
	            currentQueue[i]();
	        }
	        len = queue.length;
	    }
	    draining = false;
	}
	process.nextTick = function (fun) {
	    queue.push(fun);
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };

	},{}],93:[function(require,module,exports){
	'use strict';

	var asap = require('asap')

	module.exports = Promise;
	function Promise(fn) {
	  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
	  if (typeof fn !== 'function') throw new TypeError('not a function')
	  var state = null
	  var value = null
	  var deferreds = []
	  var self = this

	  this.then = function(onFulfilled, onRejected) {
	    return new self.constructor(function(resolve, reject) {
	      handle(new Handler(onFulfilled, onRejected, resolve, reject))
	    })
	  }

	  function handle(deferred) {
	    if (state === null) {
	      deferreds.push(deferred)
	      return
	    }
	    asap(function() {
	      var cb = state ? deferred.onFulfilled : deferred.onRejected
	      if (cb === null) {
	        (state ? deferred.resolve : deferred.reject)(value)
	        return
	      }
	      var ret
	      try {
	        ret = cb(value)
	      }
	      catch (e) {
	        deferred.reject(e)
	        return
	      }
	      deferred.resolve(ret)
	    })
	  }

	  function resolve(newValue) {
	    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then
	        if (typeof then === 'function') {
	          doResolve(then.bind(newValue), resolve, reject)
	          return
	        }
	      }
	      state = true
	      value = newValue
	      finale()
	    } catch (e) { reject(e) }
	  }

	  function reject(newValue) {
	    state = false
	    value = newValue
	    finale()
	  }

	  function finale() {
	    for (var i = 0, len = deferreds.length; i < len; i++)
	      handle(deferreds[i])
	    deferreds = null
	  }

	  doResolve(fn, resolve, reject)
	}


	function Handler(onFulfilled, onRejected, resolve, reject){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null
	  this.resolve = resolve
	  this.reject = reject
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, onFulfilled, onRejected) {
	  var done = false;
	  try {
	    fn(function (value) {
	      if (done) return
	      done = true
	      onFulfilled(value)
	    }, function (reason) {
	      if (done) return
	      done = true
	      onRejected(reason)
	    })
	  } catch (ex) {
	    if (done) return
	    done = true
	    onRejected(ex)
	  }
	}

	},{"asap":95}],94:[function(require,module,exports){
	'use strict';

	//This file contains the ES6 extensions to the core Promises/A+ API

	var Promise = require('./core.js')
	var asap = require('asap')

	module.exports = Promise

	/* Static Functions */

	function ValuePromise(value) {
	  this.then = function (onFulfilled) {
	    if (typeof onFulfilled !== 'function') return this
	    return new Promise(function (resolve, reject) {
	      asap(function () {
	        try {
	          resolve(onFulfilled(value))
	        } catch (ex) {
	          reject(ex);
	        }
	      })
	    })
	  }
	}
	ValuePromise.prototype = Promise.prototype

	var TRUE = new ValuePromise(true)
	var FALSE = new ValuePromise(false)
	var NULL = new ValuePromise(null)
	var UNDEFINED = new ValuePromise(undefined)
	var ZERO = new ValuePromise(0)
	var EMPTYSTRING = new ValuePromise('')

	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value

	  if (value === null) return NULL
	  if (value === undefined) return UNDEFINED
	  if (value === true) return TRUE
	  if (value === false) return FALSE
	  if (value === 0) return ZERO
	  if (value === '') return EMPTYSTRING

	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value))
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex)
	      })
	    }
	  }

	  return new ValuePromise(value)
	}

	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr)

	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([])
	    var remaining = args.length
	    function res(i, val) {
	      try {
	        if (val && (typeof val === 'object' || typeof val === 'function')) {
	          var then = val.then
	          if (typeof then === 'function') {
	            then.call(val, function (val) { res(i, val) }, reject)
	            return
	          }
	        }
	        args[i] = val
	        if (--remaining === 0) {
	          resolve(args);
	        }
	      } catch (ex) {
	        reject(ex)
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i])
	    }
	  })
	}

	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) { 
	    reject(value);
	  });
	}

	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) { 
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    })
	  });
	}

	/* Prototype Methods */

	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	}

	},{"./core.js":93,"asap":95}],95:[function(require,module,exports){
	(function (process){

	// Use the fastest possible means to execute a task in a future turn
	// of the event loop.

	// linked list of tasks (single, with head node)
	var head = {task: void 0, next: null};
	var tail = head;
	var flushing = false;
	var requestFlush = void 0;
	var isNodeJS = false;

	function flush() {
	    /* jshint loopfunc: true */

	    while (head.next) {
	        head = head.next;
	        var task = head.task;
	        head.task = void 0;
	        var domain = head.domain;

	        if (domain) {
	            head.domain = void 0;
	            domain.enter();
	        }

	        try {
	            task();

	        } catch (e) {
	            if (isNodeJS) {
	                // In node, uncaught exceptions are considered fatal errors.
	                // Re-throw them synchronously to interrupt flushing!

	                // Ensure continuation if the uncaught exception is suppressed
	                // listening "uncaughtException" events (as domains does).
	                // Continue in next event to avoid tick recursion.
	                if (domain) {
	                    domain.exit();
	                }
	                setTimeout(flush, 0);
	                if (domain) {
	                    domain.enter();
	                }

	                throw e;

	            } else {
	                // In browsers, uncaught exceptions are not fatal.
	                // Re-throw them asynchronously to avoid slow-downs.
	                setTimeout(function() {
	                   throw e;
	                }, 0);
	            }
	        }

	        if (domain) {
	            domain.exit();
	        }
	    }

	    flushing = false;
	}

	if (typeof process !== "undefined" && process.nextTick) {
	    // Node.js before 0.9. Note that some fake-Node environments, like the
	    // Mocha test runner, introduce a `process` global without a `nextTick`.
	    isNodeJS = true;

	    requestFlush = function () {
	        process.nextTick(flush);
	    };

	} else if (typeof setImmediate === "function") {
	    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	    if (typeof window !== "undefined") {
	        requestFlush = setImmediate.bind(window, flush);
	    } else {
	        requestFlush = function () {
	            setImmediate(flush);
	        };
	    }

	} else if (typeof MessageChannel !== "undefined") {
	    // modern browsers
	    // http://www.nonblocking.io/2011/06/windownexttick.html
	    var channel = new MessageChannel();
	    channel.port1.onmessage = flush;
	    requestFlush = function () {
	        channel.port2.postMessage(0);
	    };

	} else {
	    // old browsers
	    requestFlush = function () {
	        setTimeout(flush, 0);
	    };
	}

	function asap(task) {
	    tail = tail.next = {
	        task: task,
	        domain: isNodeJS && process.domain,
	        next: null
	    };

	    if (!flushing) {
	        flushing = true;
	        requestFlush();
	    }
	};

	module.exports = asap;


	}).call(this,require('_process'))
	},{"_process":92}],96:[function(require,module,exports){
	// should work in any browser without browserify

	if (typeof Promise.prototype.done !== 'function') {
	  Promise.prototype.done = function (onFulfilled, onRejected) {
	    var self = arguments.length ? this.then.apply(this, arguments) : this
	    self.then(null, function (err) {
	      setTimeout(function () {
	        throw err
	      }, 0)
	    })
	  }
	}
	},{}],97:[function(require,module,exports){
	// not "use strict" so we can declare global "Promise"

	var asap = require('asap');

	if (typeof Promise === 'undefined') {
	  Promise = require('./lib/core.js')
	  require('./lib/es6-extensions.js')
	}

	require('./polyfill-done.js');

	},{"./lib/core.js":93,"./lib/es6-extensions.js":94,"./polyfill-done.js":96,"asap":95}]},{},[2])(2)
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(102).setImmediate))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(26).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(102).setImmediate, __webpack_require__(102).clearImmediate))

/***/ },
/* 103 */
/***/ function(module, exports) {

	
	/*!
	 * Jade - doctypes
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	module.exports = {
	    '5': '<!DOCTYPE html>'
	  , 'default': '<!DOCTYPE html>'
	  , 'xml': '<?xml version="1.0" encoding="utf-8" ?>'
	  , 'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
	  , 'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
	  , 'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
	  , '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">'
	  , 'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
	  , 'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
	};

/***/ },
/* 104 */
/***/ function(module, exports) {

	
	/*!
	 * Jade - self closing tags
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	module.exports = [
	    'meta'
	  , 'img'
	  , 'link'
	  , 'input'
	  , 'source'
	  , 'area'
	  , 'base'
	  , 'col'
	  , 'br'
	  , 'hr'
	];

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Jade - runtime
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Lame Array.isArray() polyfill for now.
	 */

	if (!Array.isArray) {
	  Array.isArray = function(arr){
	    return '[object Array]' == Object.prototype.toString.call(arr);
	  };
	}

	/**
	 * Lame Object.keys() polyfill for now.
	 */

	if (!Object.keys) {
	  Object.keys = function(obj){
	    var arr = [];
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        arr.push(key);
	      }
	    }
	    return arr;
	  }
	}

	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */

	exports.merge = function merge(a, b) {
	  var ac = a['class'];
	  var bc = b['class'];

	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    ac = ac.filter(nulls);
	    bc = bc.filter(nulls);
	    a['class'] = ac.concat(bc).join(' ');
	  }

	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }

	  return a;
	};

	/**
	 * Filter null `val`s.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function nulls(val) {
	  return val != null;
	}

	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 * @api private
	 */

	exports.attrs = function attrs(obj, escaped){
	  var buf = []
	    , terse = obj.terse;

	  delete obj.terse;
	  var keys = Object.keys(obj)
	    , len = keys.length;

	  if (len) {
	    buf.push('');
	    for (var i = 0; i < len; ++i) {
	      var key = keys[i]
	        , val = obj[key];

	      if ('boolean' == typeof val || null == val) {
	        if (val) {
	          terse
	            ? buf.push(key)
	            : buf.push(key + '="' + key + '"');
	        }
	      } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	        buf.push(key + "='" + JSON.stringify(val) + "'");
	      } else if ('class' == key && Array.isArray(val)) {
	        buf.push(key + '="' + exports.escape(val.join(' ')) + '"');
	      } else if (escaped && escaped[key]) {
	        buf.push(key + '="' + exports.escape(val) + '"');
	      } else {
	        buf.push(key + '="' + val + '"');
	      }
	    }
	  }

	  return buf.join(' ');
	};

	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */

	exports.escape = function escape(html){
	  return String(html)
	    .replace(/&(?!(\w+|\#\d+);)/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;');
	};

	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */

	exports.rethrow = function rethrow(err, filename, lineno){
	  if (!filename) throw err;

	  var context = 3
	    , str = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFileSync(filename, 'utf8')
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);

	  // Error context
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');

	  // Alter exception message
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};


/***/ },
/* 106 */
/***/ function(module, exports) {

	
	/*!
	 * Jade - utils
	 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
	 * MIT Licensed
	 */

	/**
	 * Convert interpolation in the given string to JavaScript.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api private
	 */

	var interpolate = exports.interpolate = function(str){
	  return str.replace(/(\\)?([#!]){(.*?)}/g, function(str, escape, flag, code){
	    return escape
	      ? str
	      : "' + "
	        + ('!' == flag ? '' : 'escape')
	        + "((interp = " + code.replace(/\\'/g, "'")
	        + ") == null ? '' : interp) + '";
	  });
	};

	/**
	 * Escape single quotes in `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api private
	 */

	var escape = exports.escape = function(str) {
	  return str.replace(/'/g, "\\'");
	};

	/**
	 * Interpolate, and escape the given `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api private
	 */

	exports.text = function(str){
	  return interpolate(escape(str));
	};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 */

	var Base = __webpack_require__(32);

	/**
	 * Expose `List`.
	 */

	exports = module.exports = List;

	/**
	 * Initialize a new `List` test reporter.
	 *
	 * @api public
	 * @param {Runner} runner
	 */
	function List(runner) {
	  Base.call(this, runner);

	  var self = this;
	  var total = runner.total;

	  runner.on('start', function() {
	    console.log(JSON.stringify(['start', { total: total }]));
	  });

	  runner.on('pass', function(test) {
	    console.log(JSON.stringify(['pass', clean(test)]));
	  });

	  runner.on('fail', function(test, err) {
	    test = clean(test);
	    test.err = err.message;
	    test.stack = err.stack || null;
	    console.log(JSON.stringify(['fail', test]));
	  });

	  runner.on('end', function() {
	    process.stdout.write(JSON.stringify(['end', self.stats]));
	  });
	}

	/**
	 * Return a plain-object representation of `test`
	 * free of cyclic properties etc.
	 *
	 * @api private
	 * @param {Object} test
	 * @return {Object}
	 */
	function clean(test) {
	  return {
	    title: test.title,
	    fullTitle: test.fullTitle(),
	    duration: test.duration,
	    currentRetry: test.currentRetry()
	  };
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	exports.bdd = __webpack_require__(109);
	exports.tdd = __webpack_require__(117);
	exports.qunit = __webpack_require__(118);
	exports.exports = __webpack_require__(119);


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Suite = __webpack_require__(110);
	var Test = __webpack_require__(115);
	var escapeRe = __webpack_require__(29);

	/**
	 * BDD-style interface:
	 *
	 *      describe('Array', function() {
	 *        describe('#indexOf()', function() {
	 *          it('should return -1 when not present', function() {
	 *            // ...
	 *          });
	 *
	 *          it('should return the index when present', function() {
	 *            // ...
	 *          });
	 *        });
	 *      });
	 *
	 * @param {Suite} suite Root suite.
	 */
	module.exports = function(suite) {
	  var suites = [suite];

	  suite.on('pre-require', function(context, file, mocha) {
	    var common = __webpack_require__(116)(suites, context);

	    context.before = common.before;
	    context.after = common.after;
	    context.beforeEach = common.beforeEach;
	    context.afterEach = common.afterEach;
	    context.run = mocha.options.delay && common.runWithSuite(suite);
	    /**
	     * Describe a "suite" with the given `title`
	     * and callback `fn` containing nested suites
	     * and/or tests.
	     */

	    context.describe = context.context = function(title, fn) {
	      var suite = Suite.create(suites[0], title);
	      suite.file = file;
	      suites.unshift(suite);
	      fn.call(suite);
	      suites.shift();
	      return suite;
	    };

	    /**
	     * Pending describe.
	     */

	    context.xdescribe = context.xcontext = context.describe.skip = function(title, fn) {
	      var suite = Suite.create(suites[0], title);
	      suite.pending = true;
	      suites.unshift(suite);
	      fn.call(suite);
	      suites.shift();
	    };

	    /**
	     * Exclusive suite.
	     */

	    context.describe.only = function(title, fn) {
	      var suite = context.describe(title, fn);
	      mocha.grep(suite.fullTitle());
	      return suite;
	    };

	    /**
	     * Describe a specification or test-case
	     * with the given `title` and callback `fn`
	     * acting as a thunk.
	     */

	    var it = context.it = context.specify = function(title, fn) {
	      var suite = suites[0];
	      if (suite.pending) {
	        fn = null;
	      }
	      var test = new Test(title, fn);
	      test.file = file;
	      suite.addTest(test);
	      return test;
	    };

	    /**
	     * Exclusive test-case.
	     */

	    context.it.only = function(title, fn) {
	      var test = it(title, fn);
	      var reString = '^' + escapeRe(test.fullTitle()) + '$';
	      mocha.grep(new RegExp(reString));
	      return test;
	    };

	    /**
	     * Pending test case.
	     */

	    context.xit = context.xspecify = context.it.skip = function(title) {
	      context.it(title);
	    };

	    /**
	     * Number of attempts to retry.
	     */
	    context.it.retries = function(n) {
	      context.retries(n);
	    };
	  });
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var EventEmitter = __webpack_require__(111).EventEmitter;
	var Hook = __webpack_require__(112);
	var utils = __webpack_require__(36);
	var inherits = utils.inherits;
	var debug = __webpack_require__(41)('mocha:suite');
	var milliseconds = __webpack_require__(35);

	/**
	 * Expose `Suite`.
	 */

	exports = module.exports = Suite;

	/**
	 * Create a new `Suite` with the given `title` and parent `Suite`. When a suite
	 * with the same title is already present, that suite is returned to provide
	 * nicer reporter and more flexible meta-testing.
	 *
	 * @api public
	 * @param {Suite} parent
	 * @param {string} title
	 * @return {Suite}
	 */
	exports.create = function(parent, title) {
	  var suite = new Suite(title, parent.ctx);
	  suite.parent = parent;
	  if (parent.pending) {
	    suite.pending = true;
	  }
	  title = suite.fullTitle();
	  parent.addSuite(suite);
	  return suite;
	};

	/**
	 * Initialize a new `Suite` with the given `title` and `ctx`.
	 *
	 * @api private
	 * @param {string} title
	 * @param {Context} parentContext
	 */
	function Suite(title, parentContext) {
	  this.title = title;
	  function Context() {}
	  Context.prototype = parentContext;
	  this.ctx = new Context();
	  this.suites = [];
	  this.tests = [];
	  this.pending = false;
	  this._beforeEach = [];
	  this._beforeAll = [];
	  this._afterEach = [];
	  this._afterAll = [];
	  this.root = !title;
	  this._timeout = 2000;
	  this._enableTimeouts = true;
	  this._slow = 75;
	  this._bail = false;
	  this._retries = -1;
	  this.delayed = false;
	}

	/**
	 * Inherit from `EventEmitter.prototype`.
	 */
	inherits(Suite, EventEmitter);

	/**
	 * Return a clone of this `Suite`.
	 *
	 * @api private
	 * @return {Suite}
	 */
	Suite.prototype.clone = function() {
	  var suite = new Suite(this.title);
	  debug('clone');
	  suite.ctx = this.ctx;
	  suite.timeout(this.timeout());
	  suite.retries(this.retries());
	  suite.enableTimeouts(this.enableTimeouts());
	  suite.slow(this.slow());
	  suite.bail(this.bail());
	  return suite;
	};

	/**
	 * Set timeout `ms` or short-hand such as "2s".
	 *
	 * @api private
	 * @param {number|string} ms
	 * @return {Suite|number} for chaining
	 */
	Suite.prototype.timeout = function(ms) {
	  if (!arguments.length) {
	    return this._timeout;
	  }
	  if (ms.toString() === '0') {
	    this._enableTimeouts = false;
	  }
	  if (typeof ms === 'string') {
	    ms = milliseconds(ms);
	  }
	  debug('timeout %d', ms);
	  this._timeout = parseInt(ms, 10);
	  return this;
	};

	/**
	 * Set number of times to retry a failed test.
	 *
	 * @api private
	 * @param {number|string} n
	 * @return {Suite|number} for chaining
	 */
	Suite.prototype.retries = function(n) {
	  if (!arguments.length) {
	    return this._retries;
	  }
	  debug('retries %d', n);
	  this._retries = parseInt(n, 10) || 0;
	  return this;
	};

	/**
	  * Set timeout to `enabled`.
	  *
	  * @api private
	  * @param {boolean} enabled
	  * @return {Suite|boolean} self or enabled
	  */
	Suite.prototype.enableTimeouts = function(enabled) {
	  if (!arguments.length) {
	    return this._enableTimeouts;
	  }
	  debug('enableTimeouts %s', enabled);
	  this._enableTimeouts = enabled;
	  return this;
	};

	/**
	 * Set slow `ms` or short-hand such as "2s".
	 *
	 * @api private
	 * @param {number|string} ms
	 * @return {Suite|number} for chaining
	 */
	Suite.prototype.slow = function(ms) {
	  if (!arguments.length) {
	    return this._slow;
	  }
	  if (typeof ms === 'string') {
	    ms = milliseconds(ms);
	  }
	  debug('slow %d', ms);
	  this._slow = ms;
	  return this;
	};

	/**
	 * Sets whether to bail after first error.
	 *
	 * @api private
	 * @param {boolean} bail
	 * @return {Suite|number} for chaining
	 */
	Suite.prototype.bail = function(bail) {
	  if (!arguments.length) {
	    return this._bail;
	  }
	  debug('bail %s', bail);
	  this._bail = bail;
	  return this;
	};

	/**
	 * Run `fn(test[, done])` before running tests.
	 *
	 * @api private
	 * @param {string} title
	 * @param {Function} fn
	 * @return {Suite} for chaining
	 */
	Suite.prototype.beforeAll = function(title, fn) {
	  if (this.pending) {
	    return this;
	  }
	  if (typeof title === 'function') {
	    fn = title;
	    title = fn.name;
	  }
	  title = '"before all" hook' + (title ? ': ' + title : '');

	  var hook = new Hook(title, fn);
	  hook.parent = this;
	  hook.timeout(this.timeout());
	  hook.retries(this.retries());
	  hook.enableTimeouts(this.enableTimeouts());
	  hook.slow(this.slow());
	  hook.ctx = this.ctx;
	  this._beforeAll.push(hook);
	  this.emit('beforeAll', hook);
	  return this;
	};

	/**
	 * Run `fn(test[, done])` after running tests.
	 *
	 * @api private
	 * @param {string} title
	 * @param {Function} fn
	 * @return {Suite} for chaining
	 */
	Suite.prototype.afterAll = function(title, fn) {
	  if (this.pending) {
	    return this;
	  }
	  if (typeof title === 'function') {
	    fn = title;
	    title = fn.name;
	  }
	  title = '"after all" hook' + (title ? ': ' + title : '');

	  var hook = new Hook(title, fn);
	  hook.parent = this;
	  hook.timeout(this.timeout());
	  hook.retries(this.retries());
	  hook.enableTimeouts(this.enableTimeouts());
	  hook.slow(this.slow());
	  hook.ctx = this.ctx;
	  this._afterAll.push(hook);
	  this.emit('afterAll', hook);
	  return this;
	};

	/**
	 * Run `fn(test[, done])` before each test case.
	 *
	 * @api private
	 * @param {string} title
	 * @param {Function} fn
	 * @return {Suite} for chaining
	 */
	Suite.prototype.beforeEach = function(title, fn) {
	  if (this.pending) {
	    return this;
	  }
	  if (typeof title === 'function') {
	    fn = title;
	    title = fn.name;
	  }
	  title = '"before each" hook' + (title ? ': ' + title : '');

	  var hook = new Hook(title, fn);
	  hook.parent = this;
	  hook.timeout(this.timeout());
	  hook.retries(this.retries());
	  hook.enableTimeouts(this.enableTimeouts());
	  hook.slow(this.slow());
	  hook.ctx = this.ctx;
	  this._beforeEach.push(hook);
	  this.emit('beforeEach', hook);
	  return this;
	};

	/**
	 * Run `fn(test[, done])` after each test case.
	 *
	 * @api private
	 * @param {string} title
	 * @param {Function} fn
	 * @return {Suite} for chaining
	 */
	Suite.prototype.afterEach = function(title, fn) {
	  if (this.pending) {
	    return this;
	  }
	  if (typeof title === 'function') {
	    fn = title;
	    title = fn.name;
	  }
	  title = '"after each" hook' + (title ? ': ' + title : '');

	  var hook = new Hook(title, fn);
	  hook.parent = this;
	  hook.timeout(this.timeout());
	  hook.retries(this.retries());
	  hook.enableTimeouts(this.enableTimeouts());
	  hook.slow(this.slow());
	  hook.ctx = this.ctx;
	  this._afterEach.push(hook);
	  this.emit('afterEach', hook);
	  return this;
	};

	/**
	 * Add a test `suite`.
	 *
	 * @api private
	 * @param {Suite} suite
	 * @return {Suite} for chaining
	 */
	Suite.prototype.addSuite = function(suite) {
	  suite.parent = this;
	  suite.timeout(this.timeout());
	  suite.retries(this.retries());
	  suite.enableTimeouts(this.enableTimeouts());
	  suite.slow(this.slow());
	  suite.bail(this.bail());
	  this.suites.push(suite);
	  this.emit('suite', suite);
	  return this;
	};

	/**
	 * Add a `test` to this suite.
	 *
	 * @api private
	 * @param {Test} test
	 * @return {Suite} for chaining
	 */
	Suite.prototype.addTest = function(test) {
	  test.parent = this;
	  test.timeout(this.timeout());
	  test.retries(this.retries());
	  test.enableTimeouts(this.enableTimeouts());
	  test.slow(this.slow());
	  test.ctx = this.ctx;
	  this.tests.push(test);
	  this.emit('test', test);
	  return this;
	};

	/**
	 * Return the full title generated by recursively concatenating the parent's
	 * full title.
	 *
	 * @api public
	 * @return {string}
	 */
	Suite.prototype.fullTitle = function() {
	  if (this.parent) {
	    var full = this.parent.fullTitle();
	    if (full) {
	      return full + ' ' + this.title;
	    }
	  }
	  return this.title;
	};

	/**
	 * Return the total number of tests.
	 *
	 * @api public
	 * @return {number}
	 */
	Suite.prototype.total = function() {
	  return utils.reduce(this.suites, function(sum, suite) {
	    return sum + suite.total();
	  }, 0) + this.tests.length;
	};

	/**
	 * Iterates through each suite recursively to find all tests. Applies a
	 * function in the format `fn(test)`.
	 *
	 * @api private
	 * @param {Function} fn
	 * @return {Suite}
	 */
	Suite.prototype.eachTest = function(fn) {
	  utils.forEach(this.tests, fn);
	  utils.forEach(this.suites, function(suite) {
	    suite.eachTest(fn);
	  });
	  return this;
	};

	/**
	 * This will run the root suite if we happen to be running in delayed mode.
	 */
	Suite.prototype.run = function run() {
	  if (this.root) {
	    this.emit('run');
	  }
	};


/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Module exports.
	 */

	exports.EventEmitter = EventEmitter;

	/**
	 * Object#hasOwnProperty reference.
	 */
	var objToString = Object.prototype.toString;

	/**
	 * Check if a value is an array.
	 *
	 * @api private
	 * @param {*} val The value to test.
	 * @return {boolean} true if the value is a boolean, otherwise false.
	 */
	function isArray(val) {
	  return objToString.call(val) === '[object Array]';
	}

	/**
	 * Event emitter constructor.
	 *
	 * @api public
	 */
	function EventEmitter() {}

	/**
	 * Add a listener.
	 *
	 * @api public
	 * @param {string} name Event name.
	 * @param {Function} fn Event handler.
	 * @return {EventEmitter} Emitter instance.
	 */
	EventEmitter.prototype.on = function(name, fn) {
	  if (!this.$events) {
	    this.$events = {};
	  }

	  if (!this.$events[name]) {
	    this.$events[name] = fn;
	  } else if (isArray(this.$events[name])) {
	    this.$events[name].push(fn);
	  } else {
	    this.$events[name] = [this.$events[name], fn];
	  }

	  return this;
	};

	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	/**
	 * Adds a volatile listener.
	 *
	 * @api public
	 * @param {string} name Event name.
	 * @param {Function} fn Event handler.
	 * @return {EventEmitter} Emitter instance.
	 */
	EventEmitter.prototype.once = function(name, fn) {
	  var self = this;

	  function on() {
	    self.removeListener(name, on);
	    fn.apply(this, arguments);
	  }

	  on.listener = fn;
	  this.on(name, on);

	  return this;
	};

	/**
	 * Remove a listener.
	 *
	 * @api public
	 * @param {string} name Event name.
	 * @param {Function} fn Event handler.
	 * @return {EventEmitter} Emitter instance.
	 */
	EventEmitter.prototype.removeListener = function(name, fn) {
	  if (this.$events && this.$events[name]) {
	    var list = this.$events[name];

	    if (isArray(list)) {
	      var pos = -1;

	      for (var i = 0, l = list.length; i < l; i++) {
	        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
	          pos = i;
	          break;
	        }
	      }

	      if (pos < 0) {
	        return this;
	      }

	      list.splice(pos, 1);

	      if (!list.length) {
	        delete this.$events[name];
	      }
	    } else if (list === fn || (list.listener && list.listener === fn)) {
	      delete this.$events[name];
	    }
	  }

	  return this;
	};

	/**
	 * Remove all listeners for an event.
	 *
	 * @api public
	 * @param {string} name Event name.
	 * @return {EventEmitter} Emitter instance.
	 */
	EventEmitter.prototype.removeAllListeners = function(name) {
	  if (name === undefined) {
	    this.$events = {};
	    return this;
	  }

	  if (this.$events && this.$events[name]) {
	    this.$events[name] = null;
	  }

	  return this;
	};

	/**
	 * Get all listeners for a given event.
	 *
	 * @api public
	 * @param {string} name Event name.
	 * @return {EventEmitter} Emitter instance.
	 */
	EventEmitter.prototype.listeners = function(name) {
	  if (!this.$events) {
	    this.$events = {};
	  }

	  if (!this.$events[name]) {
	    this.$events[name] = [];
	  }

	  if (!isArray(this.$events[name])) {
	    this.$events[name] = [this.$events[name]];
	  }

	  return this.$events[name];
	};

	/**
	 * Emit an event.
	 *
	 * @api public
	 * @param {string} name Event name.
	 * @return {boolean} true if at least one handler was invoked, else false.
	 */
	EventEmitter.prototype.emit = function(name) {
	  if (!this.$events) {
	    return false;
	  }

	  var handler = this.$events[name];

	  if (!handler) {
	    return false;
	  }

	  var args = Array.prototype.slice.call(arguments, 1);

	  if (typeof handler === 'function') {
	    handler.apply(this, args);
	  } else if (isArray(handler)) {
	    var listeners = handler.slice();

	    for (var i = 0, l = listeners.length; i < l; i++) {
	      listeners[i].apply(this, args);
	    }
	  } else {
	    return false;
	  }

	  return true;
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Runnable = __webpack_require__(113);
	var inherits = __webpack_require__(36).inherits;

	/**
	 * Expose `Hook`.
	 */

	module.exports = Hook;

	/**
	 * Initialize a new `Hook` with the given `title` and callback `fn`.
	 *
	 * @param {String} title
	 * @param {Function} fn
	 * @api private
	 */
	function Hook(title, fn) {
	  Runnable.call(this, title, fn);
	  this.type = 'hook';
	}

	/**
	 * Inherit from `Runnable.prototype`.
	 */
	inherits(Hook, Runnable);

	/**
	 * Get or set the test `err`.
	 *
	 * @param {Error} err
	 * @return {Error}
	 * @api public
	 */
	Hook.prototype.error = function(err) {
	  if (!arguments.length) {
	    err = this._error;
	    this._error = null;
	    return err;
	  }

	  this._error = err;
	};


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var EventEmitter = __webpack_require__(111).EventEmitter;
	var Pending = __webpack_require__(114);
	var debug = __webpack_require__(41)('mocha:runnable');
	var milliseconds = __webpack_require__(35);
	var utils = __webpack_require__(36);
	var inherits = utils.inherits;

	/**
	 * Save timer references to avoid Sinon interfering (see GH-237).
	 */

	/* eslint-disable no-unused-vars, no-native-reassign */
	var Date = global.Date;
	var setTimeout = global.setTimeout;
	var setInterval = global.setInterval;
	var clearTimeout = global.clearTimeout;
	var clearInterval = global.clearInterval;
	/* eslint-enable no-unused-vars, no-native-reassign */

	/**
	 * Object#toString().
	 */

	var toString = Object.prototype.toString;

	/**
	 * Expose `Runnable`.
	 */

	module.exports = Runnable;

	/**
	 * Initialize a new `Runnable` with the given `title` and callback `fn`.
	 *
	 * @param {String} title
	 * @param {Function} fn
	 * @api private
	 * @param {string} title
	 * @param {Function} fn
	 */
	function Runnable(title, fn) {
	  this.title = title;
	  this.fn = fn;
	  this.async = fn && fn.length;
	  this.sync = !this.async;
	  this._timeout = 2000;
	  this._slow = 75;
	  this._enableTimeouts = true;
	  this.timedOut = false;
	  this._trace = new Error('done() called multiple times');
	  this._retries = -1;
	  this._currentRetry = 0;
	}

	/**
	 * Inherit from `EventEmitter.prototype`.
	 */
	inherits(Runnable, EventEmitter);

	/**
	 * Set & get timeout `ms`.
	 *
	 * @api private
	 * @param {number|string} ms
	 * @return {Runnable|number} ms or Runnable instance.
	 */
	Runnable.prototype.timeout = function(ms) {
	  if (!arguments.length) {
	    return this._timeout;
	  }
	  if (ms === 0) {
	    this._enableTimeouts = false;
	  }
	  if (typeof ms === 'string') {
	    ms = milliseconds(ms);
	  }
	  debug('timeout %d', ms);
	  this._timeout = ms;
	  if (this.timer) {
	    this.resetTimeout();
	  }
	  return this;
	};

	/**
	 * Set & get slow `ms`.
	 *
	 * @api private
	 * @param {number|string} ms
	 * @return {Runnable|number} ms or Runnable instance.
	 */
	Runnable.prototype.slow = function(ms) {
	  if (!arguments.length) {
	    return this._slow;
	  }
	  if (typeof ms === 'string') {
	    ms = milliseconds(ms);
	  }
	  debug('timeout %d', ms);
	  this._slow = ms;
	  return this;
	};

	/**
	 * Set and get whether timeout is `enabled`.
	 *
	 * @api private
	 * @param {boolean} enabled
	 * @return {Runnable|boolean} enabled or Runnable instance.
	 */
	Runnable.prototype.enableTimeouts = function(enabled) {
	  if (!arguments.length) {
	    return this._enableTimeouts;
	  }
	  debug('enableTimeouts %s', enabled);
	  this._enableTimeouts = enabled;
	  return this;
	};

	/**
	 * Halt and mark as pending.
	 *
	 * @api private
	 */
	Runnable.prototype.skip = function() {
	  throw new Pending();
	};

	/**
	 * Set number of retries.
	 *
	 * @api private
	 */
	Runnable.prototype.retries = function(n) {
	  if (!arguments.length) {
	    return this._retries;
	  }
	  this._retries = n;
	};

	/**
	 * Get current retry
	 *
	 * @api private
	 */
	Runnable.prototype.currentRetry = function(n) {
	  if (!arguments.length) {
	    return this._currentRetry;
	  }
	  this._currentRetry = n;
	};

	/**
	 * Return the full title generated by recursively concatenating the parent's
	 * full title.
	 *
	 * @api public
	 * @return {string}
	 */
	Runnable.prototype.fullTitle = function() {
	  return this.parent.fullTitle() + ' ' + this.title;
	};

	/**
	 * Clear the timeout.
	 *
	 * @api private
	 */
	Runnable.prototype.clearTimeout = function() {
	  clearTimeout(this.timer);
	};

	/**
	 * Inspect the runnable void of private properties.
	 *
	 * @api private
	 * @return {string}
	 */
	Runnable.prototype.inspect = function() {
	  return JSON.stringify(this, function(key, val) {
	    if (key[0] === '_') {
	      return;
	    }
	    if (key === 'parent') {
	      return '#<Suite>';
	    }
	    if (key === 'ctx') {
	      return '#<Context>';
	    }
	    return val;
	  }, 2);
	};

	/**
	 * Reset the timeout.
	 *
	 * @api private
	 */
	Runnable.prototype.resetTimeout = function() {
	  var self = this;
	  var ms = this.timeout() || 1e9;

	  if (!this._enableTimeouts) {
	    return;
	  }
	  this.clearTimeout();
	  this.timer = setTimeout(function() {
	    if (!self._enableTimeouts) {
	      return;
	    }
	    self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));
	    self.timedOut = true;
	  }, ms);
	};

	/**
	 * Whitelist a list of globals for this test run.
	 *
	 * @api private
	 * @param {string[]} globals
	 */
	Runnable.prototype.globals = function(globals) {
	  if (!arguments.length) {
	    return this._allowedGlobals;
	  }
	  this._allowedGlobals = globals;
	};

	/**
	 * Run the test and invoke `fn(err)`.
	 *
	 * @param {Function} fn
	 * @api private
	 */
	Runnable.prototype.run = function(fn) {
	  var self = this;
	  var start = new Date();
	  var ctx = this.ctx;
	  var finished;
	  var emitted;

	  // Sometimes the ctx exists, but it is not runnable
	  if (ctx && ctx.runnable) {
	    ctx.runnable(this);
	  }

	  // called multiple times
	  function multiple(err) {
	    if (emitted) {
	      return;
	    }
	    emitted = true;
	    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));
	  }

	  // finished
	  function done(err) {
	    var ms = self.timeout();
	    if (self.timedOut) {
	      return;
	    }
	    if (finished) {
	      return multiple(err || self._trace);
	    }

	    self.clearTimeout();
	    self.duration = new Date() - start;
	    finished = true;
	    if (!err && self.duration > ms && self._enableTimeouts) {
	      err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');
	    }
	    fn(err);
	  }

	  // for .resetTimeout()
	  this.callback = done;

	  // explicit async with `done` argument
	  if (this.async) {
	    this.resetTimeout();

	    if (this.allowUncaught) {
	      return callFnAsync(this.fn);
	    }
	    try {
	      callFnAsync(this.fn);
	    } catch (err) {
	      done(utils.getError(err));
	    }
	    return;
	  }

	  if (this.allowUncaught) {
	    callFn(this.fn);
	    done();
	    return;
	  }

	  // sync or promise-returning
	  try {
	    if (this.pending) {
	      done();
	    } else {
	      callFn(this.fn);
	    }
	  } catch (err) {
	    done(utils.getError(err));
	  }

	  function callFn(fn) {
	    var result = fn.call(ctx);
	    if (result && typeof result.then === 'function') {
	      self.resetTimeout();
	      result
	        .then(function() {
	          done();
	          // Return null so libraries like bluebird do not warn about
	          // subsequently constructed Promises.
	          return null;
	        },
	        function(reason) {
	          done(reason || new Error('Promise rejected with no or falsy reason'));
	        });
	    } else {
	      if (self.asyncOnly) {
	        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));
	      }

	      done();
	    }
	  }

	  function callFnAsync(fn) {
	    fn.call(ctx, function(err) {
	      if (err instanceof Error || toString.call(err) === '[object Error]') {
	        return done(err);
	      }
	      if (err) {
	        if (Object.prototype.toString.call(err) === '[object Object]') {
	          return done(new Error('done() invoked with non-Error: '
	            + JSON.stringify(err)));
	        }
	        return done(new Error('done() invoked with non-Error: ' + err));
	      }
	      done();
	    });
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 114 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Pending`.
	 */

	module.exports = Pending;

	/**
	 * Initialize a new `Pending` error with the given message.
	 *
	 * @param {string} message
	 */
	function Pending(message) {
	  this.message = message;
	}


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Runnable = __webpack_require__(113);
	var inherits = __webpack_require__(36).inherits;

	/**
	 * Expose `Test`.
	 */

	module.exports = Test;

	/**
	 * Initialize a new `Test` with the given `title` and callback `fn`.
	 *
	 * @api private
	 * @param {String} title
	 * @param {Function} fn
	 */
	function Test(title, fn) {
	  Runnable.call(this, title, fn);
	  this.pending = !fn;
	  this.type = 'test';
	  this.body = (fn || '').toString();
	}

	/**
	 * Inherit from `Runnable.prototype`.
	 */
	inherits(Test, Runnable);

	Test.prototype.clone = function() {
	  var test = new Test(this.title, this.fn);
	  test.timeout(this.timeout());
	  test.slow(this.slow());
	  test.enableTimeouts(this.enableTimeouts());
	  test.retries(this.retries());
	  test.currentRetry(this.currentRetry());
	  test.globals(this.globals());
	  test.parent = this.parent;
	  test.file = this.file;
	  test.ctx = this.ctx;
	  return test;
	};


/***/ },
/* 116 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Functions common to more than one interface.
	 *
	 * @param {Suite[]} suites
	 * @param {Context} context
	 * @return {Object} An object containing common functions.
	 */
	module.exports = function(suites, context) {
	  return {
	    /**
	     * This is only present if flag --delay is passed into Mocha. It triggers
	     * root suite execution.
	     *
	     * @param {Suite} suite The root wuite.
	     * @return {Function} A function which runs the root suite
	     */
	    runWithSuite: function runWithSuite(suite) {
	      return function run() {
	        suite.run();
	      };
	    },

	    /**
	     * Execute before running tests.
	     *
	     * @param {string} name
	     * @param {Function} fn
	     */
	    before: function(name, fn) {
	      suites[0].beforeAll(name, fn);
	    },

	    /**
	     * Execute after running tests.
	     *
	     * @param {string} name
	     * @param {Function} fn
	     */
	    after: function(name, fn) {
	      suites[0].afterAll(name, fn);
	    },

	    /**
	     * Execute before each test case.
	     *
	     * @param {string} name
	     * @param {Function} fn
	     */
	    beforeEach: function(name, fn) {
	      suites[0].beforeEach(name, fn);
	    },

	    /**
	     * Execute after each test case.
	     *
	     * @param {string} name
	     * @param {Function} fn
	     */
	    afterEach: function(name, fn) {
	      suites[0].afterEach(name, fn);
	    },

	    test: {
	      /**
	       * Pending test case.
	       *
	       * @param {string} title
	       */
	      skip: function(title) {
	        context.test(title);
	      },

	      /**
	       * Number of retry attempts
	       *
	       * @param {string} n
	       */
	      retries: function(n) {
	        context.retries(n);
	      }
	    }
	  };
	};


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Suite = __webpack_require__(110);
	var Test = __webpack_require__(115);
	var escapeRe = __webpack_require__(29);

	/**
	 * TDD-style interface:
	 *
	 *      suite('Array', function() {
	 *        suite('#indexOf()', function() {
	 *          suiteSetup(function() {
	 *
	 *          });
	 *
	 *          test('should return -1 when not present', function() {
	 *
	 *          });
	 *
	 *          test('should return the index when present', function() {
	 *
	 *          });
	 *
	 *          suiteTeardown(function() {
	 *
	 *          });
	 *        });
	 *      });
	 *
	 * @param {Suite} suite Root suite.
	 */
	module.exports = function(suite) {
	  var suites = [suite];

	  suite.on('pre-require', function(context, file, mocha) {
	    var common = __webpack_require__(116)(suites, context);

	    context.setup = common.beforeEach;
	    context.teardown = common.afterEach;
	    context.suiteSetup = common.before;
	    context.suiteTeardown = common.after;
	    context.run = mocha.options.delay && common.runWithSuite(suite);

	    /**
	     * Describe a "suite" with the given `title` and callback `fn` containing
	     * nested suites and/or tests.
	     */
	    context.suite = function(title, fn) {
	      var suite = Suite.create(suites[0], title);
	      suite.file = file;
	      suites.unshift(suite);
	      fn.call(suite);
	      suites.shift();
	      return suite;
	    };

	    /**
	     * Pending suite.
	     */
	    context.suite.skip = function(title, fn) {
	      var suite = Suite.create(suites[0], title);
	      suite.pending = true;
	      suites.unshift(suite);
	      fn.call(suite);
	      suites.shift();
	    };

	    /**
	     * Exclusive test-case.
	     */
	    context.suite.only = function(title, fn) {
	      var suite = context.suite(title, fn);
	      mocha.grep(suite.fullTitle());
	    };

	    /**
	     * Describe a specification or test-case with the given `title` and
	     * callback `fn` acting as a thunk.
	     */
	    context.test = function(title, fn) {
	      var suite = suites[0];
	      if (suite.pending) {
	        fn = null;
	      }
	      var test = new Test(title, fn);
	      test.file = file;
	      suite.addTest(test);
	      return test;
	    };

	    /**
	     * Exclusive test-case.
	     */

	    context.test.only = function(title, fn) {
	      var test = context.test(title, fn);
	      var reString = '^' + escapeRe(test.fullTitle()) + '$';
	      mocha.grep(new RegExp(reString));
	    };

	    context.test.skip = common.test.skip;
	    context.test.retries = common.test.retries;
	  });
	};


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Suite = __webpack_require__(110);
	var Test = __webpack_require__(115);
	var escapeRe = __webpack_require__(29);

	/**
	 * QUnit-style interface:
	 *
	 *     suite('Array');
	 *
	 *     test('#length', function() {
	 *       var arr = [1,2,3];
	 *       ok(arr.length == 3);
	 *     });
	 *
	 *     test('#indexOf()', function() {
	 *       var arr = [1,2,3];
	 *       ok(arr.indexOf(1) == 0);
	 *       ok(arr.indexOf(2) == 1);
	 *       ok(arr.indexOf(3) == 2);
	 *     });
	 *
	 *     suite('String');
	 *
	 *     test('#length', function() {
	 *       ok('foo'.length == 3);
	 *     });
	 *
	 * @param {Suite} suite Root suite.
	 */
	module.exports = function(suite) {
	  var suites = [suite];

	  suite.on('pre-require', function(context, file, mocha) {
	    var common = __webpack_require__(116)(suites, context);

	    context.before = common.before;
	    context.after = common.after;
	    context.beforeEach = common.beforeEach;
	    context.afterEach = common.afterEach;
	    context.run = mocha.options.delay && common.runWithSuite(suite);
	    /**
	     * Describe a "suite" with the given `title`.
	     */

	    context.suite = function(title) {
	      if (suites.length > 1) {
	        suites.shift();
	      }
	      var suite = Suite.create(suites[0], title);
	      suite.file = file;
	      suites.unshift(suite);
	      return suite;
	    };

	    /**
	     * Exclusive test-case.
	     */

	    context.suite.only = function(title, fn) {
	      var suite = context.suite(title, fn);
	      mocha.grep(suite.fullTitle());
	    };

	    /**
	     * Describe a specification or test-case
	     * with the given `title` and callback `fn`
	     * acting as a thunk.
	     */

	    context.test = function(title, fn) {
	      var test = new Test(title, fn);
	      test.file = file;
	      suites[0].addTest(test);
	      return test;
	    };

	    /**
	     * Exclusive test-case.
	     */

	    context.test.only = function(title, fn) {
	      var test = context.test(title, fn);
	      var reString = '^' + escapeRe(test.fullTitle()) + '$';
	      mocha.grep(new RegExp(reString));
	    };

	    context.test.skip = common.test.skip;
	    context.test.retries = common.test.retries;
	  });
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Suite = __webpack_require__(110);
	var Test = __webpack_require__(115);

	/**
	 * TDD-style interface:
	 *
	 *     exports.Array = {
	 *       '#indexOf()': {
	 *         'should return -1 when the value is not present': function() {
	 *
	 *         },
	 *
	 *         'should return the correct index when the value is present': function() {
	 *
	 *         }
	 *       }
	 *     };
	 *
	 * @param {Suite} suite Root suite.
	 */
	module.exports = function(suite) {
	  var suites = [suite];

	  suite.on('require', visit);

	  function visit(obj, file) {
	    var suite;
	    for (var key in obj) {
	      if (typeof obj[key] === 'function') {
	        var fn = obj[key];
	        switch (key) {
	          case 'before':
	            suites[0].beforeAll(fn);
	            break;
	          case 'after':
	            suites[0].afterAll(fn);
	            break;
	          case 'beforeEach':
	            suites[0].beforeEach(fn);
	            break;
	          case 'afterEach':
	            suites[0].afterEach(fn);
	            break;
	          default:
	            var test = new Test(key, fn);
	            test.file = file;
	            suites[0].addTest(test);
	        }
	      } else {
	        suite = Suite.create(suites[0], key);
	        suites.unshift(suite);
	        visit(obj[key], file);
	        suites.shift();
	      }
	    }
	  }
	};


/***/ },
/* 120 */
/***/ function(module, exports) {

	/**
	 * Expose `Context`.
	 */

	module.exports = Context;

	/**
	 * Initialize a new `Context`.
	 *
	 * @api private
	 */
	function Context() {}

	/**
	 * Set or get the context `Runnable` to `runnable`.
	 *
	 * @api private
	 * @param {Runnable} runnable
	 * @return {Context}
	 */
	Context.prototype.runnable = function(runnable) {
	  if (!arguments.length) {
	    return this._runnable;
	  }
	  this.test = this._runnable = runnable;
	  return this;
	};

	/**
	 * Set test timeout `ms`.
	 *
	 * @api private
	 * @param {number} ms
	 * @return {Context} self
	 */
	Context.prototype.timeout = function(ms) {
	  if (!arguments.length) {
	    return this.runnable().timeout();
	  }
	  this.runnable().timeout(ms);
	  return this;
	};

	/**
	 * Set test timeout `enabled`.
	 *
	 * @api private
	 * @param {boolean} enabled
	 * @return {Context} self
	 */
	Context.prototype.enableTimeouts = function(enabled) {
	  this.runnable().enableTimeouts(enabled);
	  return this;
	};

	/**
	 * Set test slowness threshold `ms`.
	 *
	 * @api private
	 * @param {number} ms
	 * @return {Context} self
	 */
	Context.prototype.slow = function(ms) {
	  this.runnable().slow(ms);
	  return this;
	};

	/**
	 * Mark a test as skipped.
	 *
	 * @api private
	 * @return {Context} self
	 */
	Context.prototype.skip = function() {
	  this.runnable().skip();
	  return this;
	};

	/**
	 * Allow a number of retries on failed tests
	 *
	 * @api private
	 * @param {number} n
	 * @return {Context} self
	 */
	Context.prototype.retries = function(n) {
	  if (!arguments.length) {
	    return this.runnable().retries();
	  }
	  this.runnable().retries(n);
	  return this;
	};

	/**
	 * Inspect the context void of `._runnable`.
	 *
	 * @api private
	 * @return {string}
	 */
	Context.prototype.inspect = function() {
	  return JSON.stringify(this, function(key, val) {
	    return key === 'runnable' || key === 'test' ? undefined : val;
	  }, 2);
	};


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Module dependencies.
	 */

	var EventEmitter = __webpack_require__(111).EventEmitter;
	var Pending = __webpack_require__(114);
	var utils = __webpack_require__(36);
	var inherits = utils.inherits;
	var debug = __webpack_require__(41)('mocha:runner');
	var Runnable = __webpack_require__(113);
	var filter = utils.filter;
	var indexOf = utils.indexOf;
	var keys = utils.keys;
	var stackFilter = utils.stackTraceFilter();
	var stringify = utils.stringify;
	var type = utils.type;
	var undefinedError = utils.undefinedError;
	var isArray = utils.isArray;

	/**
	 * Non-enumerable globals.
	 */

	var globals = [
	  'setTimeout',
	  'clearTimeout',
	  'setInterval',
	  'clearInterval',
	  'XMLHttpRequest',
	  'Date',
	  'setImmediate',
	  'clearImmediate'
	];

	/**
	 * Expose `Runner`.
	 */

	module.exports = Runner;

	/**
	 * Initialize a `Runner` for the given `suite`.
	 *
	 * Events:
	 *
	 *   - `start`  execution started
	 *   - `end`  execution complete
	 *   - `suite`  (suite) test suite execution started
	 *   - `suite end`  (suite) all tests (and sub-suites) have finished
	 *   - `test`  (test) test execution started
	 *   - `test end`  (test) test completed
	 *   - `hook`  (hook) hook execution started
	 *   - `hook end`  (hook) hook complete
	 *   - `pass`  (test) test passed
	 *   - `fail`  (test, err) test failed
	 *   - `pending`  (test) test pending
	 *
	 * @api public
	 * @param {Suite} suite Root suite
	 * @param {boolean} [delay] Whether or not to delay execution of root suite
	 * until ready.
	 */
	function Runner(suite, delay) {
	  var self = this;
	  this._globals = [];
	  this._abort = false;
	  this._delay = delay;
	  this.suite = suite;
	  this.started = false;
	  this.total = suite.total();
	  this.failures = 0;
	  this.on('test end', function(test) {
	    self.checkGlobals(test);
	  });
	  this.on('hook end', function(hook) {
	    self.checkGlobals(hook);
	  });
	  this._defaultGrep = /.*/;
	  this.grep(this._defaultGrep);
	  this.globals(this.globalProps().concat(extraGlobals()));
	}

	/**
	 * Wrapper for setImmediate, process.nextTick, or browser polyfill.
	 *
	 * @param {Function} fn
	 * @api private
	 */
	Runner.immediately = global.setImmediate || process.nextTick;

	/**
	 * Inherit from `EventEmitter.prototype`.
	 */
	inherits(Runner, EventEmitter);

	/**
	 * Run tests with full titles matching `re`. Updates runner.total
	 * with number of tests matched.
	 *
	 * @param {RegExp} re
	 * @param {Boolean} invert
	 * @return {Runner} for chaining
	 * @api public
	 * @param {RegExp} re
	 * @param {boolean} invert
	 * @return {Runner} Runner instance.
	 */
	Runner.prototype.grep = function(re, invert) {
	  debug('grep %s', re);
	  this._grep = re;
	  this._invert = invert;
	  this.total = this.grepTotal(this.suite);
	  return this;
	};

	/**
	 * Returns the number of tests matching the grep search for the
	 * given suite.
	 *
	 * @param {Suite} suite
	 * @return {Number}
	 * @api public
	 * @param {Suite} suite
	 * @return {number}
	 */
	Runner.prototype.grepTotal = function(suite) {
	  var self = this;
	  var total = 0;

	  suite.eachTest(function(test) {
	    var match = self._grep.test(test.fullTitle());
	    if (self._invert) {
	      match = !match;
	    }
	    if (match) {
	      total++;
	    }
	  });

	  return total;
	};

	/**
	 * Return a list of global properties.
	 *
	 * @return {Array}
	 * @api private
	 */
	Runner.prototype.globalProps = function() {
	  var props = keys(global);

	  // non-enumerables
	  for (var i = 0; i < globals.length; ++i) {
	    if (~indexOf(props, globals[i])) {
	      continue;
	    }
	    props.push(globals[i]);
	  }

	  return props;
	};

	/**
	 * Allow the given `arr` of globals.
	 *
	 * @param {Array} arr
	 * @return {Runner} for chaining
	 * @api public
	 * @param {Array} arr
	 * @return {Runner} Runner instance.
	 */
	Runner.prototype.globals = function(arr) {
	  if (!arguments.length) {
	    return this._globals;
	  }
	  debug('globals %j', arr);
	  this._globals = this._globals.concat(arr);
	  return this;
	};

	/**
	 * Check for global variable leaks.
	 *
	 * @api private
	 */
	Runner.prototype.checkGlobals = function(test) {
	  if (this.ignoreLeaks) {
	    return;
	  }
	  var ok = this._globals;

	  var globals = this.globalProps();
	  var leaks;

	  if (test) {
	    ok = ok.concat(test._allowedGlobals || []);
	  }

	  if (this.prevGlobalsLength === globals.length) {
	    return;
	  }
	  this.prevGlobalsLength = globals.length;

	  leaks = filterLeaks(ok, globals);
	  this._globals = this._globals.concat(leaks);

	  if (leaks.length > 1) {
	    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));
	  } else if (leaks.length) {
	    this.fail(test, new Error('global leak detected: ' + leaks[0]));
	  }
	};

	/**
	 * Fail the given `test`.
	 *
	 * @api private
	 * @param {Test} test
	 * @param {Error} err
	 */
	Runner.prototype.fail = function(test, err) {
	  ++this.failures;
	  test.state = 'failed';

	  if (!(err instanceof Error || err && typeof err.message === 'string')) {
	    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');
	  }

	  err.stack = (this.fullStackTrace || !err.stack)
	    ? err.stack
	    : stackFilter(err.stack);

	  this.emit('fail', test, err);
	};

	/**
	 * Fail the given `hook` with `err`.
	 *
	 * Hook failures work in the following pattern:
	 * - If bail, then exit
	 * - Failed `before` hook skips all tests in a suite and subsuites,
	 *   but jumps to corresponding `after` hook
	 * - Failed `before each` hook skips remaining tests in a
	 *   suite and jumps to corresponding `after each` hook,
	 *   which is run only once
	 * - Failed `after` hook does not alter
	 *   execution order
	 * - Failed `after each` hook skips remaining tests in a
	 *   suite and subsuites, but executes other `after each`
	 *   hooks
	 *
	 * @api private
	 * @param {Hook} hook
	 * @param {Error} err
	 */
	Runner.prototype.failHook = function(hook, err) {
	  if (hook.ctx && hook.ctx.currentTest) {
	    hook.originalTitle = hook.originalTitle || hook.title;
	    hook.title = hook.originalTitle + ' for "' + hook.ctx.currentTest.title + '"';
	  }

	  this.fail(hook, err);
	  if (this.suite.bail()) {
	    this.emit('end');
	  }
	};

	/**
	 * Run hook `name` callbacks and then invoke `fn()`.
	 *
	 * @api private
	 * @param {string} name
	 * @param {Function} fn
	 */

	Runner.prototype.hook = function(name, fn) {
	  var suite = this.suite;
	  var hooks = suite['_' + name];
	  var self = this;

	  function next(i) {
	    var hook = hooks[i];
	    if (!hook) {
	      return fn();
	    }
	    self.currentRunnable = hook;

	    hook.ctx.currentTest = self.test;

	    self.emit('hook', hook);

	    if (!hook.listeners('error').length) {
	      hook.on('error', function(err) {
	        self.failHook(hook, err);
	      });
	    }

	    hook.run(function(err) {
	      var testError = hook.error();
	      if (testError) {
	        self.fail(self.test, testError);
	      }
	      if (err) {
	        if (err instanceof Pending) {
	          suite.pending = true;
	        } else {
	          self.failHook(hook, err);

	          // stop executing hooks, notify callee of hook err
	          return fn(err);
	        }
	      }
	      self.emit('hook end', hook);
	      delete hook.ctx.currentTest;
	      next(++i);
	    });
	  }

	  Runner.immediately(function() {
	    next(0);
	  });
	};

	/**
	 * Run hook `name` for the given array of `suites`
	 * in order, and callback `fn(err, errSuite)`.
	 *
	 * @api private
	 * @param {string} name
	 * @param {Array} suites
	 * @param {Function} fn
	 */
	Runner.prototype.hooks = function(name, suites, fn) {
	  var self = this;
	  var orig = this.suite;

	  function next(suite) {
	    self.suite = suite;

	    if (!suite) {
	      self.suite = orig;
	      return fn();
	    }

	    self.hook(name, function(err) {
	      if (err) {
	        var errSuite = self.suite;
	        self.suite = orig;
	        return fn(err, errSuite);
	      }

	      next(suites.pop());
	    });
	  }

	  next(suites.pop());
	};

	/**
	 * Run hooks from the top level down.
	 *
	 * @param {String} name
	 * @param {Function} fn
	 * @api private
	 */
	Runner.prototype.hookUp = function(name, fn) {
	  var suites = [this.suite].concat(this.parents()).reverse();
	  this.hooks(name, suites, fn);
	};

	/**
	 * Run hooks from the bottom up.
	 *
	 * @param {String} name
	 * @param {Function} fn
	 * @api private
	 */
	Runner.prototype.hookDown = function(name, fn) {
	  var suites = [this.suite].concat(this.parents());
	  this.hooks(name, suites, fn);
	};

	/**
	 * Return an array of parent Suites from
	 * closest to furthest.
	 *
	 * @return {Array}
	 * @api private
	 */
	Runner.prototype.parents = function() {
	  var suite = this.suite;
	  var suites = [];
	  while (suite.parent) {
	    suite = suite.parent;
	    suites.push(suite);
	  }
	  return suites;
	};

	/**
	 * Run the current test and callback `fn(err)`.
	 *
	 * @param {Function} fn
	 * @api private
	 */
	Runner.prototype.runTest = function(fn) {
	  var self = this;
	  var test = this.test;

	  if (this.asyncOnly) {
	    test.asyncOnly = true;
	  }

	  if (this.allowUncaught) {
	    test.allowUncaught = true;
	    return test.run(fn);
	  }
	  try {
	    test.on('error', function(err) {
	      self.fail(test, err);
	    });
	    test.run(fn);
	  } catch (err) {
	    fn(err);
	  }
	};

	/**
	 * Run tests in the given `suite` and invoke the callback `fn()` when complete.
	 *
	 * @api private
	 * @param {Suite} suite
	 * @param {Function} fn
	 */
	Runner.prototype.runTests = function(suite, fn) {
	  var self = this;
	  var tests = suite.tests.slice();
	  var test;

	  function hookErr(_, errSuite, after) {
	    // before/after Each hook for errSuite failed:
	    var orig = self.suite;

	    // for failed 'after each' hook start from errSuite parent,
	    // otherwise start from errSuite itself
	    self.suite = after ? errSuite.parent : errSuite;

	    if (self.suite) {
	      // call hookUp afterEach
	      self.hookUp('afterEach', function(err2, errSuite2) {
	        self.suite = orig;
	        // some hooks may fail even now
	        if (err2) {
	          return hookErr(err2, errSuite2, true);
	        }
	        // report error suite
	        fn(errSuite);
	      });
	    } else {
	      // there is no need calling other 'after each' hooks
	      self.suite = orig;
	      fn(errSuite);
	    }
	  }

	  function next(err, errSuite) {
	    // if we bail after first err
	    if (self.failures && suite._bail) {
	      return fn();
	    }

	    if (self._abort) {
	      return fn();
	    }

	    if (err) {
	      return hookErr(err, errSuite, true);
	    }

	    // next test
	    test = tests.shift();

	    // all done
	    if (!test) {
	      return fn();
	    }

	    // grep
	    var match = self._grep.test(test.fullTitle());
	    if (self._invert) {
	      match = !match;
	    }
	    if (!match) {
	      // Run immediately only if we have defined a grep. When we
	      // define a grep  It can cause maximum callstack error if
	      // the grep is doing a large recursive loop by neglecting
	      // all tests. The run immediately function also comes with
	      // a performance cost. So we don't want to run immediately
	      // if we run the whole test suite, because running the whole
	      // test suite don't do any immediate recursive loops. Thus,
	      // allowing a JS runtime to breathe.
	      if (self._grep !== self._defaultGrep) {
	        Runner.immediately(next);
	      } else {
	        next();
	      }
	      return;
	    }

	    function parentPending(suite) {
	      return suite.pending || (suite.parent && parentPending(suite.parent));
	    }

	    // pending
	    if (test.pending || parentPending(test.parent)) {
	      self.emit('pending', test);
	      self.emit('test end', test);
	      return next();
	    }

	    // execute test and hook(s)
	    self.emit('test', self.test = test);
	    self.hookDown('beforeEach', function(err, errSuite) {
	      if (suite.pending) {
	        self.emit('pending', test);
	        self.emit('test end', test);
	        return next();
	      }
	      if (err) {
	        return hookErr(err, errSuite, false);
	      }
	      self.currentRunnable = self.test;
	      self.runTest(function(err) {
	        test = self.test;
	        if (err) {
	          var retry = test.currentRetry();
	          if (err instanceof Pending) {
	            test.pending = true;
	            self.emit('pending', test);
	          } else if (retry < test.retries()) {
	            var clonedTest = test.clone();
	            clonedTest.currentRetry(retry + 1);
	            tests.unshift(clonedTest);

	            // Early return + hook trigger so that it doesn't
	            // increment the count wrong
	            return self.hookUp('afterEach', next);
	          } else {
	            self.fail(test, err);
	          }
	          self.emit('test end', test);

	          if (err instanceof Pending) {
	            return next();
	          }

	          return self.hookUp('afterEach', next);
	        }

	        test.state = 'passed';
	        self.emit('pass', test);
	        self.emit('test end', test);
	        self.hookUp('afterEach', next);
	      });
	    });
	  }

	  this.next = next;
	  this.hookErr = hookErr;
	  next();
	};

	/**
	 * Run the given `suite` and invoke the callback `fn()` when complete.
	 *
	 * @api private
	 * @param {Suite} suite
	 * @param {Function} fn
	 */
	Runner.prototype.runSuite = function(suite, fn) {
	  var i = 0;
	  var self = this;
	  var total = this.grepTotal(suite);
	  var afterAllHookCalled = false;

	  debug('run suite %s', suite.fullTitle());

	  if (!total || (self.failures && suite._bail)) {
	    return fn();
	  }

	  this.emit('suite', this.suite = suite);

	  function next(errSuite) {
	    if (errSuite) {
	      // current suite failed on a hook from errSuite
	      if (errSuite === suite) {
	        // if errSuite is current suite
	        // continue to the next sibling suite
	        return done();
	      }
	      // errSuite is among the parents of current suite
	      // stop execution of errSuite and all sub-suites
	      return done(errSuite);
	    }

	    if (self._abort) {
	      return done();
	    }

	    var curr = suite.suites[i++];
	    if (!curr) {
	      return done();
	    }

	    // Avoid grep neglecting large number of tests causing a
	    // huge recursive loop and thus a maximum call stack error.
	    // See comment in `this.runTests()` for more information.
	    if (self._grep !== self._defaultGrep) {
	      Runner.immediately(function() {
	        self.runSuite(curr, next);
	      });
	    } else {
	      self.runSuite(curr, next);
	    }
	  }

	  function done(errSuite) {
	    self.suite = suite;
	    self.nextSuite = next;

	    if (afterAllHookCalled) {
	      fn(errSuite);
	    } else {
	      // mark that the afterAll block has been called once
	      // and so can be skipped if there is an error in it.
	      afterAllHookCalled = true;

	      // remove reference to test
	      delete self.test;

	      self.hook('afterAll', function() {
	        self.emit('suite end', suite);
	        fn(errSuite);
	      });
	    }
	  }

	  this.nextSuite = next;

	  this.hook('beforeAll', function(err) {
	    if (err) {
	      return done();
	    }
	    self.runTests(suite, next);
	  });
	};

	/**
	 * Handle uncaught exceptions.
	 *
	 * @param {Error} err
	 * @api private
	 */
	Runner.prototype.uncaught = function(err) {
	  if (err) {
	    debug('uncaught exception %s', err !== function() {
	      return this;
	    }.call(err) ? err : (err.message || err));
	  } else {
	    debug('uncaught undefined exception');
	    err = undefinedError();
	  }
	  err.uncaught = true;

	  var runnable = this.currentRunnable;

	  if (!runnable) {
	    runnable = new Runnable('Uncaught error outside test suite');
	    runnable.parent = this.suite;

	    if (this.started) {
	      this.fail(runnable, err);
	    } else {
	      // Can't recover from this failure
	      this.emit('start');
	      this.fail(runnable, err);
	      this.emit('end');
	    }

	    return;
	  }

	  runnable.clearTimeout();

	  // Ignore errors if complete
	  if (runnable.state) {
	    return;
	  }
	  this.fail(runnable, err);

	  // recover from test
	  if (runnable.type === 'test') {
	    this.emit('test end', runnable);
	    this.hookUp('afterEach', this.next);
	    return;
	  }

	 // recover from hooks
	  if (runnable.type === 'hook') {
	    var errSuite = this.suite;
	    // if hook failure is in afterEach block
	    if (runnable.fullTitle().indexOf('after each') > -1) {
	      return this.hookErr(err, errSuite, true);
	    }
	    // if hook failure is in beforeEach block
	    if (runnable.fullTitle().indexOf('before each') > -1) {
	      return this.hookErr(err, errSuite, false);
	    }
	    // if hook failure is in after or before blocks
	    return this.nextSuite(errSuite);
	  }

	  // bail
	  this.emit('end');
	};

	/**
	 * Cleans up the references to all the deferred functions
	 * (before/after/beforeEach/afterEach) and tests of a Suite.
	 * These must be deleted otherwise a memory leak can happen,
	 * as those functions may reference variables from closures,
	 * thus those variables can never be garbage collected as long
	 * as the deferred functions exist.
	 *
	 * @param {Suite} suite
	 */
	function cleanSuiteReferences(suite) {
	  function cleanArrReferences(arr) {
	    for (var i = 0; i < arr.length; i++) {
	      delete arr[i].fn;
	    }
	  }

	  if (isArray(suite._beforeAll)) {
	    cleanArrReferences(suite._beforeAll);
	  }

	  if (isArray(suite._beforeEach)) {
	    cleanArrReferences(suite._beforeEach);
	  }

	  if (isArray(suite._afterAll)) {
	    cleanArrReferences(suite._afterAll);
	  }

	  if (isArray(suite._afterEach)) {
	    cleanArrReferences(suite._afterEach);
	  }

	  for (var i = 0; i < suite.tests.length; i++) {
	    delete suite.tests[i].fn;
	  }
	}

	/**
	 * Run the root suite and invoke `fn(failures)`
	 * on completion.
	 *
	 * @param {Function} fn
	 * @return {Runner} for chaining
	 * @api public
	 * @param {Function} fn
	 * @return {Runner} Runner instance.
	 */
	Runner.prototype.run = function(fn) {
	  var self = this;
	  var rootSuite = this.suite;

	  fn = fn || function() {};

	  function uncaught(err) {
	    self.uncaught(err);
	  }

	  function start() {
	    self.started = true;
	    self.emit('start');
	    self.runSuite(rootSuite, function() {
	      debug('finished running');
	      self.emit('end');
	    });
	  }

	  debug('start');

	  // references cleanup to avoid memory leaks
	  this.on('suite end', cleanSuiteReferences);

	  // callback
	  this.on('end', function() {
	    debug('end');
	    process.removeListener('uncaughtException', uncaught);
	    fn(self.failures);
	  });

	  // uncaught exception
	  process.on('uncaughtException', uncaught);

	  if (this._delay) {
	    // for reporters, I guess.
	    // might be nice to debounce some dots while we wait.
	    this.emit('waiting', rootSuite);
	    rootSuite.once('run', start);
	  } else {
	    start();
	  }

	  return this;
	};

	/**
	 * Cleanly abort execution.
	 *
	 * @api public
	 * @return {Runner} Runner instance.
	 */
	Runner.prototype.abort = function() {
	  debug('aborting');
	  this._abort = true;

	  return this;
	};

	/**
	 * Filter leaks with the given globals flagged as `ok`.
	 *
	 * @api private
	 * @param {Array} ok
	 * @param {Array} globals
	 * @return {Array}
	 */
	function filterLeaks(ok, globals) {
	  return filter(globals, function(key) {
	    // Firefox and Chrome exposes iframes as index inside the window object
	    if (/^d+/.test(key)) {
	      return false;
	    }

	    // in firefox
	    // if runner runs in an iframe, this iframe's window.getInterface method not init at first
	    // it is assigned in some seconds
	    if (global.navigator && (/^getInterface/).test(key)) {
	      return false;
	    }

	    // an iframe could be approached by window[iframeIndex]
	    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak
	    if (global.navigator && (/^\d+/).test(key)) {
	      return false;
	    }

	    // Opera and IE expose global variables for HTML element IDs (issue #243)
	    if (/^mocha-/.test(key)) {
	      return false;
	    }

	    var matched = filter(ok, function(ok) {
	      if (~ok.indexOf('*')) {
	        return key.indexOf(ok.split('*')[0]) === 0;
	      }
	      return key === ok;
	    });
	    return !matched.length && (!global.navigator || key !== 'onerror');
	  });
	}

	/**
	 * Array of globals dependent on the environment.
	 *
	 * @return {Array}
	 * @api private
	 */
	function extraGlobals() {
	  if (typeof process === 'object' && typeof process.version === 'string') {
	    var parts = process.version.split('.');
	    var nodeVersion = utils.reduce(parts, function(a, v) {
	      return a << 8 | v;
	    });

	    // 'errno' was renamed to process._errno in v0.9.11.

	    if (nodeVersion < 0x00090B) {
	      return ['errno'];
	    }
	  }

	  return [];
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(26)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./browser/debug": 41,
		"./browser/debug.js": 41,
		"./browser/events": 111,
		"./browser/events.js": 111,
		"./browser/progress": 67,
		"./browser/progress.js": 67,
		"./browser/tty": 33,
		"./browser/tty.js": 33,
		"./context": 120,
		"./context.js": 120,
		"./hook": 112,
		"./hook.js": 112,
		"./interfaces/bdd": 109,
		"./interfaces/bdd.js": 109,
		"./interfaces/common": 116,
		"./interfaces/common.js": 116,
		"./interfaces/exports": 119,
		"./interfaces/exports.js": 119,
		"./interfaces/index": 108,
		"./interfaces/index.js": 108,
		"./interfaces/qunit": 118,
		"./interfaces/qunit.js": 118,
		"./interfaces/tdd": 117,
		"./interfaces/tdd.js": 117,
		"./mocha": 27,
		"./mocha.js": 27,
		"./ms": 35,
		"./ms.js": 35,
		"./pending": 114,
		"./pending.js": 114,
		"./reporters/base": 32,
		"./reporters/base.js": 32,
		"./reporters/doc": 63,
		"./reporters/doc.js": 63,
		"./reporters/dot": 62,
		"./reporters/dot.js": 62,
		"./reporters/html": 66,
		"./reporters/html-cov": 78,
		"./reporters/html-cov.js": 78,
		"./reporters/html.js": 66,
		"./reporters/index": 31,
		"./reporters/index.js": 31,
		"./reporters/json": 65,
		"./reporters/json-cov": 77,
		"./reporters/json-cov.js": 77,
		"./reporters/json-stream": 107,
		"./reporters/json-stream.js": 107,
		"./reporters/json.js": 65,
		"./reporters/landing": 76,
		"./reporters/landing.js": 76,
		"./reporters/list": 68,
		"./reporters/list.js": 68,
		"./reporters/markdown": 74,
		"./reporters/markdown.js": 74,
		"./reporters/min": 69,
		"./reporters/min.js": 69,
		"./reporters/nyan": 71,
		"./reporters/nyan.js": 71,
		"./reporters/progress": 75,
		"./reporters/progress.js": 75,
		"./reporters/spec": 70,
		"./reporters/spec.js": 70,
		"./reporters/tap": 64,
		"./reporters/tap.js": 64,
		"./reporters/xunit": 72,
		"./reporters/xunit.js": 72,
		"./runnable": 113,
		"./runnable.js": 113,
		"./runner": 121,
		"./runner.js": 121,
		"./suite": 110,
		"./suite.js": 110,
		"./test": 115,
		"./test.js": 115,
		"./utils": 36,
		"./utils.js": 36
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 122;


/***/ },
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)

	/**
	 * Module dependencies.
	 */

	var exec = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"child_process\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).exec
	  , fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , path = __webpack_require__(30)
	  , exists = fs.existsSync || path.existsSync
	  , os = __webpack_require__(129)
	  , quote = JSON.stringify
	  , cmd;

	function which(name) {
	  var paths = process.env.PATH.split(':');
	  var loc;
	  
	  for (var i = 0, len = paths.length; i < len; ++i) {
	    loc = path.join(paths[i], name);
	    if (exists(loc)) return loc;
	  }
	}

	switch(os.type()) {
	  case 'Darwin':
	    if (which('terminal-notifier')) {
	      cmd = {
	          type: "Darwin-NotificationCenter"
	        , pkg: "terminal-notifier"
	        , msg: '-message'
	        , title: '-title'
	        , subtitle: '-subtitle'
	        , priority: {
	              cmd: '-execute'
	            , range: []
	          }
	      };
	    } else {
	      cmd = {
	          type: "Darwin-Growl"
	        , pkg: "growlnotify"
	        , msg: '-m'
	        , sticky: '--sticky'
	        , priority: {
	              cmd: '--priority'
	            , range: [
	                -2
	              , -1
	              , 0
	              , 1
	              , 2
	              , "Very Low"
	              , "Moderate"
	              , "Normal"
	              , "High"
	              , "Emergency"
	            ]
	          }
	      };
	    }
	    break;
	  case 'Linux':
	    cmd = {
	        type: "Linux"
	      , pkg: "notify-send"
	      , msg: ''
	      , sticky: '-t 0'
	      , icon: '-i'
	      , priority: {
	          cmd: '-u'
	        , range: [
	            "low"
	          , "normal"
	          , "critical"
	        ]
	      }
	    };
	    break;
	  case 'Windows_NT':
	    cmd = {
	        type: "Windows"
	      , pkg: "growlnotify"
	      , msg: ''
	      , sticky: '/s:true'
	      , title: '/t:'
	      , icon: '/i:'
	      , priority: {
	            cmd: '/p:'
	          , range: [
	              -2
	            , -1
	            , 0
	            , 1
	            , 2
	          ]
	        }
	    };
	    break;
	}

	/**
	 * Expose `growl`.
	 */

	exports = module.exports = growl;

	/**
	 * Node-growl version.
	 */

	exports.version = '1.4.1'

	/**
	 * Send growl notification _msg_ with _options_.
	 *
	 * Options:
	 *
	 *  - title   Notification title
	 *  - sticky  Make the notification stick (defaults to false)
	 *  - priority  Specify an int or named key (default is 0)
	 *  - name    Application name (defaults to growlnotify)
	 *  - image
	 *    - path to an icon sets --iconpath
	 *    - path to an image sets --image
	 *    - capitalized word sets --appIcon
	 *    - filename uses extname as --icon
	 *    - otherwise treated as --icon
	 *
	 * Examples:
	 *
	 *   growl('New email')
	 *   growl('5 new emails', { title: 'Thunderbird' })
	 *   growl('Email sent', function(){
	 *     // ... notification sent
	 *   })
	 *
	 * @param {string} msg
	 * @param {object} options
	 * @param {function} fn
	 * @api public
	 */

	function growl(msg, options, fn) {
	  var image
	    , args
	    , options = options || {}
	    , fn = fn || function(){};

	  // noop
	  if (!cmd) return fn(new Error('growl not supported on this platform'));
	  args = [cmd.pkg];

	  // image
	  if (image = options.image) {
	    switch(cmd.type) {
	      case 'Darwin-Growl':
	        var flag, ext = path.extname(image).substr(1)
	        flag = flag || ext == 'icns' && 'iconpath'
	        flag = flag || /^[A-Z]/.test(image) && 'appIcon'
	        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'
	        flag = flag || ext && (image = ext) && 'icon'
	        flag = flag || 'icon'
	        args.push('--' + flag, quote(image))
	        break;
	      case 'Linux':
	        args.push(cmd.icon, quote(image));
	        // libnotify defaults to sticky, set a hint for transient notifications
	        if (!options.sticky) args.push('--hint=int:transient:1');
	        break;
	      case 'Windows':
	        args.push(cmd.icon + quote(image));
	        break;
	    }
	  }

	  // sticky
	  if (options.sticky) args.push(cmd.sticky);

	  // priority
	  if (options.priority) {
	    var priority = options.priority + '';
	    var checkindexOf = cmd.priority.range.indexOf(priority);
	    if (~cmd.priority.range.indexOf(priority)) {
	      args.push(cmd.priority, options.priority);
	    }
	  }

	  // name
	  if (options.name && cmd.type === "Darwin-Growl") {
	    args.push('--name', options.name);
	  }

	  switch(cmd.type) {
	    case 'Darwin-Growl':
	      args.push(cmd.msg);
	      args.push(quote(msg));
	      if (options.title) args.push(quote(options.title));
	      break;
	    case 'Darwin-NotificationCenter':
	      args.push(cmd.msg);
	      args.push(quote(msg));
	      if (options.title) {
	        args.push(cmd.title);
	        args.push(quote(options.title));
	      }
	      if (options.subtitle) {
	        args.push(cmd.subtitle);
	        args.push(quote(options.subtitle));
	      }
	      break;
	    case 'Darwin-Growl':
	      args.push(cmd.msg);
	      args.push(quote(msg));
	      if (options.title) args.push(quote(options.title));
	      break;
	    case 'Linux':
	      if (options.title) {
	        args.push(quote(options.title));
	        args.push(cmd.msg);
	        args.push(quote(msg));
	      } else {
	        args.push(quote(msg));
	      }
	      break;
	    case 'Windows':
	      args.push(quote(msg));
	      if (options.title) args.push(cmd.title + quote(options.title));
	      break;
	  }

	  // execute
	  exec(args.join(' '), fn);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 129 */
/***/ function(module, exports) {

	exports.endianness = function () { return 'LE' };

	exports.hostname = function () {
	    if (typeof location !== 'undefined') {
	        return location.hostname
	    }
	    else return '';
	};

	exports.loadavg = function () { return [] };

	exports.uptime = function () { return 0 };

	exports.freemem = function () {
	    return Number.MAX_VALUE;
	};

	exports.totalmem = function () {
	    return Number.MAX_VALUE;
	};

	exports.cpus = function () { return [] };

	exports.type = function () { return 'Browser' };

	exports.release = function () {
	    if (typeof navigator !== 'undefined') {
	        return navigator.appVersion;
	    }
	    return '';
	};

	exports.networkInterfaces
	= exports.getNetworkInterfaces
	= function () { return {} };

	exports.arch = function () { return 'javascript' };

	exports.platform = function () { return 'browser' };

	exports.tmpdir = exports.tmpDir = function () {
	    return '/tmp';
	};

	exports.EOL = '\n';


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(131);

	var _react2 = _interopRequireDefault(_react);

	var _expect = __webpack_require__(2);

	var _expect2 = _interopRequireDefault(_expect);

	var _collapseWhiteSpace = __webpack_require__(287);

	var _collapseWhiteSpace2 = _interopRequireDefault(_collapseWhiteSpace);

	var _reactElementToJsxString = __webpack_require__(288);

	var _reactElementToJsxString2 = _interopRequireDefault(_reactElementToJsxString);

	var api = {
	  toEqualJSX: function toEqualJSX(ReactElement) {
	    return (0, _expect2['default'])((0, _reactElementToJsxString2['default'])(this.actual)).toEqual((0, _reactElementToJsxString2['default'])(ReactElement));
	  },
	  toNotEqualJSX: function toNotEqualJSX(ReactElement) {
	    return (0, _expect2['default'])((0, _reactElementToJsxString2['default'])(this.actual)).toNotEqual((0, _reactElementToJsxString2['default'])(ReactElement));
	  },
	  toIncludeJSX: function toIncludeJSX(ReactElement) {
	    return (0, _expect2['default'])((0, _collapseWhiteSpace2['default'])((0, _reactElementToJsxString2['default'])(this.actual))).toInclude((0, _collapseWhiteSpace2['default'])((0, _reactElementToJsxString2['default'])(ReactElement)));
	  },
	  toNotIncludeJSX: function toNotIncludeJSX(ReactElement) {
	    return (0, _expect2['default'])((0, _collapseWhiteSpace2['default'])((0, _reactElementToJsxString2['default'])(this.actual))).toExclude((0, _collapseWhiteSpace2['default'])((0, _reactElementToJsxString2['default'])(ReactElement)));
	  }
	};

	exports['default'] = api;
	module.exports = exports['default'];


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(132);


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */

	'use strict';

	var ReactDOM = __webpack_require__(133);
	var ReactDOMServer = __webpack_require__(277);
	var ReactIsomorphic = __webpack_require__(281);

	var assign = __webpack_require__(168);
	var deprecated = __webpack_require__(286);

	// `version` will be added here by ReactIsomorphic.
	var React = {};

	assign(React, ReactIsomorphic);

	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),

	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});

	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;

	module.exports = React;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */

	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

	'use strict';

	var ReactCurrentOwner = __webpack_require__(134);
	var ReactDOMTextComponent = __webpack_require__(135);
	var ReactDefaultInjection = __webpack_require__(200);
	var ReactInstanceHandles = __webpack_require__(174);
	var ReactMount = __webpack_require__(157);
	var ReactPerf = __webpack_require__(147);
	var ReactReconciler = __webpack_require__(179);
	var ReactUpdates = __webpack_require__(183);
	var ReactVersion = __webpack_require__(275);

	var findDOMNode = __webpack_require__(220);
	var renderSubtreeIntoContainer = __webpack_require__(276);
	var warning = __webpack_require__(154);

	ReactDefaultInjection.inject();

	var render = ReactPerf.measure('React', 'render', ReactMount.render);

	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,

	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};

	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}

	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(138);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }

	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

	    // shams
	    Object.create, Object.freeze];

	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}

	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */

	'use strict';

	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {

	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null

	};

	module.exports = ReactCurrentOwner;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(136);
	var DOMPropertyOperations = __webpack_require__(151);
	var ReactComponentBrowserEnvironment = __webpack_require__(155);
	var ReactMount = __webpack_require__(157);

	var assign = __webpack_require__(168);
	var escapeTextContentForBrowser = __webpack_require__(150);
	var setTextContent = __webpack_require__(149);
	var validateDOMNesting = __webpack_require__(199);

	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (props) {
	  // This constructor and its argument is currently used by mocks.
	};

	assign(ReactDOMTextComponent.prototype, {

	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function (text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;

	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },

	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }

	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);

	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }

	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },

	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },

	  unmountComponent: function () {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }

	});

	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */

	'use strict';

	var Danger = __webpack_require__(137);
	var ReactMultiChildUpdateTypes = __webpack_require__(145);
	var ReactPerf = __webpack_require__(147);

	var setInnerHTML = __webpack_require__(148);
	var setTextContent = __webpack_require__(149);
	var invariant = __webpack_require__(142);

	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.

	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

	  parentNode.insertBefore(childNode, beforeChild);
	}

	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {

	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

	  updateTextContent: setTextContent,

	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function (updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;

	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;

	        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;

	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }

	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }

	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }

	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }

	};

	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});

	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var createNodesFromMarkup = __webpack_require__(139);
	var emptyFunction = __webpack_require__(144);
	var getMarkupWrap = __webpack_require__(143);
	var invariant = __webpack_require__(142);

	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';

	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}

	var Danger = {

	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function (markupList) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];

	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];

	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }

	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );

	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);

	          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

	          resultList[resultIndex] = renderNode;

	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (process.env.NODE_ENV !== 'production') {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }

	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

	    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

	    return resultList;
	  },

	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;

	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }

	};

	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */

	'use strict';

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	module.exports = ExecutionEnvironment;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */

	/*eslint-disable fb-www/unsafe-html*/

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var createArrayFromMixed = __webpack_require__(140);
	var getMarkupWrap = __webpack_require__(143);
	var invariant = __webpack_require__(142);

	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;

	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}

	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);

	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];

	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }

	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }

	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}

	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */

	'use strict';

	var toArray = __webpack_require__(141);

	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return(
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}

	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}

	module.exports = createArrayFromMixed;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;

	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }

	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}

	module.exports = toArray;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */

	/*eslint-disable fb-www/unsafe-html */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var invariant = __webpack_require__(142);

	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */

	var shouldWrap = {};

	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],

	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],

	  'optgroup': selectWrap,
	  'option': selectWrap,

	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,

	  'td': trWrap,
	  'th': trWrap
	};

	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});

	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}

	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 144 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */

	"use strict";

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */

	'use strict';

	var keyMirror = __webpack_require__(146);

	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});

	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function (obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};

	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,

	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,

	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function (object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },

	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function (objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function () {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },

	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function (measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};

	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}

	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */

	/* globals MSApp */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function (node, html) {
	  node.innerHTML = html;
	};

	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function (node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}

	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }

	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;

	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}

	module.exports = setInnerHTML;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);
	var escapeTextContentForBrowser = __webpack_require__(150);
	var setInnerHTML = __webpack_require__(148);

	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  node.textContent = text;
	};

	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}

	module.exports = setTextContent;

/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */

	'use strict';

	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};

	var ESCAPE_REGEX = /[&><"']/g;

	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}

	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}

	module.exports = escapeTextContentForBrowser;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */

	'use strict';

	var DOMProperty = __webpack_require__(152);
	var ReactPerf = __webpack_require__(147);

	var quoteAttributeValueForBrowser = __webpack_require__(153);
	var warning = __webpack_require__(154);

	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};

	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}

	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}

	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};

	  var warnUnknownProperty = function (name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }

	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();

	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}

	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {

	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },

	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },

	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },

	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },

	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  },

	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },

	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  }

	};

	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});

	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}

	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }

	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];

	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,

	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };

	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;

	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }

	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }

	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }

	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }

	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }

	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};

	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {

	  ID_ATTRIBUTE_NAME: 'data-reactid',

	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},

	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,

	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],

	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },

	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function (nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },

	  injection: DOMPropertyInjection
	};

	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */

	'use strict';

	var escapeTextContentForBrowser = __webpack_require__(150);

	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}

	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */

	'use strict';

	var emptyFunction = __webpack_require__(144);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }

	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}

	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */

	'use strict';

	var ReactDOMIDOperations = __webpack_require__(156);
	var ReactMount = __webpack_require__(157);

	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {

	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function (rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }

	};

	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(136);
	var DOMPropertyOperations = __webpack_require__(151);
	var ReactMount = __webpack_require__(157);
	var ReactPerf = __webpack_require__(147);

	var invariant = __webpack_require__(142);

	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};

	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {

	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function (id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },

	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },

	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};

	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});

	module.exports = ReactDOMIDOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */

	'use strict';

	var DOMProperty = __webpack_require__(152);
	var ReactBrowserEventEmitter = __webpack_require__(158);
	var ReactCurrentOwner = __webpack_require__(134);
	var ReactDOMFeatureFlags = __webpack_require__(170);
	var ReactElement = __webpack_require__(171);
	var ReactEmptyComponentRegistry = __webpack_require__(173);
	var ReactInstanceHandles = __webpack_require__(174);
	var ReactInstanceMap = __webpack_require__(176);
	var ReactMarkupChecksum = __webpack_require__(177);
	var ReactPerf = __webpack_require__(147);
	var ReactReconciler = __webpack_require__(179);
	var ReactUpdateQueue = __webpack_require__(182);
	var ReactUpdates = __webpack_require__(183);

	var assign = __webpack_require__(168);
	var emptyObject = __webpack_require__(187);
	var containsNode = __webpack_require__(188);
	var instantiateReactComponent = __webpack_require__(191);
	var invariant = __webpack_require__(142);
	var setInnerHTML = __webpack_require__(148);
	var shouldUpdateReactComponent = __webpack_require__(196);
	var validateDOMNesting = __webpack_require__(199);
	var warning = __webpack_require__(154);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};

	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);

	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};

	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};

	if (process.env.NODE_ENV !== 'production') {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}

	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];

	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}

	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}

	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}

	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }

	  return id;
	}

	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}

	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}

	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}

	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}

	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}

	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}

	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}

	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}

	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}

	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);

	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }

	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}

	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}

	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);

	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);

	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}

	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function () {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};

	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {

	  TopLevelWrapper: TopLevelWrapper,

	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,

	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },

	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });

	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }

	    return prevComponent;
	  },

	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function (nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },

	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);

	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.

	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }

	    return componentInstance;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },

	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

	    var prevComponent = instancesByReactRootID[getReactRootID(container)];

	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }

	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;

	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }

	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },

	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function (container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },

	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);

	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);

	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }

	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (process.env.NODE_ENV !== 'production') {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },

	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function (id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];

	    if (process.env.NODE_ENV !== 'production') {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }

	    return container;
	  },

	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function (id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },

	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function (node) {
	    return findFirstReactDOMImpl(node);
	  },

	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function (ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;

	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }

	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;

	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;

	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.

	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }

	        child = child.nextSibling;
	      }

	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;

	        return targetChild;
	      }
	    }

	    firstChildren.length = 0;

	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },

	  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }

	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }

	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;

	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },

	  ownerDocumentContextKey: ownerDocumentContextKey,

	  /**
	   * React ID utilities.
	   */

	  getReactRootID: getReactRootID,

	  getID: getID,

	  setID: setID,

	  getNode: getNode,

	  getNodeFromInstance: getNodeFromInstance,

	  isValid: isValid,

	  purgeID: purgeID
	};

	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});

	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventPluginHub = __webpack_require__(160);
	var EventPluginRegistry = __webpack_require__(161);
	var ReactEventEmitterMixin = __webpack_require__(166);
	var ReactPerf = __webpack_require__(147);
	var ViewportMetrics = __webpack_require__(167);

	var assign = __webpack_require__(168);
	var isEventSupported = __webpack_require__(169);

	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */

	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;

	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};

	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}

	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,

	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },

	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },

	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },

	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {

	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }

	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }

	        isListening[dependency] = true;
	      }
	    }
	  },

	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },

	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },

	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },

	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

	  registrationNameModules: EventPluginHub.registrationNameModules,

	  putListener: EventPluginHub.putListener,

	  getListener: EventPluginHub.getListener,

	  deleteListener: EventPluginHub.deleteListener,

	  deleteAllListeners: EventPluginHub.deleteAllListeners

	});

	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});

	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */

	'use strict';

	var keyMirror = __webpack_require__(146);

	var PropagationPhases = keyMirror({ bubbled: null, captured: null });

	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});

	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};

	module.exports = EventConstants;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */

	'use strict';

	var EventPluginRegistry = __webpack_require__(161);
	var EventPluginUtils = __webpack_require__(162);
	var ReactErrorUtils = __webpack_require__(163);

	var accumulateInto = __webpack_require__(164);
	var forEachAccumulated = __webpack_require__(165);
	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};

	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;

	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);

	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};

	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;

	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}

	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {

	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {

	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,

	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function (InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	    },

	    getInstanceHandle: function () {
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },

	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

	  },

	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

	  registrationNameModules: EventPluginRegistry.registrationNameModules,

	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function (id, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;

	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;

	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },

	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },

	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }

	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },

	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function (id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }

	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }

	      delete listenerBank[registrationName][id];
	    }
	  },

	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },

	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },

	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },

	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },

	  __getListenerBank: function () {
	    return listenerBank;
	  }

	};

	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;

	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};

	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}

	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}

	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}

	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {

	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],

	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},

	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},

	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},

	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },

	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },

	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },

	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;

	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }

	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }

	};

	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var ReactErrorUtils = __webpack_require__(163);

	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	/**
	 * Injected dependencies:
	 */

	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function (InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};

	var topLevelTypes = EventConstants.topLevelTypes;

	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}

	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}

	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;

	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}

	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}

	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}

	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}

	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}

	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,

	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,

	  getNode: function (id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function (node) {
	    return injection.Mount.getID(node);
	  },

	  injection: injection
	};

	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */

	'use strict';

	var caughtError = null;

	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}

	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,

	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};

	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}

	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */

	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }

	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);

	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }

	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }

	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }

	  return [current, next];
	}

	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 165 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */

	'use strict';

	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	var forEachAccumulated = function (arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};

	module.exports = forEachAccumulated;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(160);

	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}

	var ReactEventEmitterMixin = {

	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};

	module.exports = ReactEventEmitterMixin;

/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */

	'use strict';

	var ViewportMetrics = {

	  currentScrollLeft: 0,

	  currentScrollTop: 0,

	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }

	};

	module.exports = ViewportMetrics;

/***/ },
/* 168 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

	'use strict';

	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }

	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;

	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }

	    var from = Object(nextSource);

	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.

	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }

	  return to;
	}

	module.exports = assign;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}

	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }

	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = (eventName in document);

	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }

	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }

	  return isSupported;
	}

	module.exports = isEventSupported;

/***/ },
/* 170 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */

	'use strict';

	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};

	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(134);

	var assign = __webpack_require__(168);
	var canDefineProperty = __webpack_require__(172);

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};

	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,

	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,

	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};

	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }

	  return element;
	};

	ReactElement.createElement = function (type, config, children) {
	  var propName;

	  // Reserved names are extracted
	  var props = {};

	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;

	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }

	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};

	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};

	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

	  return newElement;
	};

	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);

	  if (process.env.NODE_ENV !== 'production') {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }

	  return newElement;
	};

	ReactElement.cloneElement = function (element, config, children) {
	  var propName;

	  // Original props are copied
	  var props = assign({}, element.props);

	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;

	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;

	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};

	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};

	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */

	'use strict';

	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}

	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 173 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */

	'use strict';

	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	var nullComponentIDsRegistry = {};

	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}

	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}

	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}

	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};

	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */

	'use strict';

	var ReactRootIndex = __webpack_require__(175);

	var invariant = __webpack_require__(142);

	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;

	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;

	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}

	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}

	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}

	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}

	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}

	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}

	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}

	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}

	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {

	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function () {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },

	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function (rootID, name) {
	    return rootID + name;
	  },

	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function (id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },

	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },

	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },

	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },

	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function (targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },

	  getFirstCommonAncestorID: getFirstCommonAncestorID,

	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,

	  isAncestorIDOf: isAncestorIDOf,

	  SEPARATOR: SEPARATOR

	};

	module.exports = ReactInstanceHandles;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */

	'use strict';

	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function (_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};

	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};

	module.exports = ReactRootIndex;

/***/ },
/* 176 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */

	'use strict';

	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */

	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	var ReactInstanceMap = {

	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },

	  get: function (key) {
	    return key._reactInternalInstance;
	  },

	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },

	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }

	};

	module.exports = ReactInstanceMap;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */

	'use strict';

	var adler32 = __webpack_require__(178);

	var TAG_END = /\/?>/;

	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',

	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);

	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },

	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};

	module.exports = ReactMarkupChecksum;

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */

	'use strict';

	var MOD = 65521;

	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}

	module.exports = adler32;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */

	'use strict';

	var ReactRef = __webpack_require__(180);

	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}

	var ReactReconciler = {

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },

	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;

	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.

	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }

	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }

	    internalInstance.receiveComponent(nextElement, transaction, context);

	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },

	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }

	};

	module.exports = ReactReconciler;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */

	'use strict';

	var ReactOwner = __webpack_require__(181);

	var ReactRef = {};

	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}

	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}

	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};

	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.

	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.

	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;

	  return(
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};

	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};

	module.exports = ReactRef;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {

	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },

	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },

	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }

	};

	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(134);
	var ReactElement = __webpack_require__(171);
	var ReactInstanceMap = __webpack_require__(176);
	var ReactUpdates = __webpack_require__(183);

	var assign = __webpack_require__(168);
	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}

	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }

	  return internalInstance;
	}

	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }

	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },

	  enqueueCallbackInternal: function (internalInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingForceUpdate = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

	    if (!internalInstance) {
	      return;
	    }

	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },

	  enqueueSetPropsInternal: function (internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

	    enqueueUpdate(topLevelWrapper);
	  },

	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },

	  enqueueReplacePropsInternal: function (internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

	    enqueueUpdate(topLevelWrapper);
	  },

	  enqueueElementInternal: function (internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }

	};

	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */

	'use strict';

	var CallbackQueue = __webpack_require__(184);
	var PooledClass = __webpack_require__(185);
	var ReactPerf = __webpack_require__(147);
	var ReactReconciler = __webpack_require__(179);
	var Transaction = __webpack_require__(186);

	var assign = __webpack_require__(168);
	var invariant = __webpack_require__(142);

	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;

	var batchingStrategy = null;

	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}

	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};

	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};

	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}

	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },

	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});

	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}

	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}

	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);

	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];

	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;

	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}

	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }

	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();

	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)

	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }

	  dirtyComponents.push(component);
	}

	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}

	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },

	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};

	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,

	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};

	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */

	'use strict';

	var PooledClass = __webpack_require__(185);

	var assign = __webpack_require__(168);
	var invariant = __webpack_require__(142);

	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}

	assign(CallbackQueue.prototype, {

	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },

	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },

	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },

	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }

	});

	PooledClass.addPoolingTo(CallbackQueue);

	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};

	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },

	  _isInTransaction: false,

	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,

	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },

	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },

	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },

	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};

	var Transaction = {

	  Mixin: Mixin,

	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}

	};

	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */

	'use strict';

	var emptyObject = {};

	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}

	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */

	'use strict';

	var isTextNode = __webpack_require__(189);

	/*eslint-disable no-bitwise */

	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;

	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;

	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}

	module.exports = containsNode;

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */

	'use strict';

	var isNode = __webpack_require__(190);

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}

	module.exports = isTextNode;

/***/ },
/* 190 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';

	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}

	module.exports = isNode;

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */

	'use strict';

	var ReactCompositeComponent = __webpack_require__(192);
	var ReactEmptyComponent = __webpack_require__(197);
	var ReactNativeComponent = __webpack_require__(198);

	var assign = __webpack_require__(168);
	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function () {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}

	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;

	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;

	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }

	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);

	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;

	  if (process.env.NODE_ENV !== 'production') {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }

	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }

	  return instance;
	}

	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */

	'use strict';

	var ReactComponentEnvironment = __webpack_require__(193);
	var ReactCurrentOwner = __webpack_require__(134);
	var ReactElement = __webpack_require__(171);
	var ReactInstanceMap = __webpack_require__(176);
	var ReactPerf = __webpack_require__(147);
	var ReactPropTypeLocations = __webpack_require__(194);
	var ReactPropTypeLocationNames = __webpack_require__(195);
	var ReactReconciler = __webpack_require__(179);
	var ReactUpdateQueue = __webpack_require__(182);

	var assign = __webpack_require__(168);
	var emptyObject = __webpack_require__(187);
	var invariant = __webpack_require__(142);
	var shouldUpdateReactComponent = __webpack_require__(196);
	var warning = __webpack_require__(154);

	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};

	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */

	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;

	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {

	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;

	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    this._renderedComponent = null;

	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;

	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;

	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);

	    var Component = this._currentElement.type;

	    // Initialize the public class
	    var inst;
	    var renderedElement;

	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = ('prototype' in Component);

	    if (canInstantiate) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }

	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }

	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;

	    this._instance = inst;

	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);

	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }

	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }

	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }

	    this._renderedComponent = this._instantiateReactComponent(renderedElement);

	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }

	    return markup;
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function () {
	    var inst = this._instance;

	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }

	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;

	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;

	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;

	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);

	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },

	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },

	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function (newProps) {
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },

	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function (propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);

	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },

	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;

	    this._pendingElement = null;

	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },

	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }

	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },

	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;

	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;

	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.

	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }

	    var nextState = this._processPendingState(nextProps, nextContext);

	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }

	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },

	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;

	    if (!queue) {
	      return inst.state;
	    }

	    if (replace && queue.length === 1) {
	      return queue[0];
	    }

	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }

	    return nextState;
	  },

	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;

	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }

	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }

	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;

	    this._updateRenderedComponent(transaction, unmaskedContext);

	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },

	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);

	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },

	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },

	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }

	    return renderedComponent;
	  },

	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },

	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },

	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },

	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },

	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },

	  // Stub
	  _instantiateReactComponent: null

	};

	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});

	var ReactCompositeComponent = {

	  Mixin: ReactCompositeComponentMixin

	};

	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */

	'use strict';

	var invariant = __webpack_require__(142);

	var injected = false;

	var ReactComponentEnvironment = {

	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,

	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,

	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,

	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }

	};

	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */

	'use strict';

	var keyMirror = __webpack_require__(146);

	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});

	module.exports = ReactPropTypeLocations;

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 196 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }

	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}

	module.exports = shouldUpdateReactComponent;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */

	'use strict';

	var ReactElement = __webpack_require__(171);
	var ReactEmptyComponentRegistry = __webpack_require__(173);
	var ReactReconciler = __webpack_require__(179);

	var assign = __webpack_require__(168);

	var placeholderElement;

	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function (component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};

	var ReactEmptyComponent = function (instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function (element) {},
	  mountComponent: function (rootID, transaction, context) {
	    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function () {},
	  unmountComponent: function (rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});

	ReactEmptyComponent.injection = ReactEmptyComponentInjection;

	module.exports = ReactEmptyComponent;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */

	'use strict';

	var assign = __webpack_require__(168);
	var invariant = __webpack_require__(142);

	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;

	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};

	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}

	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}

	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}

	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}

	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};

	module.exports = ReactNativeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */

	'use strict';

	var assign = __webpack_require__(168);
	var emptyFunction = __webpack_require__(144);
	var warning = __webpack_require__(154);

	var validateDOMNesting = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.

	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);

	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

	  var emptyAncestorInfo = {
	    parentTag: null,

	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,

	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };

	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };

	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }

	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }

	    ancestorInfo.parentTag = info;

	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }

	    return ancestorInfo;
	  };

	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }

	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;

	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }

	    return true;
	  };

	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':

	      case 'pre':
	      case 'listing':

	      case 'table':

	      case 'hr':

	      case 'xmp':

	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;

	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;

	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;

	      case 'button':
	        return ancestorInfo.buttonTagInScope;

	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;

	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }

	    return null;
	  };

	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }

	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };

	  var didWarn = {};

	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;

	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;

	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;

	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);

	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;

	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }

	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;

	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };

	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}

	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */

	'use strict';

	var BeforeInputEventPlugin = __webpack_require__(201);
	var ChangeEventPlugin = __webpack_require__(209);
	var ClientReactRootIndex = __webpack_require__(212);
	var DefaultEventPluginOrder = __webpack_require__(213);
	var EnterLeaveEventPlugin = __webpack_require__(214);
	var ExecutionEnvironment = __webpack_require__(138);
	var HTMLDOMPropertyConfig = __webpack_require__(218);
	var ReactBrowserComponentMixin = __webpack_require__(219);
	var ReactComponentBrowserEnvironment = __webpack_require__(155);
	var ReactDefaultBatchingStrategy = __webpack_require__(221);
	var ReactDOMComponent = __webpack_require__(222);
	var ReactDOMTextComponent = __webpack_require__(135);
	var ReactEventListener = __webpack_require__(247);
	var ReactInjection = __webpack_require__(250);
	var ReactInstanceHandles = __webpack_require__(174);
	var ReactMount = __webpack_require__(157);
	var ReactReconcileTransaction = __webpack_require__(254);
	var SelectEventPlugin = __webpack_require__(259);
	var ServerReactRootIndex = __webpack_require__(260);
	var SimpleEventPlugin = __webpack_require__(261);
	var SVGDOMPropertyConfig = __webpack_require__(270);

	var alreadyInjected = false;

	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;

	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);

	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });

	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

	  if (process.env.NODE_ENV !== 'production') {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = __webpack_require__(271);
	      ReactDefaultPerf.start();
	    }
	  }
	}

	module.exports = {
	  inject: inject
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventPropagators = __webpack_require__(202);
	var ExecutionEnvironment = __webpack_require__(138);
	var FallbackCompositionState = __webpack_require__(203);
	var SyntheticCompositionEvent = __webpack_require__(205);
	var SyntheticInputEvent = __webpack_require__(207);

	var keyOf = __webpack_require__(208);

	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;

	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}

	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}

	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

	var topLevelTypes = EventConstants.topLevelTypes;

	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};

	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;

	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}

	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}

	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}

	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}

	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}

	// Track the current IME composition fallback object, if any.
	var currentComposition = null;

	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;

	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }

	  if (!eventType) {
	    return null;
	  }

	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }

	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);

	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }

	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }

	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;

	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;

	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }

	      return chars;

	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}

	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }

	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}

	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;

	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }

	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }

	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);

	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};

	module.exports = BeforeInputEventPlugin;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventPluginHub = __webpack_require__(160);

	var warning = __webpack_require__(154);

	var accumulateInto = __webpack_require__(164);
	var forEachAccumulated = __webpack_require__(165);

	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;

	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}

	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}

	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}

	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}

	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}

	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}

	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}

	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}

	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};

	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */

	'use strict';

	var PooledClass = __webpack_require__(185);

	var assign = __webpack_require__(168);
	var getTextContentAccessor = __webpack_require__(204);

	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}

	assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },

	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },

	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }

	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;

	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }

	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }

	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});

	PooledClass.addPoolingTo(FallbackCompositionState);

	module.exports = FallbackCompositionState;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var contentKey = null;

	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}

	module.exports = getTextContentAccessor;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(206);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

	module.exports = SyntheticCompositionEvent;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */

	'use strict';

	var PooledClass = __webpack_require__(185);

	var assign = __webpack_require__(168);
	var emptyFunction = __webpack_require__(144);
	var warning = __webpack_require__(154);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};

	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;

	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }

	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}

	assign(SyntheticEvent.prototype, {

	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }

	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },

	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }

	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,

	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }

	});

	SyntheticEvent.Interface = EventInterface;

	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;

	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;

	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;

	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};

	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

	module.exports = SyntheticEvent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(206);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

	module.exports = SyntheticInputEvent;

/***/ },
/* 208 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */

	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";

	var keyOf = function (oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};

	module.exports = keyOf;

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventPluginHub = __webpack_require__(160);
	var EventPropagators = __webpack_require__(202);
	var ExecutionEnvironment = __webpack_require__(138);
	var ReactUpdates = __webpack_require__(183);
	var SyntheticEvent = __webpack_require__(206);

	var getEventTarget = __webpack_require__(210);
	var isEventSupported = __webpack_require__(169);
	var isTextInputElement = __webpack_require__(211);
	var keyOf = __webpack_require__(208);

	var topLevelTypes = EventConstants.topLevelTypes;

	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};

	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;

	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}

	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}

	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);

	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}

	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}

	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}

	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}

	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}

	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}

	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};

	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}

	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }

	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);

	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}

	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;

	  manualDispatchChangeEvent(nativeEvent);
	}

	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}

	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}

	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}

	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}

	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}

	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {

	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }

	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }

	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }

	};

	module.exports = ChangeEventPlugin;

/***/ },
/* 210 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}

	module.exports = getEventTarget;

/***/ },
/* 211 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */

	'use strict';

	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};

	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}

	module.exports = isTextInputElement;

/***/ },
/* 212 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */

	'use strict';

	var nextReactRootIndex = 0;

	var ClientReactRootIndex = {
	  createReactRootIndex: function () {
	    return nextReactRootIndex++;
	  }
	};

	module.exports = ClientReactRootIndex;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */

	'use strict';

	var keyOf = __webpack_require__(208);

	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

	module.exports = DefaultEventPluginOrder;

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventPropagators = __webpack_require__(202);
	var SyntheticMouseEvent = __webpack_require__(215);

	var ReactMount = __webpack_require__(157);
	var keyOf = __webpack_require__(208);

	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;

	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};

	var extractedEvents = [null, null];

	var EnterLeaveEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }

	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }

	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }

	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }

	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;

	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;

	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;

	    return extractedEvents;
	  }

	};

	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(216);
	var ViewportMetrics = __webpack_require__(167);

	var getEventModifierState = __webpack_require__(217);

	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

	module.exports = SyntheticMouseEvent;

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(206);

	var getEventTarget = __webpack_require__(210);

	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }

	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }

	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

	module.exports = SyntheticUIEvent;

/***/ },
/* 217 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */

	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};

	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}

	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}

	module.exports = getEventModifierState;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */

	'use strict';

	var DOMProperty = __webpack_require__(152);
	var ExecutionEnvironment = __webpack_require__(138);

	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}

	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,

	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,

	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};

	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */

	'use strict';

	var ReactInstanceMap = __webpack_require__(176);

	var findDOMNode = __webpack_require__(220);
	var warning = __webpack_require__(154);

	var didWarnKey = '_getDOMNodeDidWarn';

	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function () {
	    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};

	module.exports = ReactBrowserComponentMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(134);
	var ReactInstanceMap = __webpack_require__(176);
	var ReactMount = __webpack_require__(157);

	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}

	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */

	'use strict';

	var ReactUpdates = __webpack_require__(183);
	var Transaction = __webpack_require__(186);

	var assign = __webpack_require__(168);
	var emptyFunction = __webpack_require__(144);

	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};

	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};

	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}

	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});

	var transaction = new ReactDefaultBatchingStrategyTransaction();

	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,

	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};

	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */

	/* global hasOwnProperty:true */

	'use strict';

	var AutoFocusUtils = __webpack_require__(223);
	var CSSPropertyOperations = __webpack_require__(225);
	var DOMProperty = __webpack_require__(152);
	var DOMPropertyOperations = __webpack_require__(151);
	var EventConstants = __webpack_require__(159);
	var ReactBrowserEventEmitter = __webpack_require__(158);
	var ReactComponentBrowserEnvironment = __webpack_require__(155);
	var ReactDOMButton = __webpack_require__(233);
	var ReactDOMInput = __webpack_require__(234);
	var ReactDOMOption = __webpack_require__(238);
	var ReactDOMSelect = __webpack_require__(241);
	var ReactDOMTextarea = __webpack_require__(242);
	var ReactMount = __webpack_require__(157);
	var ReactMultiChild = __webpack_require__(243);
	var ReactPerf = __webpack_require__(147);
	var ReactUpdateQueue = __webpack_require__(182);

	var assign = __webpack_require__(168);
	var canDefineProperty = __webpack_require__(172);
	var escapeTextContentForBrowser = __webpack_require__(150);
	var invariant = __webpack_require__(142);
	var isEventSupported = __webpack_require__(169);
	var keyOf = __webpack_require__(208);
	var setInnerHTML = __webpack_require__(148);
	var setTextContent = __webpack_require__(149);
	var shallowEqual = __webpack_require__(246);
	var validateDOMNesting = __webpack_require__(199);
	var warning = __webpack_require__(154);

	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };

	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });

	var ELEMENT_NODE_TYPE = 1;

	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}

	var legacyPropsDescriptor;
	if (process.env.NODE_ENV !== 'production') {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function () {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}

	function legacyGetDOMNode() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}

	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}

	function legacySetStateEtc() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}

	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}

	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}

	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}

	var styleMutationWarning = {};

	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }

	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }

	  var hash = ownerName + '|' + componentName;

	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }

	  styleMutationWarning[hash] = true;

	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}

	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (process.env.NODE_ENV !== 'production') {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}

	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}

	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}

	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};

	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;

	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':

	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }

	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}

	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}

	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}

	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.

	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};

	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};

	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.

	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);

	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name

	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = ({}).hasOwnProperty;

	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}

	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}

	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}

	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (process.env.NODE_ENV !== 'production') {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}

	ReactDOMComponent.displayName = 'ReactDOMComponent';

	ReactDOMComponent.Mixin = {

	  construct: function (element) {
	    this._currentElement = element;
	  },

	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._rootNodeID = rootID;

	    var props = this._currentElement.props;

	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }

	    assertValidProps(this, props);
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }

	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }

	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }

	    return mountImage;
	  },

	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;

	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }

	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }

	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },

	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';

	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },

	  _createInitialChildren: function (transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },

	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },

	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;

	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }

	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);

	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }

	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },

	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },

	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;

	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }

	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },

	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function () {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }

	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },

	  getPublicInstance: function () {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);

	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;

	      if (process.env.NODE_ENV !== 'production') {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }

	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }

	};

	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});

	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */

	'use strict';

	var ReactMount = __webpack_require__(157);

	var findDOMNode = __webpack_require__(220);
	var focusNode = __webpack_require__(224);

	var Mixin = {
	  componentDidMount: function () {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};

	var AutoFocusUtils = {
	  Mixin: Mixin,

	  focusDOMComponent: function () {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};

	module.exports = AutoFocusUtils;

/***/ },
/* 224 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */

	'use strict';

	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}

	module.exports = focusNode;

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */

	'use strict';

	var CSSProperty = __webpack_require__(226);
	var ExecutionEnvironment = __webpack_require__(138);
	var ReactPerf = __webpack_require__(147);

	var camelizeStyleName = __webpack_require__(227);
	var dangerousStyleValue = __webpack_require__(229);
	var hyphenateStyleName = __webpack_require__(230);
	var memoizeStringOnly = __webpack_require__(232);
	var warning = __webpack_require__(154);

	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});

	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}

	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;

	  var warnedStyleNames = {};
	  var warnedStyleValues = {};

	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };

	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };

	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }

	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };

	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}

	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {

	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },

	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function (node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }

	};

	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});

	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 226 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */

	'use strict';

	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,

	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};

	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}

	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});

	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};

	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};

	module.exports = CSSProperty;

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */

	'use strict';

	var camelize = __webpack_require__(228);

	var msPattern = /^-ms-/;

	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}

	module.exports = camelizeStyleName;

/***/ },
/* 228 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */

	"use strict";

	var _hyphenPattern = /-(.)/g;

	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}

	module.exports = camelize;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */

	'use strict';

	var CSSProperty = __webpack_require__(226);

	var isUnitlessNumber = CSSProperty.isUnitlessNumber;

	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901

	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }

	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }

	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}

	module.exports = dangerousStyleValue;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */

	'use strict';

	var hyphenate = __webpack_require__(231);

	var msPattern = /^ms-/;

	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}

	module.exports = hyphenateStyleName;

/***/ },
/* 231 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */

	'use strict';

	var _uppercasePattern = /([A-Z])/g;

	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}

	module.exports = hyphenate;

/***/ },
/* 232 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}

	module.exports = memoizeStringOnly;

/***/ },
/* 233 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */

	'use strict';

	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,

	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};

	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function (inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }

	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }

	    return nativeProps;
	  }
	};

	module.exports = ReactDOMButton;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */

	'use strict';

	var ReactDOMIDOperations = __webpack_require__(156);
	var LinkedValueUtils = __webpack_require__(235);
	var ReactMount = __webpack_require__(157);
	var ReactUpdates = __webpack_require__(183);

	var assign = __webpack_require__(168);
	var invariant = __webpack_require__(142);

	var instancesByReactID = {};

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}

	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function (inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);

	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });

	    return nativeProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }

	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },

	  mountReadyWrapper: function (inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },

	  unmountWrapper: function (inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }

	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;

	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);

	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;

	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }

	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }

	  return returnValue;
	}

	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */

	'use strict';

	var ReactPropTypes = __webpack_require__(236);
	var ReactPropTypeLocations = __webpack_require__(194);

	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};

	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}

	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}

	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};

	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};

	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */

	'use strict';

	var ReactElement = __webpack_require__(171);
	var ReactPropTypeLocationNames = __webpack_require__(195);

	var emptyFunction = __webpack_require__(144);
	var getIteratorFn = __webpack_require__(237);

	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */

	var ANONYMOUS = '<<anonymous>>';

	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),

	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};

	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }

	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);

	  return chainedCheckType;
	}

	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);

	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}

	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }

	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }

	      return true;
	    default:
	      return false;
	  }
	}

	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}

	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}

	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}

	module.exports = ReactPropTypes;

/***/ },
/* 237 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */

	'use strict';

	/* global Symbol */
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */

	'use strict';

	var ReactChildren = __webpack_require__(239);
	var ReactDOMSelect = __webpack_require__(241);

	var assign = __webpack_require__(168);
	var warning = __webpack_require__(154);

	var valueContextKey = ReactDOMSelect.valueContextKey;

	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }

	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];

	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }

	    inst._wrapperState = { selected: selected };
	  },

	  getNativeProps: function (inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);

	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }

	    var content = '';

	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });

	    if (content) {
	      nativeProps.children = content;
	    }

	    return nativeProps;
	  }

	};

	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */

	'use strict';

	var PooledClass = __webpack_require__(185);
	var ReactElement = __webpack_require__(171);

	var emptyFunction = __webpack_require__(144);
	var traverseAllChildren = __webpack_require__(240);

	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;

	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;

	  func.call(context, child, bookKeeping.count++);
	}

	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;

	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}

	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}

	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}

	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}

	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}

	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}

	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};

	module.exports = ReactChildren;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(134);
	var ReactElement = __webpack_require__(171);
	var ReactInstanceHandles = __webpack_require__(174);

	var getIteratorFn = __webpack_require__(237);
	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};

	var userProvidedKeyEscapeRegex = /[=.:]/g;

	var didWarnAboutMaps = false;

	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}

	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */

	'use strict';

	var LinkedValueUtils = __webpack_require__(235);
	var ReactMount = __webpack_require__(157);
	var ReactUpdates = __webpack_require__(183);

	var assign = __webpack_require__(168);
	var warning = __webpack_require__(154);

	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;

	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);

	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	var valuePropNames = ['value', 'defaultValue'];

	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);

	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}

	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;

	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}

	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,

	  getNativeProps: function (inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }

	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },

	  processChildContext: function (inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },

	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;

	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);

	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */

	'use strict';

	var LinkedValueUtils = __webpack_require__(235);
	var ReactDOMIDOperations = __webpack_require__(156);
	var ReactUpdates = __webpack_require__(183);

	var assign = __webpack_require__(168);
	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}

	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function (inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });

	    return nativeProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }

	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }

	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);

	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */

	'use strict';

	var ReactComponentEnvironment = __webpack_require__(193);
	var ReactMultiChildUpdateTypes = __webpack_require__(145);

	var ReactCurrentOwner = __webpack_require__(134);
	var ReactReconciler = __webpack_require__(179);
	var ReactChildReconciler = __webpack_require__(244);

	var flattenChildren = __webpack_require__(245);

	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;

	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];

	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];

	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}

	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}

	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}

	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}

	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}

	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}

	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}

	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {

	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {

	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },

	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },

	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },

	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },

	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },

	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },

	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },

	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function () {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },

	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },

	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },

	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },

	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function (textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },

	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function (markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },

	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },

	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }

	  }

	};

	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */

	'use strict';

	var ReactReconciler = __webpack_require__(179);

	var instantiateReactComponent = __webpack_require__(191);
	var shouldUpdateReactComponent = __webpack_require__(196);
	var traverseAllChildren = __webpack_require__(240);
	var warning = __webpack_require__(154);

	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}

	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },

	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },

	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }

	};

	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */

	'use strict';

	var traverseAllChildren = __webpack_require__(240);
	var warning = __webpack_require__(154);

	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}

	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}

	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 246 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */

	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }

	  return true;
	}

	module.exports = shallowEqual;

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */

	'use strict';

	var EventListener = __webpack_require__(248);
	var ExecutionEnvironment = __webpack_require__(138);
	var PooledClass = __webpack_require__(185);
	var ReactInstanceHandles = __webpack_require__(174);
	var ReactMount = __webpack_require__(157);
	var ReactUpdates = __webpack_require__(183);

	var assign = __webpack_require__(168);
	var getEventTarget = __webpack_require__(210);
	var getUnboundedScrollPosition = __webpack_require__(249);

	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}

	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }

	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}

	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }

	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);

	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}

	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,

	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },

	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },

	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },

	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },

	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }

	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};

	module.exports = ReactEventListener;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */

	'use strict';

	var emptyFunction = __webpack_require__(144);

	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function () {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },

	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },

	  registerDefault: function () {}
	};

	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 249 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */

	'use strict';

	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}

	module.exports = getUnboundedScrollPosition;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */

	'use strict';

	var DOMProperty = __webpack_require__(152);
	var EventPluginHub = __webpack_require__(160);
	var ReactComponentEnvironment = __webpack_require__(193);
	var ReactClass = __webpack_require__(251);
	var ReactEmptyComponent = __webpack_require__(197);
	var ReactBrowserEventEmitter = __webpack_require__(158);
	var ReactNativeComponent = __webpack_require__(198);
	var ReactPerf = __webpack_require__(147);
	var ReactRootIndex = __webpack_require__(175);
	var ReactUpdates = __webpack_require__(183);

	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};

	module.exports = ReactInjection;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */

	'use strict';

	var ReactComponent = __webpack_require__(252);
	var ReactElement = __webpack_require__(171);
	var ReactPropTypeLocations = __webpack_require__(194);
	var ReactPropTypeLocationNames = __webpack_require__(195);
	var ReactNoopUpdateQueue = __webpack_require__(253);

	var assign = __webpack_require__(168);
	var emptyObject = __webpack_require__(187);
	var invariant = __webpack_require__(142);
	var keyMirror = __webpack_require__(146);
	var keyOf = __webpack_require__(208);
	var warning = __webpack_require__(154);

	var MIXINS_KEY = keyOf({ mixins: null });

	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});

	var injectedMixins = [];

	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}

	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {

	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,

	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,

	  // ==== Definition methods ====

	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,

	  // ==== Delegate methods ====

	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,

	  // ==== Advanced methods ====

	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE

	};

	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };

	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}

	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }

	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}

	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }

	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

	  var proto = Constructor.prototype;

	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }

	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }

	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }

	    var property = spec[name];
	    validateMethodOverride(proto, name);

	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];

	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}

	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }

	    var isReserved = (name in RESERVED_SPEC_KEYS);
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

	    var isInherited = (name in Constructor);
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}

	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}

	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}

	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}

	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}

	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}

	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {

	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  },

	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function (partialProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },

	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function (newProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};

	var ReactClassComponent = function () {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {

	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.

	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }

	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }

	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;

	      this.state = null;

	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.

	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;

	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

	    mixSpecIntoComponent(Constructor, spec);

	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }

	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }

	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }

	    return Constructor;
	  },

	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }

	};

	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */

	'use strict';

	var ReactNoopUpdateQueue = __webpack_require__(253);

	var canDefineProperty = __webpack_require__(172);
	var emptyObject = __webpack_require__(187);
	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	ReactComponent.prototype.isReactComponent = {};

	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};

	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};

	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}

	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */

	'use strict';

	var warning = __webpack_require__(154);

	function warnTDZ(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}

	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },

	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },

	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }

	};

	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */

	'use strict';

	var CallbackQueue = __webpack_require__(184);
	var PooledClass = __webpack_require__(185);
	var ReactBrowserEventEmitter = __webpack_require__(158);
	var ReactDOMFeatureFlags = __webpack_require__(170);
	var ReactInputSelection = __webpack_require__(255);
	var Transaction = __webpack_require__(186);

	var assign = __webpack_require__(168);

	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};

	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },

	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};

	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },

	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};

	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

	PooledClass.addPoolingTo(ReactReconcileTransaction);

	module.exports = ReactReconcileTransaction;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */

	'use strict';

	var ReactDOMSelection = __webpack_require__(256);

	var containsNode = __webpack_require__(188);
	var focusNode = __webpack_require__(224);
	var getActiveElement = __webpack_require__(258);

	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}

	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {

	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },

	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },

	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },

	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;

	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }

	    return selection || { start: 0, end: 0 };
	  },

	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }

	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};

	module.exports = ReactInputSelection;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var getNodeForCharacterOffset = __webpack_require__(257);
	var getTextContentAccessor = __webpack_require__(204);

	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}

	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;

	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);

	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;

	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}

	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();

	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }

	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;

	  var currentRange = selection.getRangeAt(0);

	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }

	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;

	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;

	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}

	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;

	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }

	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}

	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }

	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }

	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);

	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();

	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}

	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};

	module.exports = ReactDOMSelection;

/***/ },
/* 257 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */

	'use strict';

	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}

	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;

	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;

	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }

	      nodeStart = nodeEnd;
	    }

	    node = getLeafNode(getSiblingNode(node));
	  }
	}

	module.exports = getNodeForCharacterOffset;

/***/ },
/* 258 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */

	/* eslint-disable fb-www/typeof-undefined */

	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';

	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}

	module.exports = getActiveElement;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventPropagators = __webpack_require__(202);
	var ExecutionEnvironment = __webpack_require__(138);
	var ReactInputSelection = __webpack_require__(255);
	var SyntheticEvent = __webpack_require__(206);

	var getActiveElement = __webpack_require__(258);
	var isTextInputElement = __webpack_require__(211);
	var keyOf = __webpack_require__(208);
	var shallowEqual = __webpack_require__(246);

	var topLevelTypes = EventConstants.topLevelTypes;

	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};

	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;

	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });

	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}

	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }

	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;

	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);

	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;

	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

	    return syntheticEvent;
	  }

	  return null;
	}

	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }

	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;

	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);

	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }

	    return null;
	  },

	  didPutListener: function (id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};

	module.exports = SelectEventPlugin;

/***/ },
/* 260 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */

	'use strict';

	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

	var ServerReactRootIndex = {
	  createReactRootIndex: function () {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};

	module.exports = ServerReactRootIndex;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventListener = __webpack_require__(248);
	var EventPropagators = __webpack_require__(202);
	var ReactMount = __webpack_require__(157);
	var SyntheticClipboardEvent = __webpack_require__(262);
	var SyntheticEvent = __webpack_require__(206);
	var SyntheticFocusEvent = __webpack_require__(263);
	var SyntheticKeyboardEvent = __webpack_require__(264);
	var SyntheticMouseEvent = __webpack_require__(215);
	var SyntheticDragEvent = __webpack_require__(267);
	var SyntheticTouchEvent = __webpack_require__(268);
	var SyntheticUIEvent = __webpack_require__(216);
	var SyntheticWheelEvent = __webpack_require__(269);

	var emptyFunction = __webpack_require__(144);
	var getEventCharCode = __webpack_require__(265);
	var invariant = __webpack_require__(142);
	var keyOf = __webpack_require__(208);

	var topLevelTypes = EventConstants.topLevelTypes;

	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};

	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};

	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}

	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};

	var SimpleEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },

	  didPutListener: function (id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },

	  willDeleteListener: function (id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }

	};

	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(206);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

	module.exports = SyntheticClipboardEvent;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(216);

	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

	module.exports = SyntheticFocusEvent;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(216);

	var getEventCharCode = __webpack_require__(265);
	var getEventKey = __webpack_require__(266);
	var getEventModifierState = __webpack_require__(217);

	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.

	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.

	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 265 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;

	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;

	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }

	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }

	  return 0;
	}

	module.exports = getEventCharCode;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */

	'use strict';

	var getEventCharCode = __webpack_require__(265);

	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};

	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};

	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.

	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }

	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);

	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}

	module.exports = getEventKey;

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(215);

	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

	module.exports = SyntheticDragEvent;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(216);

	var getEventModifierState = __webpack_require__(217);

	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

	module.exports = SyntheticTouchEvent;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(215);

	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,

	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

	module.exports = SyntheticWheelEvent;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */

	'use strict';

	var DOMProperty = __webpack_require__(152);

	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};

	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};

	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */

	'use strict';

	var DOMProperty = __webpack_require__(152);
	var ReactDefaultPerfAnalysis = __webpack_require__(272);
	var ReactMount = __webpack_require__(157);
	var ReactPerf = __webpack_require__(147);

	var performanceNow = __webpack_require__(273);

	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}

	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}

	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,

	  start: function () {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }

	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },

	  stop: function () {
	    ReactPerf.enableMeasure = false;
	  },

	  getLastMeasurements: function () {
	    return ReactDefaultPerf._allMeasurements;
	  },

	  printExclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },

	  printInclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },

	  getMeasurementsSummaryMap: function (measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },

	  printWasted: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },

	  printDOM: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },

	  _recordWrite: function (id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },

	  measure: function (moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      var totalTime;
	      var rv;
	      var start;

	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;

	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if (typeof id === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {

	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }

	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';

	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }

	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;

	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }

	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };

	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};

	module.exports = ReactDefaultPerf;

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */

	'use strict';

	var assign = __webpack_require__(168);

	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};

	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}

	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}

	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;

	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;

	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }

	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }

	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });

	  return arr;
	}

	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;

	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;

	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }

	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }

	      var displayName = measurement.displayNames[id];

	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;

	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };

	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }

	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }

	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });

	  return arr;
	}

	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}

	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};

	module.exports = ReactDefaultPerfAnalysis;

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */

	'use strict';

	var performance = __webpack_require__(274);

	var performanceNow;

	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function () {
	    return performance.now();
	  };
	} else {
	  performanceNow = function () {
	    return Date.now();
	  };
	}

	module.exports = performanceNow;

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(138);

	var performance;

	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}

	module.exports = performance || {};

/***/ },
/* 275 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */

	'use strict';

	module.exports = '0.14.7';

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/

	'use strict';

	var ReactMount = __webpack_require__(157);

	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */

	'use strict';

	var ReactDefaultInjection = __webpack_require__(200);
	var ReactServerRendering = __webpack_require__(278);
	var ReactVersion = __webpack_require__(275);

	ReactDefaultInjection.inject();

	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};

	module.exports = ReactDOMServer;

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';

	var ReactDefaultBatchingStrategy = __webpack_require__(221);
	var ReactElement = __webpack_require__(171);
	var ReactInstanceHandles = __webpack_require__(174);
	var ReactMarkupChecksum = __webpack_require__(177);
	var ReactServerBatchingStrategy = __webpack_require__(279);
	var ReactServerRenderingTransaction = __webpack_require__(280);
	var ReactUpdates = __webpack_require__(183);

	var emptyObject = __webpack_require__(187);
	var instantiateReactComponent = __webpack_require__(191);
	var invariant = __webpack_require__(142);

	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);

	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}

	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);

	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}

	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 279 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */

	'use strict';

	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function (callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};

	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */

	'use strict';

	var PooledClass = __webpack_require__(185);
	var CallbackQueue = __webpack_require__(184);
	var Transaction = __webpack_require__(186);

	var assign = __webpack_require__(168);
	var emptyFunction = __webpack_require__(144);

	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },

	  close: emptyFunction
	};

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};

	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

	PooledClass.addPoolingTo(ReactServerRenderingTransaction);

	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */

	'use strict';

	var ReactChildren = __webpack_require__(239);
	var ReactComponent = __webpack_require__(252);
	var ReactClass = __webpack_require__(251);
	var ReactDOMFactories = __webpack_require__(282);
	var ReactElement = __webpack_require__(171);
	var ReactElementValidator = __webpack_require__(283);
	var ReactPropTypes = __webpack_require__(236);
	var ReactVersion = __webpack_require__(275);

	var assign = __webpack_require__(168);
	var onlyChild = __webpack_require__(285);

	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;

	if (process.env.NODE_ENV !== 'production') {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}

	var React = {

	  // Modern

	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },

	  Component: ReactComponent,

	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,

	  // Classic

	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },

	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,

	  version: ReactVersion,

	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};

	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */

	'use strict';

	var ReactElement = __webpack_require__(171);
	var ReactElementValidator = __webpack_require__(283);

	var mapObject = __webpack_require__(284);

	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (process.env.NODE_ENV !== 'production') {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}

	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',

	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'

	}, createDOMFactory);

	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */

	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */

	'use strict';

	var ReactElement = __webpack_require__(171);
	var ReactPropTypeLocations = __webpack_require__(194);
	var ReactPropTypeLocationNames = __webpack_require__(195);
	var ReactCurrentOwner = __webpack_require__(134);

	var canDefineProperty = __webpack_require__(172);
	var getIteratorFn = __webpack_require__(237);
	var invariant = __webpack_require__(142);
	var warning = __webpack_require__(154);

	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};

	var loggedTypeFailures = {};

	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;

	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}

	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }

	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;

	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };

	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }

	  return addenda;
	}

	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}

	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var addendum = getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}

	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}

	var ReactElementValidator = {

	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

	    var element = ReactElement.createElement.apply(this, arguments);

	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }

	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }

	    validatePropTypes(element);

	    return element;
	  },

	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;

	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }

	    return validatedFactory;
	  },

	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }

	};

	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 284 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */

	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}

	module.exports = mapObject;

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';

	var ReactElement = __webpack_require__(171);

	var invariant = __webpack_require__(142);

	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}

	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */

	'use strict';

	var assign = __webpack_require__(168);
	var warning = __webpack_require__(154);

	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (process.env.NODE_ENV !== 'production') {
	    var newFn = function () {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }

	  return fn;
	}

	module.exports = deprecated;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 287 */
/***/ function(module, exports) {

	'use strict';

	/*
	 * Constants.
	 */

	var WHITE_SPACE_COLLAPSABLE = /\s+/g;
	var SPACE = ' ';

	/**
	 * Replace multiple white-space characters with a single space.
	 *
	 * @example
	 *   collapse(' \t\nbar \nbaz\t'); // ' bar baz '
	 *
	 * @param {string} value - Value with uncollapsed white-space,
	 *   coerced to string.
	 * @return {string} - Value with collapsed white-space.
	 */
	function collapse(value) {
	    return String(value).replace(WHITE_SPACE_COLLAPSABLE, SPACE);
	}

	/*
	 * Expose.
	 */

	module.exports = collapse;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = reactElementToJSXString;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(131);

	var _react2 = _interopRequireDefault(_react);

	var _collapseWhiteSpace = __webpack_require__(287);

	var _collapseWhiteSpace2 = _interopRequireDefault(_collapseWhiteSpace);

	var _reactAddonsTestUtils = __webpack_require__(289);

	var _isPlainObject = __webpack_require__(291);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _stringifyObject = __webpack_require__(293);

	var _stringifyObject2 = _interopRequireDefault(_stringifyObject);

	var _sortobject = __webpack_require__(296);

	var _sortobject2 = _interopRequireDefault(_sortobject);

	var _traverse = __webpack_require__(297);

	var _traverse2 = _interopRequireDefault(_traverse);

	var _lodashArrayFill = __webpack_require__(298);

	var _lodashArrayFill2 = _interopRequireDefault(_lodashArrayFill);

	function reactElementToJSXString(ReactElement) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  var getDisplayName = options.displayName || getDefaultDisplayName;

	  return toJSXString({ ReactElement: ReactElement });

	  function toJSXString(_ref) {
	    var _ref$ReactElement = _ref.ReactElement;
	    var Element = _ref$ReactElement === undefined ? null : _ref$ReactElement;
	    var _ref$lvl = _ref.lvl;
	    var lvl = _ref$lvl === undefined ? 0 : _ref$lvl;
	    var _ref$inline = _ref.inline;
	    var inline = _ref$inline === undefined ? false : _ref$inline;

	    if (typeof Element === 'string' || typeof Element === 'number') {
	      return Element;
	    } else if (!(0, _reactAddonsTestUtils.isElement)(Element)) {
	      throw new Error('react-element-to-jsx-string: Expected a ReactElement, ' + 'got `' + typeof Element + '`');
	    }

	    var tagName = getDisplayName(Element);

	    var out = '<' + tagName;
	    var props = formatProps(Element.props);
	    var attributes = [];
	    var children = _react2['default'].Children.toArray(Element.props.children).filter(onlyMeaningfulChildren);

	    if (Element.ref !== null) {
	      attributes.push(getJSXAttribute('ref', Element.ref));
	    }

	    if (Element.key !== null &&
	    // React automatically add key=".X" when there are some children
	    !/^\./.test(Element.key)) {
	      attributes.push(getJSXAttribute('key', Element.key));
	    }

	    attributes = attributes.concat(props);

	    attributes.forEach(function (attribute) {
	      if (attributes.length === 1 || inline) {
	        out += ' ';
	      } else {
	        out += '\n' + spacer(lvl + 1);
	      }

	      out += attribute.name + '=' + attribute.value;
	    });

	    if (attributes.length > 1 && !inline) {
	      out += '\n' + spacer(lvl);
	    }

	    if (children.length > 0) {
	      out += '>';
	      lvl++;
	      if (!inline) {
	        out += '\n';
	        out += spacer(lvl);
	      }

	      if (typeof children === 'string') {
	        out += children;
	      } else {
	        out += children.reduce(mergePlainStringChildren, []).map(recurse({ lvl: lvl, inline: inline })).join('\n' + spacer(lvl));
	      }
	      if (!inline) {
	        out += '\n';
	        out += spacer(lvl - 1);
	      }
	      out += '</' + tagName + '>';
	    } else {
	      if (attributes.length <= 1) {
	        out += ' ';
	      }

	      out += '/>';
	    }

	    return out;
	  }

	  function formatProps(props) {
	    return Object.keys(props).filter(noChildren).sort().map(function (propName) {
	      return getJSXAttribute(propName, props[propName]);
	    });
	  }

	  function getJSXAttribute(name, value) {
	    return {
	      name: name,
	      value: formatJSXAttribute(value).replace(/'?<__reactElementToJSXString__Wrapper__>/g, '').replace(/<\/__reactElementToJSXString__Wrapper__>'?/g, '')
	    };
	  }

	  function formatJSXAttribute(propValue) {
	    if (typeof propValue === 'string') {
	      return '"' + propValue + '"';
	    }

	    return '{' + formatValue(propValue) + '}';
	  }

	  function formatValue(value) {
	    if (typeof value === 'function') {
	      return function noRefCheck() {};
	    } else if ((0, _reactAddonsTestUtils.isElement)(value)) {
	      // we use this delimiter hack in cases where the react element is a property
	      // of an object from a root prop
	      // i.e.
	      //   reactElementToJSXString(<div a={{b: <div />}} />
	      //   // <div a={{b: <div />}} />
	      // we then remove the whole wrapping
	      // otherwise, the element would be surrounded by quotes: <div a={{b: '<div />'}} />
	      return '<__reactElementToJSXString__Wrapper__>' + toJSXString({ ReactElement: value, inline: true }) + '</__reactElementToJSXString__Wrapper__>';
	    } else if ((0, _isPlainObject2['default'])(value) || Array.isArray(value)) {
	      return '<__reactElementToJSXString__Wrapper__>' + stringifyObject(value) + '</__reactElementToJSXString__Wrapper__>';
	    }

	    return value;
	  }

	  function recurse(_ref2) {
	    var lvl = _ref2.lvl;
	    var inline = _ref2.inline;

	    return function (Element) {
	      return toJSXString({ ReactElement: Element, lvl: lvl, inline: inline });
	    };
	  }

	  function stringifyObject(obj) {
	    if (Object.keys(obj).length > 0 || obj.length > 0) {
	      obj = (0, _traverse2['default'])(obj).map(function (value) {
	        if ((0, _reactAddonsTestUtils.isElement)(value) || this.isLeaf) {
	          this.update(formatValue(value));
	        }
	      });

	      obj = (0, _sortobject2['default'])(obj);
	    }

	    return (0, _collapseWhiteSpace2['default'])((0, _stringifyObject2['default'])(obj)).replace(/{ /g, '{').replace(/ }/g, '}').replace(/\[ /g, '[').replace(/ \]/g, ']');
	  }
	}

	function getDefaultDisplayName(ReactElement) {
	  return ReactElement.type.name || // function name
	  ReactElement.type.displayName || (typeof ReactElement.type === 'function' ? // function without a name, you should provide one
	  'No Display Name' : ReactElement.type);
	}

	function mergePlainStringChildren(prev, cur) {
	  var lastItem = prev[prev.length - 1];

	  if (typeof cur === 'number') {
	    cur = '' + cur;
	  }

	  if (typeof lastItem === 'string' && typeof cur === 'string') {
	    prev[prev.length - 1] += cur;
	  } else {
	    prev.push(cur);
	  }

	  return prev;
	}

	function spacer(times) {
	  return (0, _lodashArrayFill2['default'])(new Array(times), '  ').join('');
	}

	function noChildren(propName) {
	  return propName !== 'children';
	}

	function onlyMeaningfulChildren(children) {
	  return children !== true && children !== false && children !== null && children !== '';
	}
	module.exports = exports['default'];


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(290);

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactTestUtils
	 */

	'use strict';

	var EventConstants = __webpack_require__(159);
	var EventPluginHub = __webpack_require__(160);
	var EventPropagators = __webpack_require__(202);
	var React = __webpack_require__(132);
	var ReactDOM = __webpack_require__(133);
	var ReactElement = __webpack_require__(171);
	var ReactBrowserEventEmitter = __webpack_require__(158);
	var ReactCompositeComponent = __webpack_require__(192);
	var ReactInstanceHandles = __webpack_require__(174);
	var ReactInstanceMap = __webpack_require__(176);
	var ReactMount = __webpack_require__(157);
	var ReactUpdates = __webpack_require__(183);
	var SyntheticEvent = __webpack_require__(206);

	var assign = __webpack_require__(168);
	var emptyObject = __webpack_require__(187);
	var findDOMNode = __webpack_require__(220);
	var invariant = __webpack_require__(142);

	var topLevelTypes = EventConstants.topLevelTypes;

	function Event(suffix) {}

	/**
	 * @class ReactTestUtils
	 */

	function findAllInRenderedTreeInternal(inst, test) {
	  if (!inst || !inst.getPublicInstance) {
	    return [];
	  }
	  var publicInst = inst.getPublicInstance();
	  var ret = test(publicInst) ? [publicInst] : [];
	  var currentElement = inst._currentElement;
	  if (ReactTestUtils.isDOMComponent(publicInst)) {
	    var renderedChildren = inst._renderedChildren;
	    var key;
	    for (key in renderedChildren) {
	      if (!renderedChildren.hasOwnProperty(key)) {
	        continue;
	      }
	      ret = ret.concat(findAllInRenderedTreeInternal(renderedChildren[key], test));
	    }
	  } else if (ReactElement.isValidElement(currentElement) && typeof currentElement.type === 'function') {
	    ret = ret.concat(findAllInRenderedTreeInternal(inst._renderedComponent, test));
	  }
	  return ret;
	}

	/**
	 * Todo: Support the entire DOM.scry query syntax. For now, these simple
	 * utilities will suffice for testing purposes.
	 * @lends ReactTestUtils
	 */
	var ReactTestUtils = {
	  renderIntoDocument: function (instance) {
	    var div = document.createElement('div');
	    // None of our tests actually require attaching the container to the
	    // DOM, and doing so creates a mess that we rely on test isolation to
	    // clean up, so we're going to stop honoring the name of this method
	    // (and probably rename it eventually) if no problems arise.
	    // document.documentElement.appendChild(div);
	    return ReactDOM.render(instance, div);
	  },

	  isElement: function (element) {
	    return ReactElement.isValidElement(element);
	  },

	  isElementOfType: function (inst, convenienceConstructor) {
	    return ReactElement.isValidElement(inst) && inst.type === convenienceConstructor;
	  },

	  isDOMComponent: function (inst) {
	    return !!(inst && inst.nodeType === 1 && inst.tagName);
	  },

	  isDOMComponentElement: function (inst) {
	    return !!(inst && ReactElement.isValidElement(inst) && !!inst.tagName);
	  },

	  isCompositeComponent: function (inst) {
	    if (ReactTestUtils.isDOMComponent(inst)) {
	      // Accessing inst.setState warns; just return false as that'll be what
	      // this returns when we have DOM nodes as refs directly
	      return false;
	    }
	    return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
	  },

	  isCompositeComponentWithType: function (inst, type) {
	    if (!ReactTestUtils.isCompositeComponent(inst)) {
	      return false;
	    }
	    var internalInstance = ReactInstanceMap.get(inst);
	    var constructor = internalInstance._currentElement.type;

	    return constructor === type;
	  },

	  isCompositeComponentElement: function (inst) {
	    if (!ReactElement.isValidElement(inst)) {
	      return false;
	    }
	    // We check the prototype of the type that will get mounted, not the
	    // instance itself. This is a future proof way of duck typing.
	    var prototype = inst.type.prototype;
	    return typeof prototype.render === 'function' && typeof prototype.setState === 'function';
	  },

	  isCompositeComponentElementWithType: function (inst, type) {
	    var internalInstance = ReactInstanceMap.get(inst);
	    var constructor = internalInstance._currentElement.type;

	    return !!(ReactTestUtils.isCompositeComponentElement(inst) && constructor === type);
	  },

	  getRenderedChildOfCompositeComponent: function (inst) {
	    if (!ReactTestUtils.isCompositeComponent(inst)) {
	      return null;
	    }
	    var internalInstance = ReactInstanceMap.get(inst);
	    return internalInstance._renderedComponent.getPublicInstance();
	  },

	  findAllInRenderedTree: function (inst, test) {
	    if (!inst) {
	      return [];
	    }
	    !ReactTestUtils.isCompositeComponent(inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findAllInRenderedTree(...): instance must be a composite component') : invariant(false) : undefined;
	    return findAllInRenderedTreeInternal(ReactInstanceMap.get(inst), test);
	  },

	  /**
	   * Finds all instance of components in the rendered tree that are DOM
	   * components with the class name matching `className`.
	   * @return {array} an array of all the matches.
	   */
	  scryRenderedDOMComponentsWithClass: function (root, classNames) {
	    if (!Array.isArray(classNames)) {
	      classNames = classNames.split(/\s+/);
	    }
	    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
	      if (ReactTestUtils.isDOMComponent(inst)) {
	        var className = inst.className;
	        if (typeof className !== 'string') {
	          // SVG, probably.
	          className = inst.getAttribute('class') || '';
	        }
	        var classList = className.split(/\s+/);
	        return classNames.every(function (name) {
	          return classList.indexOf(name) !== -1;
	        });
	      }
	      return false;
	    });
	  },

	  /**
	   * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
	   * and returns that one result, or throws exception if there is any other
	   * number of matches besides one.
	   * @return {!ReactDOMComponent} The one match.
	   */
	  findRenderedDOMComponentWithClass: function (root, className) {
	    var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
	    if (all.length !== 1) {
	      throw new Error('Did not find exactly one match ' + '(found: ' + all.length + ') for class:' + className);
	    }
	    return all[0];
	  },

	  /**
	   * Finds all instance of components in the rendered tree that are DOM
	   * components with the tag name matching `tagName`.
	   * @return {array} an array of all the matches.
	   */
	  scryRenderedDOMComponentsWithTag: function (root, tagName) {
	    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
	      return ReactTestUtils.isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
	    });
	  },

	  /**
	   * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
	   * and returns that one result, or throws exception if there is any other
	   * number of matches besides one.
	   * @return {!ReactDOMComponent} The one match.
	   */
	  findRenderedDOMComponentWithTag: function (root, tagName) {
	    var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
	    if (all.length !== 1) {
	      throw new Error('Did not find exactly one match for tag:' + tagName);
	    }
	    return all[0];
	  },

	  /**
	   * Finds all instances of components with type equal to `componentType`.
	   * @return {array} an array of all the matches.
	   */
	  scryRenderedComponentsWithType: function (root, componentType) {
	    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
	      return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
	    });
	  },

	  /**
	   * Same as `scryRenderedComponentsWithType` but expects there to be one result
	   * and returns that one result, or throws exception if there is any other
	   * number of matches besides one.
	   * @return {!ReactComponent} The one match.
	   */
	  findRenderedComponentWithType: function (root, componentType) {
	    var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
	    if (all.length !== 1) {
	      throw new Error('Did not find exactly one match for componentType:' + componentType + ' (found ' + all.length + ')');
	    }
	    return all[0];
	  },

	  /**
	   * Pass a mocked component module to this method to augment it with
	   * useful methods that allow it to be used as a dummy React component.
	   * Instead of rendering as usual, the component will become a simple
	   * <div> containing any provided children.
	   *
	   * @param {object} module the mock function object exported from a
	   *                        module that defines the component to be mocked
	   * @param {?string} mockTagName optional dummy root tag name to return
	   *                              from render method (overrides
	   *                              module.mockTagName if provided)
	   * @return {object} the ReactTestUtils object (for chaining)
	   */
	  mockComponent: function (module, mockTagName) {
	    mockTagName = mockTagName || module.mockTagName || 'div';

	    module.prototype.render.mockImplementation(function () {
	      return React.createElement(mockTagName, null, this.props.children);
	    });

	    return this;
	  },

	  /**
	   * Simulates a top level event being dispatched from a raw event that occurred
	   * on an `Element` node.
	   * @param {Object} topLevelType A type from `EventConstants.topLevelTypes`
	   * @param {!Element} node The dom to simulate an event occurring on.
	   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
	   */
	  simulateNativeEventOnNode: function (topLevelType, node, fakeNativeEvent) {
	    fakeNativeEvent.target = node;
	    ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
	  },

	  /**
	   * Simulates a top level event being dispatched from a raw event that occurred
	   * on the `ReactDOMComponent` `comp`.
	   * @param {Object} topLevelType A type from `EventConstants.topLevelTypes`.
	   * @param {!ReactDOMComponent} comp
	   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
	   */
	  simulateNativeEventOnDOMComponent: function (topLevelType, comp, fakeNativeEvent) {
	    ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
	  },

	  nativeTouchData: function (x, y) {
	    return {
	      touches: [{ pageX: x, pageY: y }]
	    };
	  },

	  createRenderer: function () {
	    return new ReactShallowRenderer();
	  },

	  Simulate: null,
	  SimulateNative: {}
	};

	/**
	 * @class ReactShallowRenderer
	 */
	var ReactShallowRenderer = function () {
	  this._instance = null;
	};

	ReactShallowRenderer.prototype.getRenderOutput = function () {
	  return this._instance && this._instance._renderedComponent && this._instance._renderedComponent._renderedOutput || null;
	};

	var NoopInternalComponent = function (element) {
	  this._renderedOutput = element;
	  this._currentElement = element;
	};

	NoopInternalComponent.prototype = {

	  mountComponent: function () {},

	  receiveComponent: function (element) {
	    this._renderedOutput = element;
	    this._currentElement = element;
	  },

	  unmountComponent: function () {},

	  getPublicInstance: function () {
	    return null;
	  }
	};

	var ShallowComponentWrapper = function () {};
	assign(ShallowComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: function (element) {
	    return new NoopInternalComponent(element);
	  },
	  _replaceNodeWithMarkupByID: function () {},
	  _renderValidatedComponent: ReactCompositeComponent.Mixin._renderValidatedComponentWithoutOwnerOrContext
	});

	ReactShallowRenderer.prototype.render = function (element, context) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Invalid component element.%s', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : invariant(false) : undefined;
	  !(typeof element.type !== 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Shallow rendering works only with custom ' + 'components, not primitives (%s). Instead of calling `.render(el)` and ' + 'inspecting the rendered output, look at `el.props` directly instead.', element.type) : invariant(false) : undefined;

	  if (!context) {
	    context = emptyObject;
	  }
	  ReactUpdates.batchedUpdates(_batchedRender, this, element, context);
	};

	function _batchedRender(renderer, element, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(false);
	  renderer._render(element, transaction, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}

	ReactShallowRenderer.prototype.unmount = function () {
	  if (this._instance) {
	    this._instance.unmountComponent();
	  }
	};

	ReactShallowRenderer.prototype._render = function (element, transaction, context) {
	  if (this._instance) {
	    this._instance.receiveComponent(element, transaction, context);
	  } else {
	    var rootID = ReactInstanceHandles.createReactRootID();
	    var instance = new ShallowComponentWrapper(element.type);
	    instance.construct(element);

	    instance.mountComponent(rootID, transaction, context);

	    this._instance = instance;
	  }
	};

	/**
	 * Exports:
	 *
	 * - `ReactTestUtils.Simulate.click(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.Simulate.mouseMove(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.Simulate.change(Element/ReactDOMComponent)`
	 * - ... (All keys from event plugin `eventTypes` objects)
	 */
	function makeSimulator(eventType) {
	  return function (domComponentOrNode, eventData) {
	    var node;
	    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
	      node = findDOMNode(domComponentOrNode);
	    } else if (domComponentOrNode.tagName) {
	      node = domComponentOrNode;
	    }

	    var dispatchConfig = ReactBrowserEventEmitter.eventNameDispatchConfigs[eventType];

	    var fakeNativeEvent = new Event();
	    fakeNativeEvent.target = node;
	    // We don't use SyntheticEvent.getPooled in order to not have to worry about
	    // properly destroying any properties assigned from `eventData` upon release
	    var event = new SyntheticEvent(dispatchConfig, ReactMount.getID(node), fakeNativeEvent, node);
	    assign(event, eventData);

	    if (dispatchConfig.phasedRegistrationNames) {
	      EventPropagators.accumulateTwoPhaseDispatches(event);
	    } else {
	      EventPropagators.accumulateDirectDispatches(event);
	    }

	    ReactUpdates.batchedUpdates(function () {
	      EventPluginHub.enqueueEvents(event);
	      EventPluginHub.processEventQueue(true);
	    });
	  };
	}

	function buildSimulators() {
	  ReactTestUtils.Simulate = {};

	  var eventType;
	  for (eventType in ReactBrowserEventEmitter.eventNameDispatchConfigs) {
	    /**
	     * @param {!Element|ReactDOMComponent} domComponentOrNode
	     * @param {?object} eventData Fake event data to use in SyntheticEvent.
	     */
	    ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
	  }
	}

	// Rebuild ReactTestUtils.Simulate whenever event plugins are injected
	var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
	EventPluginHub.injection.injectEventPluginOrder = function () {
	  oldInjectEventPluginOrder.apply(this, arguments);
	  buildSimulators();
	};
	var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
	EventPluginHub.injection.injectEventPluginsByName = function () {
	  oldInjectEventPlugins.apply(this, arguments);
	  buildSimulators();
	};

	buildSimulators();

	/**
	 * Exports:
	 *
	 * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`
	 * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`
	 * - ... (All keys from `EventConstants.topLevelTypes`)
	 *
	 * Note: Top level event types are a subset of the entire set of handler types
	 * (which include a broader set of "synthetic" events). For example, onDragDone
	 * is a synthetic event. Except when testing an event plugin or React's event
	 * handling code specifically, you probably want to use ReactTestUtils.Simulate
	 * to dispatch synthetic events.
	 */

	function makeNativeSimulator(eventType) {
	  return function (domComponentOrNode, nativeEventData) {
	    var fakeNativeEvent = new Event(eventType);
	    assign(fakeNativeEvent, nativeEventData);
	    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
	      ReactTestUtils.simulateNativeEventOnDOMComponent(eventType, domComponentOrNode, fakeNativeEvent);
	    } else if (domComponentOrNode.tagName) {
	      // Will allow on actual dom nodes.
	      ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
	    }
	  };
	}

	Object.keys(topLevelTypes).forEach(function (eventType) {
	  // Event type is stored as 'topClick' - we transform that to 'click'
	  var convenienceName = eventType.indexOf('top') === 0 ? eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
	  /**
	   * @param {!Element|ReactDOMComponent} domComponentOrNode
	   * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.
	   */
	  ReactTestUtils.SimulateNative[convenienceName] = makeNativeSimulator(eventType);
	});

	module.exports = ReactTestUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	'use strict';

	var isObject = __webpack_require__(292);

	function isObjectObject(o) {
	  return isObject(o) === true
	    && Object.prototype.toString.call(o) === '[object Object]';
	}

	module.exports = function isPlainObject(o) {
	  var ctor,prot;
	  
	  if (isObjectObject(o) === false) return false;
	  
	  // If has modified constructor
	  ctor = o.constructor;
	  if (typeof ctor !== 'function') return false;
	  
	  // If has modified prototype
	  prot = ctor.prototype;
	  if (isObjectObject(prot) === false) return false;
	  
	  // If constructor does not have an Object-specific method
	  if (prot.hasOwnProperty('isPrototypeOf') === false) {
	    return false;
	  }
	  
	  // Most likely a plain Object
	  return true;
	};


/***/ },
/* 292 */
/***/ function(module, exports) {

	/*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	'use strict';

	module.exports = function isObject(val) {
	  return val != null && typeof val === 'object'
	    && !Array.isArray(val);
	};


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isRegexp = __webpack_require__(294);
	var isPlainObj = __webpack_require__(295);

	module.exports = function (val, opts, pad) {
		var seen = [];

		return (function stringify(val, opts, pad) {
			opts = opts || {};
			opts.indent = opts.indent || '\t';
			pad = pad || '';

			if (val === null ||
				val === undefined ||
				typeof val === 'number' ||
				typeof val === 'boolean' ||
				typeof val === 'function' ||
				isRegexp(val)) {
				return String(val);
			}

			if (val instanceof Date) {
				return 'new Date(\'' + val.toISOString() + '\')';
			}

			if (Array.isArray(val)) {
				if (val.length === 0) {
					return '[]';
				}

				return '[\n' + val.map(function (el, i) {
					var eol = val.length - 1 === i ? '\n' : ',\n';
					return pad + opts.indent + stringify(el, opts, pad + opts.indent) + eol;
				}).join('') + pad + ']';
			}

			if (isPlainObj(val)) {
				if (seen.indexOf(val) !== -1) {
					return '"[Circular]"';
				}

				var objKeys = Object.keys(val);

				if (objKeys.length === 0) {
					return '{}';
				}

				seen.push(val);

				var ret = '{\n' + objKeys.map(function (el, i) {
					if (opts.filter && !opts.filter(val, el)) {
						return '';
					}

					var eol = objKeys.length - 1 === i ? '\n' : ',\n';
					var key = /^[a-z$_][a-z$_0-9]*$/i.test(el) ? el : stringify(el, opts);
					return pad + opts.indent + key + ': ' + stringify(val[el], opts, pad + opts.indent) + eol;
				}).join('') + pad + '}';

				seen.pop(val);

				return ret;
			}

			val = String(val).replace(/[\r\n]/g, function (x) {
				return x === '\n' ? '\\n' : '\\r';
			});

			if (opts.singleQuotes === false) {
				return '"' + val.replace(/"/g, '\\\"') + '"';
			}

			return '\'' + val.replace(/'/g, '\\\'') + '\'';
		})(val, opts, pad);
	};


/***/ },
/* 294 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (re) {
		return Object.prototype.toString.call(re) === '[object RegExp]';
	};


/***/ },
/* 295 */
/***/ function(module, exports) {

	'use strict';
	var toString = Object.prototype.toString;

	module.exports = function (x) {
		var prototype;
		return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
	};


/***/ },
/* 296 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.6.3
	(function() {
	  var sortObject;

	  sortObject = function(obj, comparator) {
	    var key, result, sortedKeys, value, _i, _j, _len, _len1;
	    if (Array.isArray(obj)) {
	      result = [];
	      for (_i = 0, _len = obj.length; _i < _len; _i++) {
	        value = obj[_i];
	        if ((value != null) && typeof value === 'object') {
	          value = sortObject(value, comparator);
	        }
	        result.push(value);
	      }
	    } else {
	      result = {};
	      sortedKeys = Object.keys(obj).sort(comparator);
	      for (_j = 0, _len1 = sortedKeys.length; _j < _len1; _j++) {
	        key = sortedKeys[_j];
	        value = obj[key];
	        if ((value != null) && typeof value === 'object') {
	          value = sortObject(value, comparator);
	        }
	        result[key] = value;
	      }
	    }
	    return result;
	  };

	  module.exports = sortObject;

	}).call(this);


/***/ },
/* 297 */
/***/ function(module, exports) {

	var traverse = module.exports = function (obj) {
	    return new Traverse(obj);
	};

	function Traverse (obj) {
	    this.value = obj;
	}

	Traverse.prototype.get = function (ps) {
	    var node = this.value;
	    for (var i = 0; i < ps.length; i ++) {
	        var key = ps[i];
	        if (!node || !hasOwnProperty.call(node, key)) {
	            node = undefined;
	            break;
	        }
	        node = node[key];
	    }
	    return node;
	};

	Traverse.prototype.has = function (ps) {
	    var node = this.value;
	    for (var i = 0; i < ps.length; i ++) {
	        var key = ps[i];
	        if (!node || !hasOwnProperty.call(node, key)) {
	            return false;
	        }
	        node = node[key];
	    }
	    return true;
	};

	Traverse.prototype.set = function (ps, value) {
	    var node = this.value;
	    for (var i = 0; i < ps.length - 1; i ++) {
	        var key = ps[i];
	        if (!hasOwnProperty.call(node, key)) node[key] = {};
	        node = node[key];
	    }
	    node[ps[i]] = value;
	    return value;
	};

	Traverse.prototype.map = function (cb) {
	    return walk(this.value, cb, true);
	};

	Traverse.prototype.forEach = function (cb) {
	    this.value = walk(this.value, cb, false);
	    return this.value;
	};

	Traverse.prototype.reduce = function (cb, init) {
	    var skip = arguments.length === 1;
	    var acc = skip ? this.value : init;
	    this.forEach(function (x) {
	        if (!this.isRoot || !skip) {
	            acc = cb.call(this, acc, x);
	        }
	    });
	    return acc;
	};

	Traverse.prototype.paths = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.path); 
	    });
	    return acc;
	};

	Traverse.prototype.nodes = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.node);
	    });
	    return acc;
	};

	Traverse.prototype.clone = function () {
	    var parents = [], nodes = [];
	    
	    return (function clone (src) {
	        for (var i = 0; i < parents.length; i++) {
	            if (parents[i] === src) {
	                return nodes[i];
	            }
	        }
	        
	        if (typeof src === 'object' && src !== null) {
	            var dst = copy(src);
	            
	            parents.push(src);
	            nodes.push(dst);
	            
	            forEach(objectKeys(src), function (key) {
	                dst[key] = clone(src[key]);
	            });
	            
	            parents.pop();
	            nodes.pop();
	            return dst;
	        }
	        else {
	            return src;
	        }
	    })(this.value);
	};

	function walk (root, cb, immutable) {
	    var path = [];
	    var parents = [];
	    var alive = true;
	    
	    return (function walker (node_) {
	        var node = immutable ? copy(node_) : node_;
	        var modifiers = {};
	        
	        var keepGoing = true;
	        
	        var state = {
	            node : node,
	            node_ : node_,
	            path : [].concat(path),
	            parent : parents[parents.length - 1],
	            parents : parents,
	            key : path.slice(-1)[0],
	            isRoot : path.length === 0,
	            level : path.length,
	            circular : null,
	            update : function (x, stopHere) {
	                if (!state.isRoot) {
	                    state.parent.node[state.key] = x;
	                }
	                state.node = x;
	                if (stopHere) keepGoing = false;
	            },
	            'delete' : function (stopHere) {
	                delete state.parent.node[state.key];
	                if (stopHere) keepGoing = false;
	            },
	            remove : function (stopHere) {
	                if (isArray(state.parent.node)) {
	                    state.parent.node.splice(state.key, 1);
	                }
	                else {
	                    delete state.parent.node[state.key];
	                }
	                if (stopHere) keepGoing = false;
	            },
	            keys : null,
	            before : function (f) { modifiers.before = f },
	            after : function (f) { modifiers.after = f },
	            pre : function (f) { modifiers.pre = f },
	            post : function (f) { modifiers.post = f },
	            stop : function () { alive = false },
	            block : function () { keepGoing = false }
	        };
	        
	        if (!alive) return state;
	        
	        function updateState() {
	            if (typeof state.node === 'object' && state.node !== null) {
	                if (!state.keys || state.node_ !== state.node) {
	                    state.keys = objectKeys(state.node)
	                }
	                
	                state.isLeaf = state.keys.length == 0;
	                
	                for (var i = 0; i < parents.length; i++) {
	                    if (parents[i].node_ === node_) {
	                        state.circular = parents[i];
	                        break;
	                    }
	                }
	            }
	            else {
	                state.isLeaf = true;
	                state.keys = null;
	            }
	            
	            state.notLeaf = !state.isLeaf;
	            state.notRoot = !state.isRoot;
	        }
	        
	        updateState();
	        
	        // use return values to update if defined
	        var ret = cb.call(state, state.node);
	        if (ret !== undefined && state.update) state.update(ret);
	        
	        if (modifiers.before) modifiers.before.call(state, state.node);
	        
	        if (!keepGoing) return state;
	        
	        if (typeof state.node == 'object'
	        && state.node !== null && !state.circular) {
	            parents.push(state);
	            
	            updateState();
	            
	            forEach(state.keys, function (key, i) {
	                path.push(key);
	                
	                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
	                
	                var child = walker(state.node[key]);
	                if (immutable && hasOwnProperty.call(state.node, key)) {
	                    state.node[key] = child.node;
	                }
	                
	                child.isLast = i == state.keys.length - 1;
	                child.isFirst = i == 0;
	                
	                if (modifiers.post) modifiers.post.call(state, child);
	                
	                path.pop();
	            });
	            parents.pop();
	        }
	        
	        if (modifiers.after) modifiers.after.call(state, state.node);
	        
	        return state;
	    })(root).node;
	}

	function copy (src) {
	    if (typeof src === 'object' && src !== null) {
	        var dst;
	        
	        if (isArray(src)) {
	            dst = [];
	        }
	        else if (isDate(src)) {
	            dst = new Date(src.getTime ? src.getTime() : src);
	        }
	        else if (isRegExp(src)) {
	            dst = new RegExp(src);
	        }
	        else if (isError(src)) {
	            dst = { message: src.message };
	        }
	        else if (isBoolean(src)) {
	            dst = new Boolean(src);
	        }
	        else if (isNumber(src)) {
	            dst = new Number(src);
	        }
	        else if (isString(src)) {
	            dst = new String(src);
	        }
	        else if (Object.create && Object.getPrototypeOf) {
	            dst = Object.create(Object.getPrototypeOf(src));
	        }
	        else if (src.constructor === Object) {
	            dst = {};
	        }
	        else {
	            var proto =
	                (src.constructor && src.constructor.prototype)
	                || src.__proto__
	                || {}
	            ;
	            var T = function () {};
	            T.prototype = proto;
	            dst = new T;
	        }
	        
	        forEach(objectKeys(src), function (key) {
	            dst[key] = src[key];
	        });
	        return dst;
	    }
	    else return src;
	}

	var objectKeys = Object.keys || function keys (obj) {
	    var res = [];
	    for (var key in obj) res.push(key)
	    return res;
	};

	function toS (obj) { return Object.prototype.toString.call(obj) }
	function isDate (obj) { return toS(obj) === '[object Date]' }
	function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
	function isError (obj) { return toS(obj) === '[object Error]' }
	function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
	function isNumber (obj) { return toS(obj) === '[object Number]' }
	function isString (obj) { return toS(obj) === '[object String]' }

	var isArray = Array.isArray || function isArray (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	forEach(objectKeys(Traverse.prototype), function (key) {
	    traverse[key] = function (obj) {
	        var args = [].slice.call(arguments, 1);
	        var t = new Traverse(obj);
	        return t[key].apply(t, args);
	    };
	});

	var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
	    return key in obj;
	};


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	var baseFill = __webpack_require__(299),
	    isIterateeCall = __webpack_require__(300);

	/**
	 * Fills elements of `array` with `value` from `start` up to, but not
	 * including, `end`.
	 *
	 * **Note:** This method mutates `array`.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to fill.
	 * @param {*} value The value to fill `array` with.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = [1, 2, 3];
	 *
	 * _.fill(array, 'a');
	 * console.log(array);
	 * // => ['a', 'a', 'a']
	 *
	 * _.fill(Array(3), 2);
	 * // => [2, 2, 2]
	 *
	 * _.fill([4, 6, 8], '*', 1, 2);
	 * // => [4, '*', 8]
	 */
	function fill(array, value, start, end) {
	  var length = array ? array.length : 0;
	  if (!length) {
	    return [];
	  }
	  if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	    start = 0;
	    end = length;
	  }
	  return baseFill(array, value, start, end);
	}

	module.exports = fill;


/***/ },
/* 299 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.fill` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to fill.
	 * @param {*} value The value to fill `array` with.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns `array`.
	 */
	function baseFill(array, value, start, end) {
	  var length = array.length;

	  start = start == null ? 0 : (+start || 0);
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = (end === undefined || end > length) ? length : (+end || 0);
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : (end >>> 0);
	  start >>>= 0;

	  while (start < length) {
	    array[start++] = value;
	  }
	  return array;
	}

	module.exports = baseFill;


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(301),
	    isIndex = __webpack_require__(305),
	    isObject = __webpack_require__(306);

	/**
	 * Checks if the provided arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	      ? (isArrayLike(object) && isIndex(index, object.length))
	      : (type == 'string' && index in object)) {
	    var other = object[index];
	    return value === value ? (value === other) : (other !== other);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var getLength = __webpack_require__(302),
	    isLength = __webpack_require__(304);

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	module.exports = isArrayLike;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(303);

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	module.exports = getLength;


/***/ },
/* 303 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ },
/* 304 */
/***/ function(module, exports) {

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 305 */
/***/ function(module, exports) {

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	module.exports = isIndex;


/***/ },
/* 306 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ }
/******/ ]);